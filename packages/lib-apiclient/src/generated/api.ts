/* tslint:disable */
/* eslint-disable */
/**
 * Takaro API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: unset - unset 
 * Contact: support@takaro.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration.js';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
import type { RequestArgs } from './base.js';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base.js';

/**
 * 
 * @export
 * @interface APIOutput
 */
export interface APIOutput {
    /**
     * 
     * @type {MetadataOutput}
     * @memberof APIOutput
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ActivityInputDTO
 */
export interface ActivityInputDTO {
    /**
     * 
     * @type {string}
     * @memberof ActivityInputDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActivityInputDTO
     */
    'timeType': ActivityInputDTOTimeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ActivityInputDTO
     */
    'dataType': ActivityInputDTODataTypeEnum;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof ActivityInputDTO
     */
    'startDate'?: StatsControllerGetPingStatsStartDateParameter;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof ActivityInputDTO
     */
    'endDate'?: StatsControllerGetPingStatsStartDateParameter;
}

export const ActivityInputDTOTimeTypeEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type ActivityInputDTOTimeTypeEnum = typeof ActivityInputDTOTimeTypeEnum[keyof typeof ActivityInputDTOTimeTypeEnum];
export const ActivityInputDTODataTypeEnum = {
    Users: 'users',
    Players: 'players'
} as const;

export type ActivityInputDTODataTypeEnum = typeof ActivityInputDTODataTypeEnum[keyof typeof ActivityInputDTODataTypeEnum];

/**
 * 
 * @export
 * @interface AllowedFilters
 */
export interface AllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof AllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BanCreateDTO
 */
export interface BanCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof BanCreateDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof BanCreateDTO
     */
    'playerId': string;
    /**
     * 
     * @type {boolean}
     * @memberof BanCreateDTO
     */
    'takaroManaged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BanCreateDTO
     */
    'isGlobal'?: boolean;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanCreateDTO
     */
    'until'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof BanCreateDTO
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface BanDTO
 */
export interface BanDTO {
    /**
     * 
     * @type {IGamePlayer}
     * @memberof BanDTO
     */
    'player': IGamePlayer;
    /**
     * 
     * @type {string}
     * @memberof BanDTO
     */
    'reason': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanDTO
     */
    'expiresAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface BanOutputArrayDTOAPI
 */
export interface BanOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<BanOutputDTO>}
     * @memberof BanOutputArrayDTOAPI
     */
    'data': Array<BanOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof BanOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface BanOutputDTO
 */
export interface BanOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof BanOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BanOutputDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof BanOutputDTO
     */
    'playerId': string;
    /**
     * 
     * @type {boolean}
     * @memberof BanOutputDTO
     */
    'takaroManaged': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BanOutputDTO
     */
    'isGlobal': boolean;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanOutputDTO
     */
    'until'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof BanOutputDTO
     */
    'reason'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface BanOutputDTOAPI
 */
export interface BanOutputDTOAPI {
    /**
     * 
     * @type {BanOutputDTO}
     * @memberof BanOutputDTOAPI
     */
    'data': BanOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof BanOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface BanPlayerInputDTO
 */
export interface BanPlayerInputDTO {
    /**
     * 
     * @type {string}
     * @memberof BanPlayerInputDTO
     */
    'reason'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanPlayerInputDTO
     */
    'expiresAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface BanPlayerOutputDTO
 */
export interface BanPlayerOutputDTO {
    /**
     * 
     * @type {Array<BanDTO>}
     * @memberof BanPlayerOutputDTO
     */
    'data': Array<BanDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof BanPlayerOutputDTO
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface BanSearchInputAllowedFilters
 */
export interface BanSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof BanSearchInputAllowedFilters
     */
    'gameServerId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BanSearchInputAllowedFilters
     */
    'playerId'?: Array<string>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof BanSearchInputAllowedFilters
     */
    'takaroManaged'?: Array<boolean>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof BanSearchInputAllowedFilters
     */
    'isGlobal'?: Array<boolean>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BanSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BanSearchInputAllowedRangeFilter
 */
export interface BanSearchInputAllowedRangeFilter {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanSearchInputAllowedRangeFilter
     */
    'until'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanSearchInputAllowedRangeFilter
     */
    'createdAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanSearchInputAllowedRangeFilter
     */
    'updatedAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface BanSearchInputDTO
 */
export interface BanSearchInputDTO {
    /**
     * 
     * @type {BanSearchInputAllowedFilters}
     * @memberof BanSearchInputDTO
     */
    'filters'?: BanSearchInputAllowedFilters;
    /**
     * 
     * @type {BanSearchInputAllowedFilters}
     * @memberof BanSearchInputDTO
     */
    'search'?: BanSearchInputAllowedFilters;
    /**
     * 
     * @type {BanSearchInputAllowedRangeFilter}
     * @memberof BanSearchInputDTO
     */
    'greaterThan'?: BanSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {BanSearchInputAllowedRangeFilter}
     * @memberof BanSearchInputDTO
     */
    'lessThan'?: BanSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {number}
     * @memberof BanSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof BanSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof BanSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof BanSearchInputDTO
     */
    'sortDirection'?: BanSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof BanSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const BanSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type BanSearchInputDTOSortDirectionEnum = typeof BanSearchInputDTOSortDirectionEnum[keyof typeof BanSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface BanUpdateDTO
 */
export interface BanUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof BanUpdateDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof BanUpdateDTO
     */
    'playerId': string;
    /**
     * 
     * @type {boolean}
     * @memberof BanUpdateDTO
     */
    'takaroManaged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BanUpdateDTO
     */
    'isGlobal'?: boolean;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BanUpdateDTO
     */
    'until'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof BanUpdateDTO
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface BaseDiscordEvent
 */
export interface BaseDiscordEvent {
    /**
     * 
     * @type {string}
     * @memberof BaseDiscordEvent
     */
    'msg': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BaseDiscordEvent
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface BaseEvent
 */
export interface BaseEvent {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BaseEvent
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface BaseGameEvent
 */
export interface BaseGameEvent {
    /**
     * 
     * @type {string}
     * @memberof BaseGameEvent
     */
    'msg'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BaseGameEvent
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface BaseStatsInputDTO
 */
export interface BaseStatsInputDTO {
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof BaseStatsInputDTO
     */
    'startDate'?: StatsControllerGetPingStatsStartDateParameter;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof BaseStatsInputDTO
     */
    'endDate'?: StatsControllerGetPingStatsStartDateParameter;
}
/**
 * 
 * @export
 * @interface BaseTakaroEvent
 */
export interface BaseTakaroEvent {
    /**
     * 
     * @type {string}
     * @memberof BaseTakaroEvent
     */
    'msg': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof BaseTakaroEvent
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface CommandArgumentCreateDTO
 */
export interface CommandArgumentCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentCreateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentCreateDTO
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentCreateDTO
     */
    'helpText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentCreateDTO
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommandArgumentCreateDTO
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentCreateDTO
     */
    'commandId'?: string;
}
/**
 * 
 * @export
 * @interface CommandArgumentDTOAPI
 */
export interface CommandArgumentDTOAPI {
    /**
     * 
     * @type {CommandArgumentOutputDTO}
     * @memberof CommandArgumentDTOAPI
     */
    'data': CommandArgumentOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof CommandArgumentDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface CommandArgumentOutputDTO
 */
export interface CommandArgumentOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentOutputDTO
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentOutputDTO
     */
    'helpText': string;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentOutputDTO
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {number}
     * @memberof CommandArgumentOutputDTO
     */
    'position': number;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof CommandArgumentOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof CommandArgumentOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface CommandArgumentUpdateDTO
 */
export interface CommandArgumentUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentUpdateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentUpdateDTO
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentUpdateDTO
     */
    'helpText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandArgumentUpdateDTO
     */
    'defaultValue'?: string;
}
/**
 * 
 * @export
 * @interface CommandCreateDTO
 */
export interface CommandCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof CommandCreateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CommandCreateDTO
     */
    'trigger': string;
    /**
     * 
     * @type {string}
     * @memberof CommandCreateDTO
     */
    'helpText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandCreateDTO
     */
    'versionId': string;
    /**
     * 
     * @type {string}
     * @memberof CommandCreateDTO
     */
    'function'?: string;
    /**
     * 
     * @type {Array<CommandArgumentCreateDTO>}
     * @memberof CommandCreateDTO
     */
    'arguments'?: Array<CommandArgumentCreateDTO>;
}
/**
 * 
 * @export
 * @interface CommandExecuteDTOAPI
 */
export interface CommandExecuteDTOAPI {
    /**
     * 
     * @type {CommandOutput}
     * @memberof CommandExecuteDTOAPI
     */
    'data': CommandOutput;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof CommandExecuteDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface CommandExecuteInputDTO
 */
export interface CommandExecuteInputDTO {
    /**
     * 
     * @type {string}
     * @memberof CommandExecuteInputDTO
     */
    'command': string;
}
/**
 * 
 * @export
 * @interface CommandOutput
 */
export interface CommandOutput {
    /**
     * 
     * @type {string}
     * @memberof CommandOutput
     */
    'rawResult': string;
    /**
     * 
     * @type {boolean}
     * @memberof CommandOutput
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof CommandOutput
     */
    'errorMessage'?: string;
}
/**
 * 
 * @export
 * @interface CommandOutputArrayDTOAPI
 */
export interface CommandOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<CommandOutputDTO>}
     * @memberof CommandOutputArrayDTOAPI
     */
    'data': Array<CommandOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof CommandOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface CommandOutputDTO
 */
export interface CommandOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof CommandOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CommandOutputDTO
     */
    'trigger': string;
    /**
     * 
     * @type {string}
     * @memberof CommandOutputDTO
     */
    'helpText': string;
    /**
     * 
     * @type {FunctionOutputDTO}
     * @memberof CommandOutputDTO
     */
    'function': FunctionOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof CommandOutputDTO
     */
    'functionId': string;
    /**
     * 
     * @type {string}
     * @memberof CommandOutputDTO
     */
    'versionId': string;
    /**
     * 
     * @type {Array<CommandArgumentOutputDTO>}
     * @memberof CommandOutputDTO
     */
    'arguments': Array<CommandArgumentOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof CommandOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof CommandOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof CommandOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface CommandOutputDTOAPI
 */
export interface CommandOutputDTOAPI {
    /**
     * 
     * @type {CommandOutputDTO}
     * @memberof CommandOutputDTOAPI
     */
    'data': CommandOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof CommandOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface CommandSearchInputAllowedFilters
 */
export interface CommandSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof CommandSearchInputAllowedFilters
     */
    'moduleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommandSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof CommandSearchInputAllowedFilters
     */
    'enabled'?: Array<boolean>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommandSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CommandSearchInputDTO
 */
export interface CommandSearchInputDTO {
    /**
     * 
     * @type {CommandSearchInputAllowedFilters}
     * @memberof CommandSearchInputDTO
     */
    'filters'?: CommandSearchInputAllowedFilters;
    /**
     * 
     * @type {CommandSearchInputAllowedFilters}
     * @memberof CommandSearchInputDTO
     */
    'search'?: CommandSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof CommandSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof CommandSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof CommandSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof CommandSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommandSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandSearchInputDTO
     */
    'sortDirection'?: CommandSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CommandSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const CommandSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type CommandSearchInputDTOSortDirectionEnum = typeof CommandSearchInputDTOSortDirectionEnum[keyof typeof CommandSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface CommandTriggerDTO
 */
export interface CommandTriggerDTO {
    /**
     * 
     * @type {string}
     * @memberof CommandTriggerDTO
     */
    'playerId': string;
    /**
     * 
     * @type {string}
     * @memberof CommandTriggerDTO
     */
    'msg': string;
}
/**
 * 
 * @export
 * @interface CommandUpdateDTO
 */
export interface CommandUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof CommandUpdateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandUpdateDTO
     */
    'trigger'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandUpdateDTO
     */
    'helpText'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommandUpdateDTO
     */
    'function'?: string;
    /**
     * 
     * @type {Array<CommandArgumentCreateDTO>}
     * @memberof CommandUpdateDTO
     */
    'arguments'?: Array<CommandArgumentCreateDTO>;
}
/**
 * 
 * @export
 * @interface CountryStatsInputDTO
 */
export interface CountryStatsInputDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof CountryStatsInputDTO
     */
    'gameServerId'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CronJobCreateDTO
 */
export interface CronJobCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof CronJobCreateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobCreateDTO
     */
    'temporalValue': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobCreateDTO
     */
    'versionId': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobCreateDTO
     */
    'function'?: string;
}
/**
 * 
 * @export
 * @interface CronJobOutputArrayDTOAPI
 */
export interface CronJobOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<CronJobOutputDTO>}
     * @memberof CronJobOutputArrayDTOAPI
     */
    'data': Array<CronJobOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof CronJobOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface CronJobOutputDTO
 */
export interface CronJobOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof CronJobOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobOutputDTO
     */
    'temporalValue': string;
    /**
     * 
     * @type {FunctionOutputDTO}
     * @memberof CronJobOutputDTO
     */
    'function': FunctionOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof CronJobOutputDTO
     */
    'versionId': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof CronJobOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof CronJobOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface CronJobOutputDTOAPI
 */
export interface CronJobOutputDTOAPI {
    /**
     * 
     * @type {CronJobOutputDTO}
     * @memberof CronJobOutputDTOAPI
     */
    'data': CronJobOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof CronJobOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface CronJobSearchInputAllowedFilters
 */
export interface CronJobSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof CronJobSearchInputAllowedFilters
     */
    'moduleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CronJobSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CronJobSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CronJobSearchInputDTO
 */
export interface CronJobSearchInputDTO {
    /**
     * 
     * @type {CronJobSearchInputAllowedFilters}
     * @memberof CronJobSearchInputDTO
     */
    'filters'?: CronJobSearchInputAllowedFilters;
    /**
     * 
     * @type {CronJobSearchInputAllowedFilters}
     * @memberof CronJobSearchInputDTO
     */
    'search'?: CronJobSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof CronJobSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof CronJobSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof CronJobSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof CronJobSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof CronJobSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof CronJobSearchInputDTO
     */
    'sortDirection'?: CronJobSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CronJobSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const CronJobSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type CronJobSearchInputDTOSortDirectionEnum = typeof CronJobSearchInputDTOSortDirectionEnum[keyof typeof CronJobSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface CronJobTriggerDTO
 */
export interface CronJobTriggerDTO {
    /**
     * 
     * @type {string}
     * @memberof CronJobTriggerDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobTriggerDTO
     */
    'cronjobId': string;
    /**
     * 
     * @type {string}
     * @memberof CronJobTriggerDTO
     */
    'moduleId': string;
}
/**
 * 
 * @export
 * @interface CronJobUpdateDTO
 */
export interface CronJobUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof CronJobUpdateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CronJobUpdateDTO
     */
    'temporalValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof CronJobUpdateDTO
     */
    'function'?: string;
}
/**
 * 
 * @export
 * @interface DiscordInviteOutputDTO
 */
export interface DiscordInviteOutputDTO {
    /**
     * 
     * @type {InviteOutputDTO}
     * @memberof DiscordInviteOutputDTO
     */
    'data': InviteOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof DiscordInviteOutputDTO
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface DiscordParamId
 */
export interface DiscordParamId {
    /**
     * 
     * @type {string}
     * @memberof DiscordParamId
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DomainCreateInputDTO
 */
export interface DomainCreateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof DomainCreateInputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DomainCreateInputDTO
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainCreateInputDTO
     */
    'state'?: DomainCreateInputDTOStateEnum;
    /**
     * 
     * @type {string}
     * @memberof DomainCreateInputDTO
     */
    'externalReference'?: string;
}

export const DomainCreateInputDTOStateEnum = {
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Maintenance: 'MAINTENANCE'
} as const;

export type DomainCreateInputDTOStateEnum = typeof DomainCreateInputDTOStateEnum[keyof typeof DomainCreateInputDTOStateEnum];

/**
 * 
 * @export
 * @interface DomainCreateOutputDTO
 */
export interface DomainCreateOutputDTO {
    /**
     * 
     * @type {DomainOutputDTO}
     * @memberof DomainCreateOutputDTO
     */
    'createdDomain': DomainOutputDTO;
    /**
     * 
     * @type {UserOutputDTO}
     * @memberof DomainCreateOutputDTO
     */
    'rootUser': UserOutputDTO;
    /**
     * 
     * @type {RoleOutputDTO}
     * @memberof DomainCreateOutputDTO
     */
    'rootRole': RoleOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof DomainCreateOutputDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface DomainCreateOutputDTOAPI
 */
export interface DomainCreateOutputDTOAPI {
    /**
     * 
     * @type {DomainCreateOutputDTO}
     * @memberof DomainCreateOutputDTOAPI
     */
    'data': DomainCreateOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof DomainCreateOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface DomainOutputArrayDTOAPI
 */
export interface DomainOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<DomainOutputDTO>}
     * @memberof DomainOutputArrayDTOAPI
     */
    'data': Array<DomainOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof DomainOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface DomainOutputDTO
 */
export interface DomainOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof DomainOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DomainOutputDTO
     */
    'externalReference': string;
    /**
     * 
     * @type {string}
     * @memberof DomainOutputDTO
     */
    'state': DomainOutputDTOStateEnum;
    /**
     * 
     * @type {number}
     * @memberof DomainOutputDTO
     */
    'rateLimitPoints': number;
    /**
     * 
     * @type {number}
     * @memberof DomainOutputDTO
     */
    'rateLimitDuration': number;
    /**
     * 
     * @type {string}
     * @memberof DomainOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof DomainOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof DomainOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}

export const DomainOutputDTOStateEnum = {
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Maintenance: 'MAINTENANCE'
} as const;

export type DomainOutputDTOStateEnum = typeof DomainOutputDTOStateEnum[keyof typeof DomainOutputDTOStateEnum];

/**
 * 
 * @export
 * @interface DomainOutputDTOAPI
 */
export interface DomainOutputDTOAPI {
    /**
     * 
     * @type {DomainOutputDTO}
     * @memberof DomainOutputDTOAPI
     */
    'data': DomainOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof DomainOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface DomainSearchInputAllowedFilters
 */
export interface DomainSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof DomainSearchInputAllowedFilters
     */
    'id'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DomainSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DomainSearchInputAllowedFilters
     */
    'state'?: Array<DomainSearchInputAllowedFiltersStateEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DomainSearchInputAllowedFilters
     */
    'externalReference'?: Array<string>;
}

export const DomainSearchInputAllowedFiltersStateEnum = {
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Maintenance: 'MAINTENANCE'
} as const;

export type DomainSearchInputAllowedFiltersStateEnum = typeof DomainSearchInputAllowedFiltersStateEnum[keyof typeof DomainSearchInputAllowedFiltersStateEnum];

/**
 * 
 * @export
 * @interface DomainSearchInputDTO
 */
export interface DomainSearchInputDTO {
    /**
     * 
     * @type {DomainSearchInputAllowedFilters}
     * @memberof DomainSearchInputDTO
     */
    'filters'?: DomainSearchInputAllowedFilters;
    /**
     * 
     * @type {DomainSearchInputAllowedFilters}
     * @memberof DomainSearchInputDTO
     */
    'search'?: DomainSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof DomainSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof DomainSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof DomainSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof DomainSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof DomainSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainSearchInputDTO
     */
    'sortDirection'?: DomainSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof DomainSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const DomainSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type DomainSearchInputDTOSortDirectionEnum = typeof DomainSearchInputDTOSortDirectionEnum[keyof typeof DomainSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface DomainUpdateInputDTO
 */
export interface DomainUpdateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof DomainUpdateInputDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainUpdateInputDTO
     */
    'externalReference'?: string;
    /**
     * 
     * @type {string}
     * @memberof DomainUpdateInputDTO
     */
    'state'?: DomainUpdateInputDTOStateEnum;
}

export const DomainUpdateInputDTOStateEnum = {
    Active: 'ACTIVE',
    Disabled: 'DISABLED',
    Maintenance: 'MAINTENANCE'
} as const;

export type DomainUpdateInputDTOStateEnum = typeof DomainUpdateInputDTOStateEnum[keyof typeof DomainUpdateInputDTOStateEnum];

/**
 * 
 * @export
 * @interface ErrorOutput
 */
export interface ErrorOutput {
    /**
     * 
     * @type {string}
     * @memberof ErrorOutput
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorOutput
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorOutput
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface EventChatMessage
 */
export interface EventChatMessage {
    /**
     * 
     * @type {IGamePlayer}
     * @memberof EventChatMessage
     */
    'player': IGamePlayer;
    /**
     * 
     * @type {string}
     * @memberof EventChatMessage
     */
    'channel': EventChatMessageChannelEnum;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof EventChatMessage
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof EventChatMessage
     */
    'msg'?: string;
}

export const EventChatMessageChannelEnum = {
    Global: 'global',
    Team: 'team',
    Friends: 'friends',
    Whisper: 'whisper'
} as const;

export type EventChatMessageChannelEnum = typeof EventChatMessageChannelEnum[keyof typeof EventChatMessageChannelEnum];

/**
 * 
 * @export
 * @interface EventCreateDTO
 */
export interface EventCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof EventCreateDTO
     */
    'eventName': EventCreateDTOEventNameEnum;
    /**
     * 
     * @type {string}
     * @memberof EventCreateDTO
     */
    'moduleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreateDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreateDTO
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreateDTO
     */
    'gameserverId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreateDTO
     */
    'actingUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventCreateDTO
     */
    'actingModuleId'?: string;
    /**
     * 
     * @type {object}
     * @memberof EventCreateDTO
     */
    'meta'?: object;
}

export const EventCreateDTOEventNameEnum = {
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed'
} as const;

export type EventCreateDTOEventNameEnum = typeof EventCreateDTOEventNameEnum[keyof typeof EventCreateDTOEventNameEnum];

/**
 * 
 * @export
 * @interface EventDiscordChannel
 */
export interface EventDiscordChannel {
    /**
     * 
     * @type {string}
     * @memberof EventDiscordChannel
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventDiscordChannel
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface EventDiscordUser
 */
export interface EventDiscordUser {
    /**
     * 
     * @type {string}
     * @memberof EventDiscordUser
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EventDiscordUser
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof EventDiscordUser
     */
    'displayName': string;
    /**
     * 
     * @type {boolean}
     * @memberof EventDiscordUser
     */
    'isBot': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventDiscordUser
     */
    'isTakaroBot': boolean;
}
/**
 * 
 * @export
 * @interface EventEntityKilled
 */
export interface EventEntityKilled {
    /**
     * 
     * @type {IGamePlayer}
     * @memberof EventEntityKilled
     */
    'player': IGamePlayer;
    /**
     * 
     * @type {string}
     * @memberof EventEntityKilled
     */
    'entity': string;
    /**
     * 
     * @type {string}
     * @memberof EventEntityKilled
     */
    'weapon': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof EventEntityKilled
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof EventEntityKilled
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface EventLogLine
 */
export interface EventLogLine {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof EventLogLine
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof EventLogLine
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface EventOutputArrayDTOAPI
 */
export interface EventOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<EventOutputDTO>}
     * @memberof EventOutputArrayDTOAPI
     */
    'data': Array<EventOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof EventOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface EventOutputDTO
 */
export interface EventOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof EventOutputDTO
     */
    'eventName': EventOutputDTOEventNameEnum;
    /**
     * 
     * @type {string}
     * @memberof EventOutputDTO
     */
    'moduleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventOutputDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventOutputDTO
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventOutputDTO
     */
    'gameserverId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventOutputDTO
     */
    'actingUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventOutputDTO
     */
    'actingModuleId'?: string;
    /**
     * 
     * @type {EventOutputDTOMeta}
     * @memberof EventOutputDTO
     */
    'meta'?: EventOutputDTOMeta;
    /**
     * 
     * @type {PlayerOutputDTO}
     * @memberof EventOutputDTO
     */
    'player'?: PlayerOutputDTO;
    /**
     * 
     * @type {GameServerOutputDTO}
     * @memberof EventOutputDTO
     */
    'gameServer'?: GameServerOutputDTO;
    /**
     * 
     * @type {ModuleOutputDTO}
     * @memberof EventOutputDTO
     */
    'module'?: ModuleOutputDTO;
    /**
     * 
     * @type {UserOutputDTO}
     * @memberof EventOutputDTO
     */
    'user'?: UserOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof EventOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof EventOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof EventOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}

export const EventOutputDTOEventNameEnum = {
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed'
} as const;

export type EventOutputDTOEventNameEnum = typeof EventOutputDTOEventNameEnum[keyof typeof EventOutputDTOEventNameEnum];

/**
 * @type EventOutputDTOMeta
 * @export
 */
export type EventOutputDTOMeta = EventChatMessage | EventEntityKilled | EventLogLine | EventPlayerConnected | EventPlayerDeath | EventPlayerDisconnected | HookEventDiscordMessage | TakaroEventCommandExecuted | TakaroEventCronjobExecuted | TakaroEventCurrencyAdded | TakaroEventCurrencyDeducted | TakaroEventHookExecuted | TakaroEventModuleCreated | TakaroEventModuleDeleted | TakaroEventModuleInstalled | TakaroEventModuleUninstalled | TakaroEventModuleUpdated | TakaroEventPlayerCreated | TakaroEventPlayerLinked | TakaroEventPlayerNewIpDetected | TakaroEventRoleAssigned | TakaroEventRoleCreated | TakaroEventRoleDeleted | TakaroEventRoleRemoved | TakaroEventRoleUpdated | TakaroEventServerStatusChanged | TakaroEventSettingsSet | TakaroEventShopListingCreated | TakaroEventShopListingDeleted | TakaroEventShopListingUpdated | TakaroEventShopOrderCreated | TakaroEventShopOrderStatusChanged;

/**
 * 
 * @export
 * @interface EventPlayerConnected
 */
export interface EventPlayerConnected {
    /**
     * 
     * @type {IGamePlayer}
     * @memberof EventPlayerConnected
     */
    'player': IGamePlayer;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof EventPlayerConnected
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof EventPlayerConnected
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface EventPlayerDeath
 */
export interface EventPlayerDeath {
    /**
     * 
     * @type {IGamePlayer}
     * @memberof EventPlayerDeath
     */
    'player': IGamePlayer;
    /**
     * 
     * @type {IGamePlayer}
     * @memberof EventPlayerDeath
     */
    'attacker'?: IGamePlayer;
    /**
     * 
     * @type {IPosition}
     * @memberof EventPlayerDeath
     */
    'position'?: IPosition;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof EventPlayerDeath
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof EventPlayerDeath
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface EventPlayerDisconnected
 */
export interface EventPlayerDisconnected {
    /**
     * 
     * @type {IGamePlayer}
     * @memberof EventPlayerDisconnected
     */
    'player': IGamePlayer;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof EventPlayerDisconnected
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof EventPlayerDisconnected
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface EventSearchInputAllowedFilters
 */
export interface EventSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSearchInputAllowedFilters
     */
    'id'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSearchInputAllowedFilters
     */
    'eventName'?: Array<EventSearchInputAllowedFiltersEventNameEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSearchInputAllowedFilters
     */
    'moduleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSearchInputAllowedFilters
     */
    'playerId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSearchInputAllowedFilters
     */
    'gameserverId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSearchInputAllowedFilters
     */
    'actingUserId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSearchInputAllowedFilters
     */
    'actingModuleId'?: Array<string>;
}

export const EventSearchInputAllowedFiltersEventNameEnum = {
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed'
} as const;

export type EventSearchInputAllowedFiltersEventNameEnum = typeof EventSearchInputAllowedFiltersEventNameEnum[keyof typeof EventSearchInputAllowedFiltersEventNameEnum];

/**
 * 
 * @export
 * @interface EventSearchInputDTO
 */
export interface EventSearchInputDTO {
    /**
     * 
     * @type {EventSearchInputAllowedFilters}
     * @memberof EventSearchInputDTO
     */
    'filters'?: EventSearchInputAllowedFilters;
    /**
     * 
     * @type {EventSearchInputAllowedFilters}
     * @memberof EventSearchInputDTO
     */
    'search'?: EventSearchInputAllowedFilters;
    /**
     * 
     * @type {RangeFilterCreatedAndUpdatedAt}
     * @memberof EventSearchInputDTO
     */
    'greaterThan'?: RangeFilterCreatedAndUpdatedAt;
    /**
     * 
     * @type {RangeFilterCreatedAndUpdatedAt}
     * @memberof EventSearchInputDTO
     */
    'lessThan'?: RangeFilterCreatedAndUpdatedAt;
    /**
     * 
     * @type {number}
     * @memberof EventSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof EventSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof EventSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventSearchInputDTO
     */
    'sortDirection'?: EventSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const EventSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type EventSearchInputDTOSortDirectionEnum = typeof EventSearchInputDTOSortDirectionEnum[keyof typeof EventSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface EventsCountInputDTO
 */
export interface EventsCountInputDTO {
    /**
     * 
     * @type {string}
     * @memberof EventsCountInputDTO
     */
    'eventName': EventsCountInputDTOEventNameEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof EventsCountInputDTO
     */
    'sumBy'?: Array<EventsCountInputDTOSumByEnum>;
    /**
     * 
     * @type {string}
     * @memberof EventsCountInputDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCountInputDTO
     */
    'moduleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCountInputDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCountInputDTO
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof EventsCountInputDTO
     */
    'bucketStep': EventsCountInputDTOBucketStepEnum;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof EventsCountInputDTO
     */
    'startDate'?: StatsControllerGetPingStatsStartDateParameter;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof EventsCountInputDTO
     */
    'endDate'?: StatsControllerGetPingStatsStartDateParameter;
}

export const EventsCountInputDTOEventNameEnum = {
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed'
} as const;

export type EventsCountInputDTOEventNameEnum = typeof EventsCountInputDTOEventNameEnum[keyof typeof EventsCountInputDTOEventNameEnum];
export const EventsCountInputDTOSumByEnum = {
    Player: 'player',
    Module: 'module',
    User: 'user',
    Gameserver: 'gameserver'
} as const;

export type EventsCountInputDTOSumByEnum = typeof EventsCountInputDTOSumByEnum[keyof typeof EventsCountInputDTOSumByEnum];
export const EventsCountInputDTOBucketStepEnum = {
    _5m: '5m',
    _30m: '30m',
    _1h: '1h',
    _6h: '6h',
    _12h: '12h',
    _24h: '24h'
} as const;

export type EventsCountInputDTOBucketStepEnum = typeof EventsCountInputDTOBucketStepEnum[keyof typeof EventsCountInputDTOBucketStepEnum];

/**
 * 
 * @export
 * @interface FunctionCreateDTO
 */
export interface FunctionCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof FunctionCreateDTO
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionCreateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionCreateDTO
     */
    'versionId'?: string;
}
/**
 * 
 * @export
 * @interface FunctionOutputArrayDTOAPI
 */
export interface FunctionOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<FunctionOutputDTO>}
     * @memberof FunctionOutputArrayDTOAPI
     */
    'data': Array<FunctionOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof FunctionOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface FunctionOutputDTO
 */
export interface FunctionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof FunctionOutputDTO
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof FunctionOutputDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionOutputDTO
     */
    'versionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof FunctionOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof FunctionOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface FunctionOutputDTOAPI
 */
export interface FunctionOutputDTOAPI {
    /**
     * 
     * @type {FunctionOutputDTO}
     * @memberof FunctionOutputDTOAPI
     */
    'data': FunctionOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof FunctionOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface FunctionSearchInputAllowedFilters
 */
export interface FunctionSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof FunctionSearchInputAllowedFilters
     */
    'moduleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunctionSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunctionSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FunctionSearchInputDTO
 */
export interface FunctionSearchInputDTO {
    /**
     * 
     * @type {FunctionSearchInputAllowedFilters}
     * @memberof FunctionSearchInputDTO
     */
    'filters'?: FunctionSearchInputAllowedFilters;
    /**
     * 
     * @type {FunctionSearchInputAllowedFilters}
     * @memberof FunctionSearchInputDTO
     */
    'search'?: FunctionSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof FunctionSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof FunctionSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof FunctionSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof FunctionSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof FunctionSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionSearchInputDTO
     */
    'sortDirection'?: FunctionSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunctionSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const FunctionSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type FunctionSearchInputDTOSortDirectionEnum = typeof FunctionSearchInputDTOSortDirectionEnum[keyof typeof FunctionSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface FunctionUpdateDTO
 */
export interface FunctionUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof FunctionUpdateDTO
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionUpdateDTO
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GameServerCreateDTO
 */
export interface GameServerCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof GameServerCreateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GameServerCreateDTO
     */
    'connectionInfo': string;
    /**
     * 
     * @type {string}
     * @memberof GameServerCreateDTO
     */
    'type': GameServerCreateDTOTypeEnum;
}

export const GameServerCreateDTOTypeEnum = {
    Mock: 'MOCK',
    Sevendaystodie: 'SEVENDAYSTODIE',
    Rust: 'RUST'
} as const;

export type GameServerCreateDTOTypeEnum = typeof GameServerCreateDTOTypeEnum[keyof typeof GameServerCreateDTOTypeEnum];

/**
 * 
 * @export
 * @interface GameServerOutputArrayDTOAPI
 */
export interface GameServerOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<GameServerOutputDTO>}
     * @memberof GameServerOutputArrayDTOAPI
     */
    'data': Array<GameServerOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof GameServerOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface GameServerOutputDTO
 */
export interface GameServerOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof GameServerOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof GameServerOutputDTO
     */
    'connectionInfo': object;
    /**
     * 
     * @type {string}
     * @memberof GameServerOutputDTO
     */
    'type': GameServerOutputDTOTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GameServerOutputDTO
     */
    'reachable': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GameServerOutputDTO
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof GameServerOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof GameServerOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof GameServerOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}

export const GameServerOutputDTOTypeEnum = {
    Mock: 'MOCK',
    Sevendaystodie: 'SEVENDAYSTODIE',
    Rust: 'RUST'
} as const;

export type GameServerOutputDTOTypeEnum = typeof GameServerOutputDTOTypeEnum[keyof typeof GameServerOutputDTOTypeEnum];

/**
 * 
 * @export
 * @interface GameServerOutputDTOAPI
 */
export interface GameServerOutputDTOAPI {
    /**
     * 
     * @type {GameServerOutputDTO}
     * @memberof GameServerOutputDTOAPI
     */
    'data': GameServerOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof GameServerOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface GameServerSearchInputAllowedFilters
 */
export interface GameServerSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof GameServerSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameServerSearchInputAllowedFilters
     */
    'type'?: Array<GameServerSearchInputAllowedFiltersTypeEnum>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof GameServerSearchInputAllowedFilters
     */
    'reachable'?: Array<boolean>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof GameServerSearchInputAllowedFilters
     */
    'enabled'?: Array<boolean>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameServerSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}

export const GameServerSearchInputAllowedFiltersTypeEnum = {
    Mock: 'MOCK',
    Sevendaystodie: 'SEVENDAYSTODIE',
    Rust: 'RUST'
} as const;

export type GameServerSearchInputAllowedFiltersTypeEnum = typeof GameServerSearchInputAllowedFiltersTypeEnum[keyof typeof GameServerSearchInputAllowedFiltersTypeEnum];

/**
 * 
 * @export
 * @interface GameServerSearchInputDTO
 */
export interface GameServerSearchInputDTO {
    /**
     * 
     * @type {GameServerSearchInputAllowedFilters}
     * @memberof GameServerSearchInputDTO
     */
    'filters'?: GameServerSearchInputAllowedFilters;
    /**
     * 
     * @type {GameServerSearchInputAllowedFilters}
     * @memberof GameServerSearchInputDTO
     */
    'search'?: GameServerSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof GameServerSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof GameServerSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof GameServerSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GameServerSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof GameServerSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof GameServerSearchInputDTO
     */
    'sortDirection'?: GameServerSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof GameServerSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const GameServerSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type GameServerSearchInputDTOSortDirectionEnum = typeof GameServerSearchInputDTOSortDirectionEnum[keyof typeof GameServerSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface GameServerTestReachabilityDTOAPI
 */
export interface GameServerTestReachabilityDTOAPI {
    /**
     * 
     * @type {TestReachabilityOutputDTO}
     * @memberof GameServerTestReachabilityDTOAPI
     */
    'data': TestReachabilityOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof GameServerTestReachabilityDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface GameServerTestReachabilityInputDTO
 */
export interface GameServerTestReachabilityInputDTO {
    /**
     * 
     * @type {string}
     * @memberof GameServerTestReachabilityInputDTO
     */
    'connectionInfo': string;
    /**
     * 
     * @type {string}
     * @memberof GameServerTestReachabilityInputDTO
     */
    'type': GameServerTestReachabilityInputDTOTypeEnum;
}

export const GameServerTestReachabilityInputDTOTypeEnum = {
    Mock: 'MOCK',
    Sevendaystodie: 'SEVENDAYSTODIE',
    Rust: 'RUST'
} as const;

export type GameServerTestReachabilityInputDTOTypeEnum = typeof GameServerTestReachabilityInputDTOTypeEnum[keyof typeof GameServerTestReachabilityInputDTOTypeEnum];

/**
 * 
 * @export
 * @interface GameServerTypesOutputDTO
 */
export interface GameServerTypesOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof GameServerTypesOutputDTO
     */
    'type': GameServerTypesOutputDTOTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof GameServerTypesOutputDTO
     */
    'connectionInfoSchema': string;
}

export const GameServerTypesOutputDTOTypeEnum = {
    Mock: 'MOCK',
    Sevendaystodie: 'SEVENDAYSTODIE',
    Rust: 'RUST'
} as const;

export type GameServerTypesOutputDTOTypeEnum = typeof GameServerTypesOutputDTOTypeEnum[keyof typeof GameServerTypesOutputDTOTypeEnum];

/**
 * 
 * @export
 * @interface GameServerTypesOutputDTOAPI
 */
export interface GameServerTypesOutputDTOAPI {
    /**
     * 
     * @type {Array<GameServerOutputDTO>}
     * @memberof GameServerTypesOutputDTOAPI
     */
    'data': Array<GameServerOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof GameServerTypesOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface GameServerUpdateDTO
 */
export interface GameServerUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof GameServerUpdateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GameServerUpdateDTO
     */
    'connectionInfo': string;
    /**
     * 
     * @type {string}
     * @memberof GameServerUpdateDTO
     */
    'type': GameServerUpdateDTOTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof GameServerUpdateDTO
     */
    'reachable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GameServerUpdateDTO
     */
    'enabled'?: boolean;
}

export const GameServerUpdateDTOTypeEnum = {
    Mock: 'MOCK',
    Sevendaystodie: 'SEVENDAYSTODIE',
    Rust: 'RUST'
} as const;

export type GameServerUpdateDTOTypeEnum = typeof GameServerUpdateDTOTypeEnum[keyof typeof GameServerUpdateDTOTypeEnum];

/**
 * 
 * @export
 * @interface GetSettingsInput
 */
export interface GetSettingsInput {
    /**
     * 
     * @type {Array<string>}
     * @memberof GetSettingsInput
     */
    'keys'?: Array<GetSettingsInputKeysEnum>;
    /**
     * 
     * @type {string}
     * @memberof GetSettingsInput
     */
    'gameServerId'?: string;
}

export const GetSettingsInputKeysEnum = {
    CommandPrefix: 'commandPrefix',
    ServerChatName: 'serverChatName',
    EconomyEnabled: 'economyEnabled',
    CurrencyName: 'currencyName',
    DeveloperMode: 'developerMode'
} as const;

export type GetSettingsInputKeysEnum = typeof GetSettingsInputKeysEnum[keyof typeof GetSettingsInputKeysEnum];

/**
 * 
 * @export
 * @interface GetSettingsOneInput
 */
export interface GetSettingsOneInput {
    /**
     * 
     * @type {string}
     * @memberof GetSettingsOneInput
     */
    'gameServerId'?: string;
}
/**
 * 
 * @export
 * @interface GetUserDTO
 */
export interface GetUserDTO {
    /**
     * 
     * @type {string}
     * @memberof GetUserDTO
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface GiveItemInputDTO
 */
export interface GiveItemInputDTO {
    /**
     * 
     * @type {string}
     * @memberof GiveItemInputDTO
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof GiveItemInputDTO
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof GiveItemInputDTO
     */
    'quality': string;
}
/**
 * 
 * @export
 * @interface GuildApiUpdateDTO
 */
export interface GuildApiUpdateDTO {
    /**
     * 
     * @type {boolean}
     * @memberof GuildApiUpdateDTO
     */
    'takaroEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface GuildCreateInputDTO
 */
export interface GuildCreateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof GuildCreateInputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GuildCreateInputDTO
     */
    'discordId': string;
    /**
     * 
     * @type {string}
     * @memberof GuildCreateInputDTO
     */
    'icon'?: string;
}
/**
 * 
 * @export
 * @interface GuildOutputArrayDTOAPI
 */
export interface GuildOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<GuildOutputDTO>}
     * @memberof GuildOutputArrayDTOAPI
     */
    'data': Array<GuildOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof GuildOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface GuildOutputDTO
 */
export interface GuildOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof GuildOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof GuildOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof GuildOutputDTO
     */
    'discordId': string;
    /**
     * 
     * @type {boolean}
     * @memberof GuildOutputDTO
     */
    'takaroEnabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof GuildOutputDTO
     */
    'icon'?: string;
}
/**
 * 
 * @export
 * @interface GuildOutputDTOAPI
 */
export interface GuildOutputDTOAPI {
    /**
     * 
     * @type {GuildOutputDTO}
     * @memberof GuildOutputDTOAPI
     */
    'data': GuildOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof GuildOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface GuildSearchInputAllowedFilters
 */
export interface GuildSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof GuildSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GuildSearchInputAllowedFilters
     */
    'discordId'?: Array<string>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof GuildSearchInputAllowedFilters
     */
    'takaroEnabled'?: Array<boolean>;
    /**
     * 
     * @type {Array<string>}
     * @memberof GuildSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GuildSearchInputDTO
 */
export interface GuildSearchInputDTO {
    /**
     * 
     * @type {GuildSearchInputAllowedFilters}
     * @memberof GuildSearchInputDTO
     */
    'filters'?: GuildSearchInputAllowedFilters;
    /**
     * 
     * @type {GuildSearchInputAllowedFilters}
     * @memberof GuildSearchInputDTO
     */
    'search'?: GuildSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof GuildSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof GuildSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof GuildSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GuildSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof GuildSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildSearchInputDTO
     */
    'sortDirection'?: GuildSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof GuildSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const GuildSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type GuildSearchInputDTOSortDirectionEnum = typeof GuildSearchInputDTOSortDirectionEnum[keyof typeof GuildSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface GuildUpdateDTO
 */
export interface GuildUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof GuildUpdateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GuildUpdateDTO
     */
    'icon'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GuildUpdateDTO
     */
    'takaroEnabled'?: boolean;
}
/**
 * 
 * @export
 * @interface HealthOutputDTO
 */
export interface HealthOutputDTO {
    /**
     * 
     * @type {boolean}
     * @memberof HealthOutputDTO
     */
    'healthy': boolean;
}
/**
 * 
 * @export
 * @interface HookCreateDTO
 */
export interface HookCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof HookCreateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HookCreateDTO
     */
    'regex': string;
    /**
     * 
     * @type {string}
     * @memberof HookCreateDTO
     */
    'versionId': string;
    /**
     * 
     * @type {string}
     * @memberof HookCreateDTO
     */
    'eventType': HookCreateDTOEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof HookCreateDTO
     */
    'function'?: string;
}

export const HookCreateDTOEventTypeEnum = {
    Log: 'log',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed',
    DiscordMessage: 'discord-message',
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked'
} as const;

export type HookCreateDTOEventTypeEnum = typeof HookCreateDTOEventTypeEnum[keyof typeof HookCreateDTOEventTypeEnum];

/**
 * 
 * @export
 * @interface HookEventDiscordMessage
 */
export interface HookEventDiscordMessage {
    /**
     * 
     * @type {string}
     * @memberof HookEventDiscordMessage
     */
    'msg': string;
    /**
     * 
     * @type {EventDiscordUser}
     * @memberof HookEventDiscordMessage
     */
    'author': EventDiscordUser;
    /**
     * 
     * @type {EventDiscordChannel}
     * @memberof HookEventDiscordMessage
     */
    'channel': EventDiscordChannel;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof HookEventDiscordMessage
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface HookOutputArrayDTOAPI
 */
export interface HookOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<HookOutputDTO>}
     * @memberof HookOutputArrayDTOAPI
     */
    'data': Array<HookOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof HookOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface HookOutputDTO
 */
export interface HookOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof HookOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HookOutputDTO
     */
    'regex': string;
    /**
     * 
     * @type {FunctionOutputDTO}
     * @memberof HookOutputDTO
     */
    'function': FunctionOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof HookOutputDTO
     */
    'eventType': HookOutputDTOEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof HookOutputDTO
     */
    'versionId': string;
    /**
     * 
     * @type {string}
     * @memberof HookOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof HookOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof HookOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}

export const HookOutputDTOEventTypeEnum = {
    Log: 'log',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed',
    DiscordMessage: 'discord-message',
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked'
} as const;

export type HookOutputDTOEventTypeEnum = typeof HookOutputDTOEventTypeEnum[keyof typeof HookOutputDTOEventTypeEnum];

/**
 * 
 * @export
 * @interface HookOutputDTOAPI
 */
export interface HookOutputDTOAPI {
    /**
     * 
     * @type {HookOutputDTO}
     * @memberof HookOutputDTOAPI
     */
    'data': HookOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof HookOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface HookSearchInputAllowedFilters
 */
export interface HookSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof HookSearchInputAllowedFilters
     */
    'moduleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof HookSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof HookSearchInputAllowedFilters
     */
    'eventType'?: Array<HookSearchInputAllowedFiltersEventTypeEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof HookSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}

export const HookSearchInputAllowedFiltersEventTypeEnum = {
    Log: 'log',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed',
    DiscordMessage: 'discord-message',
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked'
} as const;

export type HookSearchInputAllowedFiltersEventTypeEnum = typeof HookSearchInputAllowedFiltersEventTypeEnum[keyof typeof HookSearchInputAllowedFiltersEventTypeEnum];

/**
 * 
 * @export
 * @interface HookSearchInputDTO
 */
export interface HookSearchInputDTO {
    /**
     * 
     * @type {HookSearchInputAllowedFilters}
     * @memberof HookSearchInputDTO
     */
    'filters'?: HookSearchInputAllowedFilters;
    /**
     * 
     * @type {HookSearchInputAllowedFilters}
     * @memberof HookSearchInputDTO
     */
    'search'?: HookSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof HookSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof HookSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof HookSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof HookSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof HookSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof HookSearchInputDTO
     */
    'sortDirection'?: HookSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof HookSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const HookSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type HookSearchInputDTOSortDirectionEnum = typeof HookSearchInputDTOSortDirectionEnum[keyof typeof HookSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface HookTriggerDTO
 */
export interface HookTriggerDTO {
    /**
     * 
     * @type {string}
     * @memberof HookTriggerDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof HookTriggerDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof HookTriggerDTO
     */
    'moduleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof HookTriggerDTO
     */
    'eventType': HookTriggerDTOEventTypeEnum;
    /**
     * 
     * @type {object}
     * @memberof HookTriggerDTO
     */
    'eventMeta': object;
}

export const HookTriggerDTOEventTypeEnum = {
    Log: 'log',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed',
    DiscordMessage: 'discord-message',
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked'
} as const;

export type HookTriggerDTOEventTypeEnum = typeof HookTriggerDTOEventTypeEnum[keyof typeof HookTriggerDTOEventTypeEnum];

/**
 * 
 * @export
 * @interface HookUpdateDTO
 */
export interface HookUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof HookUpdateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HookUpdateDTO
     */
    'regex'?: string;
    /**
     * 
     * @type {string}
     * @memberof HookUpdateDTO
     */
    'eventType'?: HookUpdateDTOEventTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof HookUpdateDTO
     */
    'function'?: string;
}

export const HookUpdateDTOEventTypeEnum = {
    Log: 'log',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed',
    DiscordMessage: 'discord-message',
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked'
} as const;

export type HookUpdateDTOEventTypeEnum = typeof HookUpdateDTOEventTypeEnum[keyof typeof HookUpdateDTOEventTypeEnum];

/**
 * 
 * @export
 * @interface ICommand
 */
export interface ICommand {
    /**
     * 
     * @type {string}
     * @memberof ICommand
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ICommand
     */
    'function': string;
    /**
     * 
     * @type {string}
     * @memberof ICommand
     */
    'trigger': string;
    /**
     * 
     * @type {string}
     * @memberof ICommand
     */
    'helpText'?: string;
    /**
     * 
     * @type {Array<ICommandArgument>}
     * @memberof ICommand
     */
    'arguments'?: Array<ICommandArgument>;
}
/**
 * 
 * @export
 * @interface ICommandArgument
 */
export interface ICommandArgument {
    /**
     * 
     * @type {string}
     * @memberof ICommandArgument
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ICommandArgument
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ICommandArgument
     */
    'helpText'?: string;
    /**
     * 
     * @type {string}
     * @memberof ICommandArgument
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {number}
     * @memberof ICommandArgument
     */
    'position'?: number;
}
/**
 * 
 * @export
 * @interface ICronJob
 */
export interface ICronJob {
    /**
     * 
     * @type {string}
     * @memberof ICronJob
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ICronJob
     */
    'function': string;
    /**
     * 
     * @type {string}
     * @memberof ICronJob
     */
    'temporalValue': string;
}
/**
 * 
 * @export
 * @interface IFunction
 */
export interface IFunction {
    /**
     * 
     * @type {string}
     * @memberof IFunction
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IFunction
     */
    'function': string;
}
/**
 * 
 * @export
 * @interface IGamePlayer
 */
export interface IGamePlayer {
    /**
     * 
     * @type {string}
     * @memberof IGamePlayer
     */
    'gameId': string;
    /**
     * 
     * @type {string}
     * @memberof IGamePlayer
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IGamePlayer
     */
    'steamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGamePlayer
     */
    'epicOnlineServicesId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGamePlayer
     */
    'xboxLiveId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGamePlayer
     */
    'platformId'?: string;
    /**
     * 
     * @type {string}
     * @memberof IGamePlayer
     */
    'ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof IGamePlayer
     */
    'ping'?: number;
}
/**
 * 
 * @export
 * @interface IHook
 */
export interface IHook {
    /**
     * 
     * @type {string}
     * @memberof IHook
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IHook
     */
    'function': string;
    /**
     * 
     * @type {string}
     * @memberof IHook
     */
    'eventType': IHookEventTypeEnum;
}

export const IHookEventTypeEnum = {
    Log: 'log',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed',
    DiscordMessage: 'discord-message',
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked'
} as const;

export type IHookEventTypeEnum = typeof IHookEventTypeEnum[keyof typeof IHookEventTypeEnum];

/**
 * 
 * @export
 * @interface IItemDTO
 */
export interface IItemDTO {
    /**
     * 
     * @type {string}
     * @memberof IItemDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof IItemDTO
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof IItemDTO
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof IItemDTO
     */
    'amount'?: number;
    /**
     * 
     * @type {string}
     * @memberof IItemDTO
     */
    'quality'?: string;
}
/**
 * 
 * @export
 * @interface IMessageOptsDTO
 */
export interface IMessageOptsDTO {
    /**
     * 
     * @type {IPlayerReferenceDTO}
     * @memberof IMessageOptsDTO
     */
    'recipient': IPlayerReferenceDTO;
}
/**
 * 
 * @export
 * @interface IPermission
 */
export interface IPermission {
    /**
     * 
     * @type {string}
     * @memberof IPermission
     */
    'permission': string;
    /**
     * 
     * @type {string}
     * @memberof IPermission
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof IPermission
     */
    'friendlyName': string;
    /**
     * 
     * @type {boolean}
     * @memberof IPermission
     */
    'canHaveCount'?: boolean;
}
/**
 * 
 * @export
 * @interface IPlayerReferenceDTO
 */
export interface IPlayerReferenceDTO {
    /**
     * 
     * @type {string}
     * @memberof IPlayerReferenceDTO
     */
    'gameId': string;
}
/**
 * 
 * @export
 * @interface IPosition
 */
export interface IPosition {
    /**
     * 
     * @type {number}
     * @memberof IPosition
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof IPosition
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof IPosition
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface ITakaroQuery
 */
export interface ITakaroQuery {
    /**
     * 
     * @type {any}
     * @memberof ITakaroQuery
     */
    'filters'?: any;
    /**
     * 
     * @type {any}
     * @memberof ITakaroQuery
     */
    'search'?: any;
    /**
     * 
     * @type {any}
     * @memberof ITakaroQuery
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof ITakaroQuery
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof ITakaroQuery
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof ITakaroQuery
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ITakaroQuery
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ITakaroQuery
     */
    'sortDirection'?: ITakaroQuerySortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ITakaroQuery
     */
    'extend'?: Array<string>;
}

export const ITakaroQuerySortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ITakaroQuerySortDirectionEnum = typeof ITakaroQuerySortDirectionEnum[keyof typeof ITakaroQuerySortDirectionEnum];

/**
 * 
 * @export
 * @interface ImportInputDTO
 */
export interface ImportInputDTO {
    /**
     * 
     * @type {boolean}
     * @memberof ImportInputDTO
     */
    'roles': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportInputDTO
     */
    'players': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportInputDTO
     */
    'currency': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ImportInputDTO
     */
    'shop': boolean;
}
/**
 * 
 * @export
 * @interface ImportOutputDTO
 */
export interface ImportOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof ImportOutputDTO
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ImportOutputDTOAPI
 */
export interface ImportOutputDTOAPI {
    /**
     * 
     * @type {ImportOutputDTO}
     * @memberof ImportOutputDTOAPI
     */
    'data': ImportOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ImportOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ImportStatusOutputDTO
 */
export interface ImportStatusOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof ImportStatusOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImportStatusOutputDTO
     */
    'status': ImportStatusOutputDTOStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof ImportStatusOutputDTO
     */
    'failedReason'?: string;
}

export const ImportStatusOutputDTOStatusEnum = {
    Pending: 'pending',
    Completed: 'completed',
    Failed: 'failed'
} as const;

export type ImportStatusOutputDTOStatusEnum = typeof ImportStatusOutputDTOStatusEnum[keyof typeof ImportStatusOutputDTOStatusEnum];

/**
 * 
 * @export
 * @interface ImportStatusOutputDTOAPI
 */
export interface ImportStatusOutputDTOAPI {
    /**
     * 
     * @type {ImportStatusOutputDTO}
     * @memberof ImportStatusOutputDTOAPI
     */
    'data': ImportStatusOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ImportStatusOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface InstallModuleDTO
 */
export interface InstallModuleDTO {
    /**
     * 
     * @type {string}
     * @memberof InstallModuleDTO
     */
    'versionId': string;
    /**
     * 
     * @type {string}
     * @memberof InstallModuleDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof InstallModuleDTO
     */
    'userConfig'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstallModuleDTO
     */
    'systemConfig'?: string;
}
/**
 * 
 * @export
 * @interface InviteCreateDTO
 */
export interface InviteCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof InviteCreateDTO
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface InviteOutputDTO
 */
export interface InviteOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof InviteOutputDTO
     */
    'botInvite': string;
    /**
     * 
     * @type {string}
     * @memberof InviteOutputDTO
     */
    'devServer': string;
}
/**
 * 
 * @export
 * @interface IpHistoryOutputDTO
 */
export interface IpHistoryOutputDTO {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof IpHistoryOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof IpHistoryOutputDTO
     */
    'ip': string;
    /**
     * 
     * @type {string}
     * @memberof IpHistoryOutputDTO
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof IpHistoryOutputDTO
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof IpHistoryOutputDTO
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof IpHistoryOutputDTO
     */
    'longitude'?: string;
}
/**
 * 
 * @export
 * @interface ItemCreateDTO
 */
export interface ItemCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof ItemCreateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemCreateDTO
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ItemCreateDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCreateDTO
     */
    'icon'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCreateDTO
     */
    'gameserverId': string;
}
/**
 * 
 * @export
 * @interface ItemOutputArrayDTOAPI
 */
export interface ItemOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<ItemsOutputDTO>}
     * @memberof ItemOutputArrayDTOAPI
     */
    'data': Array<ItemsOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ItemOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ItemOutputDTOAPI
 */
export interface ItemOutputDTOAPI {
    /**
     * 
     * @type {ItemsOutputDTO}
     * @memberof ItemOutputDTOAPI
     */
    'data': ItemsOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ItemOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ItemSearchInputAllowedFilters
 */
export interface ItemSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemSearchInputAllowedFilters
     */
    'code'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemSearchInputAllowedFilters
     */
    'gameserverId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ItemSearchInputDTO
 */
export interface ItemSearchInputDTO {
    /**
     * 
     * @type {ItemSearchInputAllowedFilters}
     * @memberof ItemSearchInputDTO
     */
    'filters'?: ItemSearchInputAllowedFilters;
    /**
     * 
     * @type {ItemSearchInputAllowedFilters}
     * @memberof ItemSearchInputDTO
     */
    'search'?: ItemSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof ItemSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof ItemSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof ItemSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemSearchInputDTO
     */
    'sortDirection'?: ItemSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ItemSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const ItemSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ItemSearchInputDTOSortDirectionEnum = typeof ItemSearchInputDTOSortDirectionEnum[keyof typeof ItemSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface ItemUpdateDTO
 */
export interface ItemUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateDTO
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemUpdateDTO
     */
    'icon'?: string;
}
/**
 * 
 * @export
 * @interface ItemsOutputDTO
 */
export interface ItemsOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof ItemsOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ItemsOutputDTO
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof ItemsOutputDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsOutputDTO
     */
    'icon'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemsOutputDTO
     */
    'gameserverId': string;
    /**
     * 
     * @type {string}
     * @memberof ItemsOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ItemsOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ItemsOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface KickPlayerInputDTO
 */
export interface KickPlayerInputDTO {
    /**
     * 
     * @type {string}
     * @memberof KickPlayerInputDTO
     */
    'reason': string;
}
/**
 * 
 * @export
 * @interface LatencyInputDTO
 */
export interface LatencyInputDTO {
    /**
     * 
     * @type {string}
     * @memberof LatencyInputDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof LatencyInputDTO
     */
    'startDate'?: StatsControllerGetPingStatsStartDateParameter;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof LatencyInputDTO
     */
    'endDate'?: StatsControllerGetPingStatsStartDateParameter;
}
/**
 * 
 * @export
 * @interface LinkPlayerUnauthedInputDTO
 */
export interface LinkPlayerUnauthedInputDTO {
    /**
     * 
     * @type {string}
     * @memberof LinkPlayerUnauthedInputDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof LinkPlayerUnauthedInputDTO
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface LoginDTO
 */
export interface LoginDTO {
    /**
     * 
     * @type {string}
     * @memberof LoginDTO
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginOutputDTO
 */
export interface LoginOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof LoginOutputDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface LoginOutputDTOAPI
 */
export interface LoginOutputDTOAPI {
    /**
     * 
     * @type {LoginOutputDTO}
     * @memberof LoginOutputDTOAPI
     */
    'data': LoginOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof LoginOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface MeOutoutDTOAPI
 */
export interface MeOutoutDTOAPI {
    /**
     * 
     * @type {MeOutputDTO}
     * @memberof MeOutoutDTOAPI
     */
    'data': MeOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof MeOutoutDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface MeOutputDTO
 */
export interface MeOutputDTO {
    /**
     * 
     * @type {UserOutputWithRolesDTO}
     * @memberof MeOutputDTO
     */
    'user': UserOutputWithRolesDTO;
    /**
     * 
     * @type {Array<DomainOutputDTO>}
     * @memberof MeOutputDTO
     */
    'domains': Array<DomainOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof MeOutputDTO
     */
    'domain': string;
    /**
     * 
     * @type {PlayerOutputWithRolesDTO}
     * @memberof MeOutputDTO
     */
    'player'?: PlayerOutputWithRolesDTO;
    /**
     * 
     * @type {Array<PlayerOnGameserverOutputDTO>}
     * @memberof MeOutputDTO
     */
    'pogs': Array<PlayerOnGameserverOutputDTO>;
}
/**
 * 
 * @export
 * @interface MessageSendInputDTO
 */
export interface MessageSendInputDTO {
    /**
     * 
     * @type {string}
     * @memberof MessageSendInputDTO
     */
    'message': string;
    /**
     * 
     * @type {IMessageOptsDTO}
     * @memberof MessageSendInputDTO
     */
    'opts'?: IMessageOptsDTO;
}
/**
 * 
 * @export
 * @interface MetadataOutput
 */
export interface MetadataOutput {
    /**
     * 
     * @type {MetadataOutputServerTime}
     * @memberof MetadataOutput
     */
    'serverTime': MetadataOutputServerTime;
    /**
     * 
     * @type {ErrorOutput}
     * @memberof MetadataOutput
     */
    'error': ErrorOutput;
    /**
     * 
     * @type {number}
     * @memberof MetadataOutput
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetadataOutput
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetadataOutput
     */
    'total'?: number;
}
/**
 * @type MetadataOutputServerTime
 * @export
 */
export type MetadataOutputServerTime = string;

/**
 * 
 * @export
 * @interface MockConnectionInfo
 */
export interface MockConnectionInfo {
    /**
     * 
     * @type {string}
     * @memberof MockConnectionInfo
     */
    'host': string;
    /**
     * 
     * @type {string}
     * @memberof MockConnectionInfo
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ModuleCreateAPIDTO
 */
export interface ModuleCreateAPIDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleCreateAPIDTO
     */
    'name': string;
    /**
     * 
     * @type {ModuleCreateVersionInputDTO}
     * @memberof ModuleCreateAPIDTO
     */
    'latestVersion'?: ModuleCreateVersionInputDTO;
}
/**
 * 
 * @export
 * @interface ModuleCreateDTO
 */
export interface ModuleCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleCreateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleCreateDTO
     */
    'builtin'?: string;
}
/**
 * 
 * @export
 * @interface ModuleCreateInternalDTO
 */
export interface ModuleCreateInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleCreateInternalDTO
     */
    'builtin'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleCreateInternalDTO
     */
    'name': string;
    /**
     * 
     * @type {ModuleCreateVersionInputDTO}
     * @memberof ModuleCreateInternalDTO
     */
    'latestVersion': ModuleCreateVersionInputDTO;
}
/**
 * 
 * @export
 * @interface ModuleCreateVersionInputDTO
 */
export interface ModuleCreateVersionInputDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleCreateVersionInputDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleCreateVersionInputDTO
     */
    'configSchema'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleCreateVersionInputDTO
     */
    'uiSchema'?: string;
    /**
     * 
     * @type {Array<PermissionCreateDTO>}
     * @memberof ModuleCreateVersionInputDTO
     */
    'permissions'?: Array<PermissionCreateDTO>;
    /**
     * 
     * @type {Array<FunctionCreateDTO>}
     * @memberof ModuleCreateVersionInputDTO
     */
    'functions'?: Array<FunctionCreateDTO>;
    /**
     * 
     * @type {Array<CommandCreateDTO>}
     * @memberof ModuleCreateVersionInputDTO
     */
    'commands'?: Array<CommandCreateDTO>;
    /**
     * 
     * @type {Array<HookCreateDTO>}
     * @memberof ModuleCreateVersionInputDTO
     */
    'hooks'?: Array<HookCreateDTO>;
    /**
     * 
     * @type {Array<CronJobCreateDTO>}
     * @memberof ModuleCreateVersionInputDTO
     */
    'cronJobs'?: Array<CronJobCreateDTO>;
}
/**
 * 
 * @export
 * @interface ModuleExportDTOAPI
 */
export interface ModuleExportDTOAPI {
    /**
     * 
     * @type {ModuleTransferDTO}
     * @memberof ModuleExportDTOAPI
     */
    'data': ModuleTransferDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ModuleExportDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ModuleExportOptionsDTO
 */
export interface ModuleExportOptionsDTO {
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleExportOptionsDTO
     */
    'versionIds'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModuleInstallParamId
 */
export interface ModuleInstallParamId {
    /**
     * 
     * @type {string}
     * @memberof ModuleInstallParamId
     */
    'moduleId': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleInstallParamId
     */
    'gameServerId': string;
}
/**
 * 
 * @export
 * @interface ModuleInstallationOutputArrayDTOAPI
 */
export interface ModuleInstallationOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<ModuleInstallationOutputDTO>}
     * @memberof ModuleInstallationOutputArrayDTOAPI
     */
    'data': Array<ModuleInstallationOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ModuleInstallationOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ModuleInstallationOutputDTO
 */
export interface ModuleInstallationOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleInstallationOutputDTO
     */
    'gameserverId': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleInstallationOutputDTO
     */
    'versionId': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleInstallationOutputDTO
     */
    'moduleId': string;
    /**
     * 
     * @type {ModuleVersionOutputDTO}
     * @memberof ModuleInstallationOutputDTO
     */
    'version': ModuleVersionOutputDTO;
    /**
     * 
     * @type {ModuleOutputDTO}
     * @memberof ModuleInstallationOutputDTO
     */
    'module': ModuleOutputDTO;
    /**
     * 
     * @type {object}
     * @memberof ModuleInstallationOutputDTO
     */
    'userConfig': object;
    /**
     * 
     * @type {object}
     * @memberof ModuleInstallationOutputDTO
     */
    'systemConfig': object;
    /**
     * 
     * @type {string}
     * @memberof ModuleInstallationOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ModuleInstallationOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ModuleInstallationOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface ModuleInstallationOutputDTOAPI
 */
export interface ModuleInstallationOutputDTOAPI {
    /**
     * 
     * @type {ModuleInstallationOutputDTO}
     * @memberof ModuleInstallationOutputDTOAPI
     */
    'data': ModuleInstallationOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ModuleInstallationOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ModuleInstallationSearchInputAllowedFilters
 */
export interface ModuleInstallationSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleInstallationSearchInputAllowedFilters
     */
    'versionId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleInstallationSearchInputAllowedFilters
     */
    'moduleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleInstallationSearchInputAllowedFilters
     */
    'gameserverId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleInstallationSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModuleInstallationSearchInputDTO
 */
export interface ModuleInstallationSearchInputDTO {
    /**
     * 
     * @type {ModuleInstallationSearchInputAllowedFilters}
     * @memberof ModuleInstallationSearchInputDTO
     */
    'filters'?: ModuleInstallationSearchInputAllowedFilters;
    /**
     * 
     * @type {ModuleInstallationSearchInputAllowedFilters}
     * @memberof ModuleInstallationSearchInputDTO
     */
    'search'?: ModuleInstallationSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof ModuleInstallationSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof ModuleInstallationSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof ModuleInstallationSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleInstallationSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModuleInstallationSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleInstallationSearchInputDTO
     */
    'sortDirection'?: ModuleInstallationSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleInstallationSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const ModuleInstallationSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ModuleInstallationSearchInputDTOSortDirectionEnum = typeof ModuleInstallationSearchInputDTOSortDirectionEnum[keyof typeof ModuleInstallationSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface ModuleOutputArrayDTOAPI
 */
export interface ModuleOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<ModuleOutputDTO>}
     * @memberof ModuleOutputArrayDTOAPI
     */
    'data': Array<ModuleOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ModuleOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ModuleOutputDTO
 */
export interface ModuleOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleOutputDTO
     */
    'builtin'?: string;
    /**
     * 
     * @type {ModuleVersionOutputDTO}
     * @memberof ModuleOutputDTO
     */
    'latestVersion': ModuleVersionOutputDTO;
    /**
     * 
     * @type {Array<SmallModuleVersionOutputDTO>}
     * @memberof ModuleOutputDTO
     */
    'versions': Array<SmallModuleVersionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof ModuleOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ModuleOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ModuleOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface ModuleOutputDTOAPI
 */
export interface ModuleOutputDTOAPI {
    /**
     * 
     * @type {ModuleOutputDTO}
     * @memberof ModuleOutputDTOAPI
     */
    'data': ModuleOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ModuleOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ModuleSearchInputAllowedFilters
 */
export interface ModuleSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleSearchInputAllowedFilters
     */
    'builtin'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModuleSearchInputDTO
 */
export interface ModuleSearchInputDTO {
    /**
     * 
     * @type {ModuleSearchInputAllowedFilters}
     * @memberof ModuleSearchInputDTO
     */
    'filters'?: ModuleSearchInputAllowedFilters;
    /**
     * 
     * @type {ModuleSearchInputAllowedFilters}
     * @memberof ModuleSearchInputDTO
     */
    'search'?: ModuleSearchInputAllowedFilters;
    /**
     * 
     * @type {RangeFilterCreatedAndUpdatedAt}
     * @memberof ModuleSearchInputDTO
     */
    'greaterThan'?: RangeFilterCreatedAndUpdatedAt;
    /**
     * 
     * @type {RangeFilterCreatedAndUpdatedAt}
     * @memberof ModuleSearchInputDTO
     */
    'lessThan'?: RangeFilterCreatedAndUpdatedAt;
    /**
     * 
     * @type {number}
     * @memberof ModuleSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModuleSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleSearchInputDTO
     */
    'sortDirection'?: ModuleSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const ModuleSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ModuleSearchInputDTOSortDirectionEnum = typeof ModuleSearchInputDTOSortDirectionEnum[keyof typeof ModuleSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface ModuleTransferDTO
 */
export interface ModuleTransferDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleTransferDTO
     */
    'name': string;
    /**
     * 
     * @type {Array<ModuleTransferVersionDTO>}
     * @memberof ModuleTransferDTO
     */
    'versions': Array<ModuleTransferVersionDTO>;
}
/**
 * 
 * @export
 * @interface ModuleTransferVersionDTO
 */
export interface ModuleTransferVersionDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleTransferVersionDTO
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleTransferVersionDTO
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleTransferVersionDTO
     */
    'configSchema': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleTransferVersionDTO
     */
    'uiSchema': string;
    /**
     * 
     * @type {Array<ICommand>}
     * @memberof ModuleTransferVersionDTO
     */
    'commands'?: Array<ICommand>;
    /**
     * 
     * @type {Array<IHook>}
     * @memberof ModuleTransferVersionDTO
     */
    'hooks'?: Array<IHook>;
    /**
     * 
     * @type {Array<ICronJob>}
     * @memberof ModuleTransferVersionDTO
     */
    'cronJobs'?: Array<ICronJob>;
    /**
     * 
     * @type {Array<IFunction>}
     * @memberof ModuleTransferVersionDTO
     */
    'functions'?: Array<IFunction>;
    /**
     * 
     * @type {Array<IPermission>}
     * @memberof ModuleTransferVersionDTO
     */
    'permissions'?: Array<IPermission>;
}
/**
 * 
 * @export
 * @interface ModuleUpdateDTO
 */
export interface ModuleUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleUpdateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {ModuleVersionUpdateDTO}
     * @memberof ModuleUpdateDTO
     */
    'latestVersion'?: ModuleVersionUpdateDTO;
}
/**
 * 
 * @export
 * @interface ModuleVersionCreateAPIDTO
 */
export interface ModuleVersionCreateAPIDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionCreateAPIDTO
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionCreateAPIDTO
     */
    'moduleId': string;
}
/**
 * 
 * @export
 * @interface ModuleVersionOutputArrayDTOAPI
 */
export interface ModuleVersionOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<ModuleVersionOutputDTO>}
     * @memberof ModuleVersionOutputArrayDTOAPI
     */
    'data': Array<ModuleVersionOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ModuleVersionOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ModuleVersionOutputDTO
 */
export interface ModuleVersionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionOutputDTO
     */
    'tag': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionOutputDTO
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionOutputDTO
     */
    'configSchema': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionOutputDTO
     */
    'uiSchema': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionOutputDTO
     */
    'systemConfigSchema': string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionOutputDTO
     */
    'moduleId': string;
    /**
     * 
     * @type {Array<CronJobOutputDTO>}
     * @memberof ModuleVersionOutputDTO
     */
    'cronJobs': Array<CronJobOutputDTO>;
    /**
     * 
     * @type {Array<HookOutputDTO>}
     * @memberof ModuleVersionOutputDTO
     */
    'hooks': Array<HookOutputDTO>;
    /**
     * 
     * @type {Array<CommandOutputDTO>}
     * @memberof ModuleVersionOutputDTO
     */
    'commands': Array<CommandOutputDTO>;
    /**
     * 
     * @type {Array<FunctionOutputDTO>}
     * @memberof ModuleVersionOutputDTO
     */
    'functions': Array<FunctionOutputDTO>;
    /**
     * 
     * @type {Array<PermissionOutputDTO>}
     * @memberof ModuleVersionOutputDTO
     */
    'permissions': Array<PermissionOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ModuleVersionOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ModuleVersionOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface ModuleVersionOutputDTOAPI
 */
export interface ModuleVersionOutputDTOAPI {
    /**
     * 
     * @type {ModuleVersionOutputDTO}
     * @memberof ModuleVersionOutputDTOAPI
     */
    'data': ModuleVersionOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ModuleVersionOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ModuleVersionSearchInputAllowedFilters
 */
export interface ModuleVersionSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleVersionSearchInputAllowedFilters
     */
    'version'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleVersionSearchInputAllowedFilters
     */
    'moduleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleVersionSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModuleVersionSearchInputDTO
 */
export interface ModuleVersionSearchInputDTO {
    /**
     * 
     * @type {ModuleVersionSearchInputAllowedFilters}
     * @memberof ModuleVersionSearchInputDTO
     */
    'filters'?: ModuleVersionSearchInputAllowedFilters;
    /**
     * 
     * @type {ModuleVersionSearchInputAllowedFilters}
     * @memberof ModuleVersionSearchInputDTO
     */
    'search'?: ModuleVersionSearchInputAllowedFilters;
    /**
     * 
     * @type {RangeFilterCreatedAndUpdatedAt}
     * @memberof ModuleVersionSearchInputDTO
     */
    'greaterThan'?: RangeFilterCreatedAndUpdatedAt;
    /**
     * 
     * @type {RangeFilterCreatedAndUpdatedAt}
     * @memberof ModuleVersionSearchInputDTO
     */
    'lessThan'?: RangeFilterCreatedAndUpdatedAt;
    /**
     * 
     * @type {number}
     * @memberof ModuleVersionSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleVersionSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionSearchInputDTO
     */
    'sortDirection'?: ModuleVersionSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleVersionSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const ModuleVersionSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ModuleVersionSearchInputDTOSortDirectionEnum = typeof ModuleVersionSearchInputDTOSortDirectionEnum[keyof typeof ModuleVersionSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface ModuleVersionUpdateDTO
 */
export interface ModuleVersionUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionUpdateDTO
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionUpdateDTO
     */
    'configSchema'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleVersionUpdateDTO
     */
    'uiSchema'?: string;
    /**
     * 
     * @type {Array<PermissionCreateDTO>}
     * @memberof ModuleVersionUpdateDTO
     */
    'permissions'?: Array<PermissionCreateDTO>;
}
/**
 * 
 * @export
 * @interface NOTDOMAINSCOPEDTakaroModelDTO
 */
export interface NOTDOMAINSCOPEDTakaroModelDTO {
    /**
     * 
     * @type {string}
     * @memberof NOTDOMAINSCOPEDTakaroModelDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof NOTDOMAINSCOPEDTakaroModelDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof NOTDOMAINSCOPEDTakaroModelDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * @type NOTDOMAINSCOPEDTakaroModelDTOCreatedAt
 * @export
 */
export type NOTDOMAINSCOPEDTakaroModelDTOCreatedAt = string;

/**
 * 
 * @export
 * @interface OptionalPogStatsInputDTO
 */
export interface OptionalPogStatsInputDTO {
    /**
     * 
     * @type {string}
     * @memberof OptionalPogStatsInputDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof OptionalPogStatsInputDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof OptionalPogStatsInputDTO
     */
    'startDate'?: StatsControllerGetPingStatsStartDateParameter;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof OptionalPogStatsInputDTO
     */
    'endDate'?: StatsControllerGetPingStatsStartDateParameter;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PERMISSIONS = {
    Root: 'ROOT',
    ManageUsers: 'MANAGE_USERS',
    ReadUsers: 'READ_USERS',
    ManageRoles: 'MANAGE_ROLES',
    ReadRoles: 'READ_ROLES',
    ManageGameservers: 'MANAGE_GAMESERVERS',
    ReadModules: 'READ_MODULES',
    ManageModules: 'MANAGE_MODULES',
    ReadPlayers: 'READ_PLAYERS',
    ManagePlayers: 'MANAGE_PLAYERS',
    ManageSettings: 'MANAGE_SETTINGS',
    ReadSettings: 'READ_SETTINGS',
    ReadVariables: 'READ_VARIABLES',
    ManageVariables: 'MANAGE_VARIABLES',
    ReadEvents: 'READ_EVENTS',
    ManageEvents: 'MANAGE_EVENTS',
    ReadItems: 'READ_ITEMS',
    ManageItems: 'MANAGE_ITEMS',
    ManageShopListings: 'MANAGE_SHOP_LISTINGS',
    ManageShopOrders: 'MANAGE_SHOP_ORDERS'
} as const;

export type PERMISSIONS = typeof PERMISSIONS[keyof typeof PERMISSIONS];


/**
 * 
 * @export
 * @interface PaginationParams
 */
export interface PaginationParams {
    /**
     * 
     * @type {number}
     * @memberof PaginationParams
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationParams
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface PaginationParamsWithGameServer
 */
export interface PaginationParamsWithGameServer {
    /**
     * 
     * @type {string}
     * @memberof PaginationParamsWithGameServer
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PaginationParamsWithGameServer
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PaginationParamsWithGameServer
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface ParamId
 */
export interface ParamId {
    /**
     * 
     * @type {string}
     * @memberof ParamId
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ParamIdAndRoleId
 */
export interface ParamIdAndRoleId {
    /**
     * 
     * @type {string}
     * @memberof ParamIdAndRoleId
     */
    'roleId': string;
    /**
     * 
     * @type {string}
     * @memberof ParamIdAndRoleId
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ParamKey
 */
export interface ParamKey {
    /**
     * 
     * @type {string}
     * @memberof ParamKey
     */
    'key': ParamKeyKeyEnum;
}

export const ParamKeyKeyEnum = {
    CommandPrefix: 'commandPrefix',
    ServerChatName: 'serverChatName',
    EconomyEnabled: 'economyEnabled',
    CurrencyName: 'currencyName',
    DeveloperMode: 'developerMode'
} as const;

export type ParamKeyKeyEnum = typeof ParamKeyKeyEnum[keyof typeof ParamKeyKeyEnum];

/**
 * 
 * @export
 * @interface ParamSenderReceiver
 */
export interface ParamSenderReceiver {
    /**
     * 
     * @type {string}
     * @memberof ParamSenderReceiver
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof ParamSenderReceiver
     */
    'sender': string;
    /**
     * 
     * @type {string}
     * @memberof ParamSenderReceiver
     */
    'receiver': string;
}
/**
 * 
 * @export
 * @interface PermissionCreateDTO
 */
export interface PermissionCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof PermissionCreateDTO
     */
    'permission': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionCreateDTO
     */
    'friendlyName': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionCreateDTO
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionCreateDTO
     */
    'canHaveCount'?: boolean;
}
/**
 * 
 * @export
 * @interface PermissionInputDTO
 */
export interface PermissionInputDTO {
    /**
     * 
     * @type {string}
     * @memberof PermissionInputDTO
     */
    'permissionId': string;
    /**
     * 
     * @type {number}
     * @memberof PermissionInputDTO
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface PermissionModuleDTO
 */
export interface PermissionModuleDTO {
    /**
     * 
     * @type {string}
     * @memberof PermissionModuleDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionModuleDTO
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface PermissionOnRoleDTO
 */
export interface PermissionOnRoleDTO {
    /**
     * 
     * @type {string}
     * @memberof PermissionOnRoleDTO
     */
    'permissionId': string;
    /**
     * 
     * @type {PermissionOutputDTO}
     * @memberof PermissionOnRoleDTO
     */
    'permission': PermissionOutputDTO;
    /**
     * 
     * @type {number}
     * @memberof PermissionOnRoleDTO
     */
    'count': number;
    /**
     * 
     * @type {string}
     * @memberof PermissionOnRoleDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PermissionOnRoleDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PermissionOnRoleDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface PermissionOutputDTO
 */
export interface PermissionOutputDTO {
    /**
     * 
     * @type {PermissionModuleDTO}
     * @memberof PermissionOutputDTO
     */
    'module'?: PermissionModuleDTO;
    /**
     * 
     * @type {string}
     * @memberof PermissionOutputDTO
     */
    'permission': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionOutputDTO
     */
    'friendlyName': string;
    /**
     * 
     * @type {string}
     * @memberof PermissionOutputDTO
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof PermissionOutputDTO
     */
    'canHaveCount'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PermissionOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PermissionOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PermissionOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface PermissionOutputDTOAPI
 */
export interface PermissionOutputDTOAPI {
    /**
     * 
     * @type {Array<PermissionOutputDTO>}
     * @memberof PermissionOutputDTOAPI
     */
    'data': Array<PermissionOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof PermissionOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface PlayerCreateDTO
 */
export interface PlayerCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof PlayerCreateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCreateDTO
     */
    'steamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCreateDTO
     */
    'xboxLiveId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerCreateDTO
     */
    'epicOnlineServicesId'?: string;
}
/**
 * 
 * @export
 * @interface PlayerMeOutputDTO
 */
export interface PlayerMeOutputDTO {
    /**
     * 
     * @type {PlayerOutputWithRolesDTO}
     * @memberof PlayerMeOutputDTO
     */
    'player': PlayerOutputWithRolesDTO;
    /**
     * 
     * @type {Array<PlayerOnGameserverOutputArrayDTOAPI>}
     * @memberof PlayerMeOutputDTO
     */
    'pogs': Array<PlayerOnGameserverOutputArrayDTOAPI>;
}
/**
 * 
 * @export
 * @interface PlayerOnGameServerCreateDTO
 */
export interface PlayerOnGameServerCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameServerCreateDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameServerCreateDTO
     */
    'playerId': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameServerCreateDTO
     */
    'gameId': string;
}
/**
 * 
 * @export
 * @interface PlayerOnGameServerSearchInputAllowedFilters
 */
export interface PlayerOnGameServerSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerOnGameServerSearchInputAllowedFilters
     */
    'gameId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerOnGameServerSearchInputAllowedFilters
     */
    'gameServerId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerOnGameServerSearchInputAllowedFilters
     */
    'playerId'?: Array<string>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof PlayerOnGameServerSearchInputAllowedFilters
     */
    'online'?: Array<boolean>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerOnGameServerSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlayerOnGameServerSearchInputAllowedRangeFilter
 */
export interface PlayerOnGameServerSearchInputAllowedRangeFilter {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOnGameServerSearchInputAllowedRangeFilter
     */
    'lastSeen'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerSearchInputAllowedRangeFilter
     */
    'playtimeSeconds'?: number;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOnGameServerSearchInputAllowedRangeFilter
     */
    'createdAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOnGameServerSearchInputAllowedRangeFilter
     */
    'updatedAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface PlayerOnGameServerSearchInputDTO
 */
export interface PlayerOnGameServerSearchInputDTO {
    /**
     * 
     * @type {PlayerOnGameServerSearchInputAllowedFilters}
     * @memberof PlayerOnGameServerSearchInputDTO
     */
    'filters'?: PlayerOnGameServerSearchInputAllowedFilters;
    /**
     * 
     * @type {PlayerOnGameServerSearchInputAllowedFilters}
     * @memberof PlayerOnGameServerSearchInputDTO
     */
    'search'?: PlayerOnGameServerSearchInputAllowedFilters;
    /**
     * 
     * @type {PlayerOnGameServerSearchInputAllowedRangeFilter}
     * @memberof PlayerOnGameServerSearchInputDTO
     */
    'greaterThan'?: PlayerOnGameServerSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {PlayerOnGameServerSearchInputAllowedRangeFilter}
     * @memberof PlayerOnGameServerSearchInputDTO
     */
    'lessThan'?: PlayerOnGameServerSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameServerSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameServerSearchInputDTO
     */
    'sortDirection'?: PlayerOnGameServerSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerOnGameServerSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const PlayerOnGameServerSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type PlayerOnGameServerSearchInputDTOSortDirectionEnum = typeof PlayerOnGameServerSearchInputDTOSortDirectionEnum[keyof typeof PlayerOnGameServerSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface PlayerOnGameServerSetCurrencyInputDTO
 */
export interface PlayerOnGameServerSetCurrencyInputDTO {
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerSetCurrencyInputDTO
     */
    'currency': number;
}
/**
 * 
 * @export
 * @interface PlayerOnGameServerUpdateDTO
 */
export interface PlayerOnGameServerUpdateDTO {
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerUpdateDTO
     */
    'positionX'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerUpdateDTO
     */
    'positionY'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerUpdateDTO
     */
    'positionZ'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameServerUpdateDTO
     */
    'ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerUpdateDTO
     */
    'ping'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerUpdateDTO
     */
    'currency'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerOnGameServerUpdateDTO
     */
    'online': boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameServerUpdateDTO
     */
    'playtimeSeconds'?: number;
}
/**
 * 
 * @export
 * @interface PlayerOnGameserverOutputArrayDTOAPI
 */
export interface PlayerOnGameserverOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<PlayerOnGameserverOutputWithRolesDTO>}
     * @memberof PlayerOnGameserverOutputArrayDTOAPI
     */
    'data': Array<PlayerOnGameserverOutputWithRolesDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof PlayerOnGameserverOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface PlayerOnGameserverOutputDTO
 */
export interface PlayerOnGameserverOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'playerId': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'gameId': string;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'positionX'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'positionY'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'positionZ'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'ping'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'currency': number;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'online': boolean;
    /**
     * 
     * @type {Array<IItemDTO>}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'inventory': Array<IItemDTO>;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'lastSeen': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'playtimeSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOnGameserverOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface PlayerOnGameserverOutputDTOAPI
 */
export interface PlayerOnGameserverOutputDTOAPI {
    /**
     * 
     * @type {PlayerOnGameserverOutputWithRolesDTO}
     * @memberof PlayerOnGameserverOutputDTOAPI
     */
    'data': PlayerOnGameserverOutputWithRolesDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof PlayerOnGameserverOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface PlayerOnGameserverOutputWithRolesDTO
 */
export interface PlayerOnGameserverOutputWithRolesDTO {
    /**
     * 
     * @type {Array<PlayerRoleAssignmentOutputDTO>}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'roles': Array<PlayerRoleAssignmentOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'playerId': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'gameId': string;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'positionX'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'positionY'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'positionZ'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'ip'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'ping'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'currency': number;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'online': boolean;
    /**
     * 
     * @type {Array<IItemDTO>}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'inventory': Array<IItemDTO>;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'lastSeen': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {number}
     * @memberof PlayerOnGameserverOutputWithRolesDTO
     */
    'playtimeSeconds': number;
}
/**
 * 
 * @export
 * @interface PlayerOutputArrayDTOAPI
 */
export interface PlayerOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<PlayerOutputDTO>}
     * @memberof PlayerOutputArrayDTOAPI
     */
    'data': Array<PlayerOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof PlayerOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface PlayerOutputDTO
 */
export interface PlayerOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputDTO
     */
    'steamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputDTO
     */
    'xboxLiveId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputDTO
     */
    'epicOnlineServicesId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputDTO
     */
    'steamAvatar'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOutputDTO
     */
    'steamAccountCreated'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerOutputDTO
     */
    'steamCommunityBanned'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputDTO
     */
    'steamEconomyBan'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerOutputDTO
     */
    'steamVacBanned'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayerOutputDTO
     */
    'steamsDaysSinceLastBan'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOutputDTO
     */
    'steamNumberOfVACBans'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOutputDTO
     */
    'steamLevel'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOutputDTO
     */
    'playtimeSeconds': number;
    /**
     * 
     * @type {Array<PlayerOnGameserverOutputDTO>}
     * @memberof PlayerOutputDTO
     */
    'playerOnGameServers'?: Array<PlayerOnGameserverOutputDTO>;
    /**
     * 
     * @type {Array<IpHistoryOutputDTO>}
     * @memberof PlayerOutputDTO
     */
    'ipHistory': Array<IpHistoryOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface PlayerOutputDTOAPI
 */
export interface PlayerOutputDTOAPI {
    /**
     * 
     * @type {PlayerOutputWithRolesDTO}
     * @memberof PlayerOutputDTOAPI
     */
    'data': PlayerOutputWithRolesDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof PlayerOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface PlayerOutputWithRolesDTO
 */
export interface PlayerOutputWithRolesDTO {
    /**
     * 
     * @type {Array<PlayerRoleAssignmentOutputDTO>}
     * @memberof PlayerOutputWithRolesDTO
     */
    'roleAssignments': Array<PlayerRoleAssignmentOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputWithRolesDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOutputWithRolesDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOutputWithRolesDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputWithRolesDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputWithRolesDTO
     */
    'steamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputWithRolesDTO
     */
    'xboxLiveId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputWithRolesDTO
     */
    'epicOnlineServicesId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputWithRolesDTO
     */
    'steamAvatar'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerOutputWithRolesDTO
     */
    'steamAccountCreated'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerOutputWithRolesDTO
     */
    'steamCommunityBanned'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PlayerOutputWithRolesDTO
     */
    'steamEconomyBan'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlayerOutputWithRolesDTO
     */
    'steamVacBanned'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PlayerOutputWithRolesDTO
     */
    'steamsDaysSinceLastBan'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOutputWithRolesDTO
     */
    'steamNumberOfVACBans'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOutputWithRolesDTO
     */
    'steamLevel'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerOutputWithRolesDTO
     */
    'playtimeSeconds': number;
    /**
     * 
     * @type {Array<PlayerOnGameserverOutputDTO>}
     * @memberof PlayerOutputWithRolesDTO
     */
    'playerOnGameServers'?: Array<PlayerOnGameserverOutputDTO>;
    /**
     * 
     * @type {Array<IpHistoryOutputDTO>}
     * @memberof PlayerOutputWithRolesDTO
     */
    'ipHistory': Array<IpHistoryOutputDTO>;
}
/**
 * 
 * @export
 * @interface PlayerOutputWithRolesDTOAPI
 */
export interface PlayerOutputWithRolesDTOAPI {
    /**
     * 
     * @type {PlayerOutputWithRolesDTO}
     * @memberof PlayerOutputWithRolesDTOAPI
     */
    'data': PlayerOutputWithRolesDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof PlayerOutputWithRolesDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface PlayerRoleAssignChangeDTO
 */
export interface PlayerRoleAssignChangeDTO {
    /**
     * 
     * @type {string}
     * @memberof PlayerRoleAssignChangeDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerRoleAssignChangeDTO
     */
    'expiresAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface PlayerRoleAssignmentOutputDTO
 */
export interface PlayerRoleAssignmentOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof PlayerRoleAssignmentOutputDTO
     */
    'playerId': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerRoleAssignmentOutputDTO
     */
    'roleId': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerRoleAssignmentOutputDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {RoleOutputDTO}
     * @memberof PlayerRoleAssignmentOutputDTO
     */
    'role': RoleOutputDTO;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerRoleAssignmentOutputDTO
     */
    'expiresAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof PlayerRoleAssignmentOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerRoleAssignmentOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerRoleAssignmentOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface PlayerSearchInputAllowedFilters
 */
export interface PlayerSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerSearchInputAllowedFilters
     */
    'steamId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerSearchInputAllowedFilters
     */
    'epicOnlineServicesId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerSearchInputAllowedFilters
     */
    'xboxLiveId'?: Array<string>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof PlayerSearchInputAllowedFilters
     */
    'steamCommunityBanned'?: Array<boolean>;
    /**
     * 
     * @type {Array<boolean>}
     * @memberof PlayerSearchInputAllowedFilters
     */
    'steamVacBanned'?: Array<boolean>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerSearchInputAllowedFilters
     */
    'roleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PlayerSearchInputAllowedRangeFilter
 */
export interface PlayerSearchInputAllowedRangeFilter {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerSearchInputAllowedRangeFilter
     */
    'steamAccountCreated'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {number}
     * @memberof PlayerSearchInputAllowedRangeFilter
     */
    'steamDaysSinceLastBan'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerSearchInputAllowedRangeFilter
     */
    'steamNumberOfVACBans'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerSearchInputAllowedRangeFilter
     */
    'steamLevel'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerSearchInputAllowedRangeFilter
     */
    'playtimeSeconds'?: number;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerSearchInputAllowedRangeFilter
     */
    'createdAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof PlayerSearchInputAllowedRangeFilter
     */
    'updatedAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface PlayerSearchInputDTO
 */
export interface PlayerSearchInputDTO {
    /**
     * 
     * @type {PlayerSearchInputAllowedFilters}
     * @memberof PlayerSearchInputDTO
     */
    'filters'?: PlayerSearchInputAllowedFilters;
    /**
     * 
     * @type {PlayerSearchInputAllowedFilters}
     * @memberof PlayerSearchInputDTO
     */
    'search'?: PlayerSearchInputAllowedFilters;
    /**
     * 
     * @type {PlayerSearchInputAllowedRangeFilter}
     * @memberof PlayerSearchInputDTO
     */
    'greaterThan'?: PlayerSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {PlayerSearchInputAllowedRangeFilter}
     * @memberof PlayerSearchInputDTO
     */
    'lessThan'?: PlayerSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {number}
     * @memberof PlayerSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlayerSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlayerSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerSearchInputDTO
     */
    'sortDirection'?: PlayerSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlayerSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const PlayerSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type PlayerSearchInputDTOSortDirectionEnum = typeof PlayerSearchInputDTOSortDirectionEnum[keyof typeof PlayerSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface PlayerUpdateDTO
 */
export interface PlayerUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof PlayerUpdateDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PlayerUpdateDTO
     */
    'steamId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerUpdateDTO
     */
    'xboxLiveId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlayerUpdateDTO
     */
    'epicOnlineServicesId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlayerUpdateDTO
     */
    'playtimeSeconds'?: number;
}
/**
 * 
 * @export
 * @interface PlayersOnlineInputDTO
 */
export interface PlayersOnlineInputDTO {
    /**
     * 
     * @type {string}
     * @memberof PlayersOnlineInputDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof PlayersOnlineInputDTO
     */
    'startDate'?: StatsControllerGetPingStatsStartDateParameter;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof PlayersOnlineInputDTO
     */
    'endDate'?: StatsControllerGetPingStatsStartDateParameter;
}
/**
 * 
 * @export
 * @interface PogParam
 */
export interface PogParam {
    /**
     * 
     * @type {string}
     * @memberof PogParam
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof PogParam
     */
    'playerId': string;
}
/**
 * 
 * @export
 * @interface PogStatsInputDTO
 */
export interface PogStatsInputDTO {
    /**
     * 
     * @type {string}
     * @memberof PogStatsInputDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof PogStatsInputDTO
     */
    'playerId': string;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof PogStatsInputDTO
     */
    'startDate'?: StatsControllerGetPingStatsStartDateParameter;
    /**
     * 
     * @type {StatsControllerGetPingStatsStartDateParameter}
     * @memberof PogStatsInputDTO
     */
    'endDate'?: StatsControllerGetPingStatsStartDateParameter;
}
/**
 * 
 * @export
 * @interface RangeFilterCreatedAndUpdatedAt
 */
export interface RangeFilterCreatedAndUpdatedAt {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof RangeFilterCreatedAndUpdatedAt
     */
    'createdAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof RangeFilterCreatedAndUpdatedAt
     */
    'updatedAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface RedirectQs
 */
export interface RedirectQs {
    /**
     * 
     * @type {string}
     * @memberof RedirectQs
     */
    'redirect': string;
}
/**
 * 
 * @export
 * @interface RoleCreateInputDTO
 */
export interface RoleCreateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof RoleCreateInputDTO
     */
    'name': string;
    /**
     * 
     * @type {Array<PermissionInputDTO>}
     * @memberof RoleCreateInputDTO
     */
    'permissions': Array<PermissionInputDTO>;
}
/**
 * 
 * @export
 * @interface RoleMembersOutputDTO
 */
export interface RoleMembersOutputDTO {
    /**
     * 
     * @type {RoleMembersPlayersOutputDTO}
     * @memberof RoleMembersOutputDTO
     */
    'players': RoleMembersPlayersOutputDTO;
    /**
     * 
     * @type {RoleMembersUsersOutputDTO}
     * @memberof RoleMembersOutputDTO
     */
    'users': RoleMembersUsersOutputDTO;
}
/**
 * 
 * @export
 * @interface RoleMembersOutputDTOAPI
 */
export interface RoleMembersOutputDTOAPI {
    /**
     * 
     * @type {RoleMembersOutputDTO}
     * @memberof RoleMembersOutputDTOAPI
     */
    'data': RoleMembersOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof RoleMembersOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface RoleMembersPlayersOutputDTO
 */
export interface RoleMembersPlayersOutputDTO {
    /**
     * 
     * @type {number}
     * @memberof RoleMembersPlayersOutputDTO
     */
    'total': number;
    /**
     * 
     * @type {Array<PlayerOutputWithRolesDTO>}
     * @memberof RoleMembersPlayersOutputDTO
     */
    'results': Array<PlayerOutputWithRolesDTO>;
}
/**
 * 
 * @export
 * @interface RoleMembersUsersOutputDTO
 */
export interface RoleMembersUsersOutputDTO {
    /**
     * 
     * @type {number}
     * @memberof RoleMembersUsersOutputDTO
     */
    'total': number;
    /**
     * 
     * @type {Array<UserOutputWithRolesDTO>}
     * @memberof RoleMembersUsersOutputDTO
     */
    'results': Array<UserOutputWithRolesDTO>;
}
/**
 * 
 * @export
 * @interface RoleOutputArrayDTOAPI
 */
export interface RoleOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<RoleOutputDTO>}
     * @memberof RoleOutputArrayDTOAPI
     */
    'data': Array<RoleOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof RoleOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface RoleOutputDTO
 */
export interface RoleOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof RoleOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {Array<PermissionOnRoleDTO>}
     * @memberof RoleOutputDTO
     */
    'permissions': Array<PermissionOnRoleDTO>;
    /**
     * 
     * @type {boolean}
     * @memberof RoleOutputDTO
     */
    'system': boolean;
    /**
     * 
     * @type {string}
     * @memberof RoleOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof RoleOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof RoleOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface RoleOutputDTOAPI
 */
export interface RoleOutputDTOAPI {
    /**
     * 
     * @type {RoleOutputDTO}
     * @memberof RoleOutputDTOAPI
     */
    'data': RoleOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof RoleOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface RoleSearchInputAllowedFilters
 */
export interface RoleSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RoleSearchInputDTO
 */
export interface RoleSearchInputDTO {
    /**
     * 
     * @type {RoleSearchInputAllowedFilters}
     * @memberof RoleSearchInputDTO
     */
    'filters'?: RoleSearchInputAllowedFilters;
    /**
     * 
     * @type {RoleSearchInputAllowedFilters}
     * @memberof RoleSearchInputDTO
     */
    'search'?: RoleSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof RoleSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof RoleSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof RoleSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof RoleSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof RoleSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleSearchInputDTO
     */
    'sortDirection'?: RoleSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoleSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const RoleSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type RoleSearchInputDTOSortDirectionEnum = typeof RoleSearchInputDTOSortDirectionEnum[keyof typeof RoleSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface RoleUpdateInputDTO
 */
export interface RoleUpdateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof RoleUpdateInputDTO
     */
    'name'?: string;
    /**
     * 
     * @type {Array<PermissionInputDTO>}
     * @memberof RoleUpdateInputDTO
     */
    'permissions'?: Array<PermissionInputDTO>;
}
/**
 * 
 * @export
 * @interface RustConnectionInfo
 */
export interface RustConnectionInfo {
    /**
     * 
     * @type {string}
     * @memberof RustConnectionInfo
     */
    'host': string;
    /**
     * 
     * @type {number}
     * @memberof RustConnectionInfo
     */
    'rconPort': number;
    /**
     * 
     * @type {string}
     * @memberof RustConnectionInfo
     */
    'rconPassword': string;
    /**
     * 
     * @type {boolean}
     * @memberof RustConnectionInfo
     */
    'useTls': boolean;
}
/**
 * 
 * @export
 * @interface SdtdConnectionInfo
 */
export interface SdtdConnectionInfo {
    /**
     * 
     * @type {string}
     * @memberof SdtdConnectionInfo
     */
    'host': string;
    /**
     * 
     * @type {string}
     * @memberof SdtdConnectionInfo
     */
    'adminUser': string;
    /**
     * 
     * @type {string}
     * @memberof SdtdConnectionInfo
     */
    'adminToken': string;
    /**
     * 
     * @type {boolean}
     * @memberof SdtdConnectionInfo
     */
    'useTls': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SdtdConnectionInfo
     */
    'useCPM': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SdtdConnectionInfo
     */
    'useLegacy': boolean;
}
/**
 * 
 * @export
 * @interface SearchRoleInputDTO
 */
export interface SearchRoleInputDTO {
    /**
     * 
     * @type {string}
     * @memberof SearchRoleInputDTO
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SendMessageInputDTO
 */
export interface SendMessageInputDTO {
    /**
     * 
     * @type {string}
     * @memberof SendMessageInputDTO
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ServiceRoleCreateInputDTO
 */
export interface ServiceRoleCreateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceRoleCreateInputDTO
     */
    'name': string;
    /**
     * 
     * @type {Array<PermissionInputDTO>}
     * @memberof ServiceRoleCreateInputDTO
     */
    'permissions': Array<PermissionInputDTO>;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceRoleCreateInputDTO
     */
    'system'?: boolean;
}
/**
 * 
 * @export
 * @interface Settings
 */
export interface Settings {
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'commandPrefix': string;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'serverChatName': string;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'economyEnabled': string;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'currencyName': string;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'developerMode': string;
    /**
     * 
     * @type {string}
     * @memberof Settings
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof Settings
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof Settings
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface SettingsOutputArrayDTOAPI
 */
export interface SettingsOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<SettingsOutputDTO>}
     * @memberof SettingsOutputArrayDTOAPI
     */
    'data': Array<SettingsOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof SettingsOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface SettingsOutputDTO
 */
export interface SettingsOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof SettingsOutputDTO
     */
    'key': SettingsOutputDTOKeyEnum;
    /**
     * 
     * @type {string}
     * @memberof SettingsOutputDTO
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof SettingsOutputDTO
     */
    'type': SettingsOutputDTOTypeEnum;
}

export const SettingsOutputDTOKeyEnum = {
    CommandPrefix: 'commandPrefix',
    ServerChatName: 'serverChatName',
    EconomyEnabled: 'economyEnabled',
    CurrencyName: 'currencyName',
    DeveloperMode: 'developerMode'
} as const;

export type SettingsOutputDTOKeyEnum = typeof SettingsOutputDTOKeyEnum[keyof typeof SettingsOutputDTOKeyEnum];
export const SettingsOutputDTOTypeEnum = {
    Override: 'override',
    Inherit: 'inherit',
    Global: 'global',
    Default: 'default'
} as const;

export type SettingsOutputDTOTypeEnum = typeof SettingsOutputDTOTypeEnum[keyof typeof SettingsOutputDTOTypeEnum];

/**
 * 
 * @export
 * @interface SettingsOutputDTOAPI
 */
export interface SettingsOutputDTOAPI {
    /**
     * 
     * @type {SettingsOutputDTO}
     * @memberof SettingsOutputDTOAPI
     */
    'data': SettingsOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof SettingsOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface SettingsSetDTO
 */
export interface SettingsSetDTO {
    /**
     * 
     * @type {string}
     * @memberof SettingsSetDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {any}
     * @memberof SettingsSetDTO
     */
    'value': any;
}
/**
 * 
 * @export
 * @interface ShopImportOptions
 */
export interface ShopImportOptions {
    /**
     * 
     * @type {boolean}
     * @memberof ShopImportOptions
     */
    'replace'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ShopImportOptions
     */
    'draft'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShopImportOptions
     */
    'gameServerId': string;
}
/**
 * 
 * @export
 * @interface ShopListingCreateDTO
 */
export interface ShopListingCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof ShopListingCreateDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {Array<ShopListingItemMetaInputDTO>}
     * @memberof ShopListingCreateDTO
     */
    'items': Array<ShopListingItemMetaInputDTO>;
    /**
     * 
     * @type {number}
     * @memberof ShopListingCreateDTO
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof ShopListingCreateDTO
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopListingCreateDTO
     */
    'draft'?: boolean;
}
/**
 * 
 * @export
 * @interface ShopListingItemMetaInputDTO
 */
export interface ShopListingItemMetaInputDTO {
    /**
     * 
     * @type {number}
     * @memberof ShopListingItemMetaInputDTO
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ShopListingItemMetaInputDTO
     */
    'quality'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopListingItemMetaInputDTO
     */
    'itemId': string;
}
/**
 * 
 * @export
 * @interface ShopListingItemMetaOutputDTO
 */
export interface ShopListingItemMetaOutputDTO {
    /**
     * 
     * @type {number}
     * @memberof ShopListingItemMetaOutputDTO
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ShopListingItemMetaOutputDTO
     */
    'quality'?: string;
    /**
     * 
     * @type {ItemsOutputDTO}
     * @memberof ShopListingItemMetaOutputDTO
     */
    'item': ItemsOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof ShopListingItemMetaOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopListingItemMetaOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopListingItemMetaOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface ShopListingOutputArrayDTOAPI
 */
export interface ShopListingOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<ShopListingOutputDTO>}
     * @memberof ShopListingOutputArrayDTOAPI
     */
    'data': Array<ShopListingOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ShopListingOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ShopListingOutputDTO
 */
export interface ShopListingOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof ShopListingOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ShopListingOutputDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {Array<ShopListingItemMetaOutputDTO>}
     * @memberof ShopListingOutputDTO
     */
    'items': Array<ShopListingItemMetaOutputDTO>;
    /**
     * 
     * @type {number}
     * @memberof ShopListingOutputDTO
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof ShopListingOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopListingOutputDTO
     */
    'deletedAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {boolean}
     * @memberof ShopListingOutputDTO
     */
    'draft': boolean;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopListingOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopListingOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface ShopListingOutputDTOAPI
 */
export interface ShopListingOutputDTOAPI {
    /**
     * 
     * @type {ShopListingOutputDTO}
     * @memberof ShopListingOutputDTOAPI
     */
    'data': ShopListingOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ShopListingOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ShopListingSearchInputAllowedFilters
 */
export interface ShopListingSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopListingSearchInputAllowedFilters
     */
    'id'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopListingSearchInputAllowedFilters
     */
    'gameServerId'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ShopListingSearchInputAllowedFilters
     */
    'price'?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopListingSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof ShopListingSearchInputAllowedFilters
     */
    'draft'?: boolean;
}
/**
 * 
 * @export
 * @interface ShopListingSearchInputDTO
 */
export interface ShopListingSearchInputDTO {
    /**
     * 
     * @type {ShopListingSearchInputAllowedFilters}
     * @memberof ShopListingSearchInputDTO
     */
    'filters'?: ShopListingSearchInputAllowedFilters;
    /**
     * 
     * @type {ShopListingSearchInputAllowedFilters}
     * @memberof ShopListingSearchInputDTO
     */
    'search'?: ShopListingSearchInputAllowedFilters;
    /**
     * 
     * @type {ShopSearchInputAllowedRangeFilter}
     * @memberof ShopListingSearchInputDTO
     */
    'greaterThan'?: ShopSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {ShopSearchInputAllowedRangeFilter}
     * @memberof ShopListingSearchInputDTO
     */
    'lessThan'?: ShopSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {number}
     * @memberof ShopListingSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopListingSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopListingSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopListingSearchInputDTO
     */
    'sortDirection'?: ShopListingSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopListingSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const ShopListingSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ShopListingSearchInputDTOSortDirectionEnum = typeof ShopListingSearchInputDTOSortDirectionEnum[keyof typeof ShopListingSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface ShopListingUpdateDTO
 */
export interface ShopListingUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof ShopListingUpdateDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {Array<ShopListingItemMetaInputDTO>}
     * @memberof ShopListingUpdateDTO
     */
    'items'?: Array<ShopListingItemMetaInputDTO>;
    /**
     * 
     * @type {number}
     * @memberof ShopListingUpdateDTO
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopListingUpdateDTO
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ShopListingUpdateDTO
     */
    'draft'?: boolean;
}
/**
 * 
 * @export
 * @interface ShopOrderCreateDTO
 */
export interface ShopOrderCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof ShopOrderCreateDTO
     */
    'listingId': string;
    /**
     * 
     * @type {string}
     * @memberof ShopOrderCreateDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {number}
     * @memberof ShopOrderCreateDTO
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ShopOrderCreateInternalDTO
 */
export interface ShopOrderCreateInternalDTO {
    /**
     * 
     * @type {string}
     * @memberof ShopOrderCreateInternalDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopOrderCreateInternalDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {string}
     * @memberof ShopOrderCreateInternalDTO
     */
    'listingId': string;
    /**
     * 
     * @type {number}
     * @memberof ShopOrderCreateInternalDTO
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface ShopOrderOutputArrayDTOAPI
 */
export interface ShopOrderOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<ShopOrderOutputDTO>}
     * @memberof ShopOrderOutputArrayDTOAPI
     */
    'data': Array<ShopOrderOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ShopOrderOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ShopOrderOutputDTO
 */
export interface ShopOrderOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof ShopOrderOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ShopOrderOutputDTO
     */
    'listingId': string;
    /**
     * 
     * @type {string}
     * @memberof ShopOrderOutputDTO
     */
    'playerId': string;
    /**
     * 
     * @type {string}
     * @memberof ShopOrderOutputDTO
     */
    'gameServerId': string;
    /**
     * 
     * @type {number}
     * @memberof ShopOrderOutputDTO
     */
    'amount': number;
    /**
     * 
     * @type {string}
     * @memberof ShopOrderOutputDTO
     */
    'status': ShopOrderOutputDTOStatusEnum;
    /**
     * 
     * @type {ShopListingOutputDTO}
     * @memberof ShopOrderOutputDTO
     */
    'listing'?: ShopListingOutputDTO;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopOrderOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopOrderOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}

export const ShopOrderOutputDTOStatusEnum = {
    Completed: 'COMPLETED',
    Paid: 'PAID',
    Canceled: 'CANCELED'
} as const;

export type ShopOrderOutputDTOStatusEnum = typeof ShopOrderOutputDTOStatusEnum[keyof typeof ShopOrderOutputDTOStatusEnum];

/**
 * 
 * @export
 * @interface ShopOrderOutputDTOAPI
 */
export interface ShopOrderOutputDTOAPI {
    /**
     * 
     * @type {ShopOrderOutputDTO}
     * @memberof ShopOrderOutputDTOAPI
     */
    'data': ShopOrderOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof ShopOrderOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface ShopOrderSearchInputAllowedFilters
 */
export interface ShopOrderSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopOrderSearchInputAllowedFilters
     */
    'listingId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopOrderSearchInputAllowedFilters
     */
    'gameServerId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopOrderSearchInputAllowedFilters
     */
    'playerId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopOrderSearchInputAllowedFilters
     */
    'userId'?: Array<string>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ShopOrderSearchInputAllowedFilters
     */
    'amount'?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopOrderSearchInputAllowedFilters
     */
    'status'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopOrderSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ShopOrderSearchInputAllowedRangeFilter
 */
export interface ShopOrderSearchInputAllowedRangeFilter {
    /**
     * 
     * @type {number}
     * @memberof ShopOrderSearchInputAllowedRangeFilter
     */
    'amount'?: number;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopOrderSearchInputAllowedRangeFilter
     */
    'createdAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopOrderSearchInputAllowedRangeFilter
     */
    'updatedAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface ShopOrderSearchInputDTO
 */
export interface ShopOrderSearchInputDTO {
    /**
     * 
     * @type {ShopOrderSearchInputAllowedFilters}
     * @memberof ShopOrderSearchInputDTO
     */
    'filters'?: ShopOrderSearchInputAllowedFilters;
    /**
     * 
     * @type {ShopOrderSearchInputAllowedFilters}
     * @memberof ShopOrderSearchInputDTO
     */
    'search'?: ShopOrderSearchInputAllowedFilters;
    /**
     * 
     * @type {ShopOrderSearchInputAllowedRangeFilter}
     * @memberof ShopOrderSearchInputDTO
     */
    'greaterThan'?: ShopOrderSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {ShopOrderSearchInputAllowedRangeFilter}
     * @memberof ShopOrderSearchInputDTO
     */
    'lessThan'?: ShopOrderSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {number}
     * @memberof ShopOrderSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof ShopOrderSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof ShopOrderSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShopOrderSearchInputDTO
     */
    'sortDirection'?: ShopOrderSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ShopOrderSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const ShopOrderSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type ShopOrderSearchInputDTOSortDirectionEnum = typeof ShopOrderSearchInputDTOSortDirectionEnum[keyof typeof ShopOrderSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface ShopOrderUpdateDTO
 */
export interface ShopOrderUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof ShopOrderUpdateDTO
     */
    'status': ShopOrderUpdateDTOStatusEnum;
}

export const ShopOrderUpdateDTOStatusEnum = {
    Completed: 'COMPLETED',
    Paid: 'PAID',
    Canceled: 'CANCELED'
} as const;

export type ShopOrderUpdateDTOStatusEnum = typeof ShopOrderUpdateDTOStatusEnum[keyof typeof ShopOrderUpdateDTOStatusEnum];

/**
 * 
 * @export
 * @interface ShopSearchInputAllowedRangeFilter
 */
export interface ShopSearchInputAllowedRangeFilter {
    /**
     * 
     * @type {number}
     * @memberof ShopSearchInputAllowedRangeFilter
     */
    'price'?: number;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopSearchInputAllowedRangeFilter
     */
    'deletedAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopSearchInputAllowedRangeFilter
     */
    'createdAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof ShopSearchInputAllowedRangeFilter
     */
    'updatedAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface SmallModuleVersionOutputDTO
 */
export interface SmallModuleVersionOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof SmallModuleVersionOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SmallModuleVersionOutputDTO
     */
    'tag': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof SmallModuleVersionOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof SmallModuleVersionOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * @type StatsControllerGetPingStatsStartDateParameter
 * @export
 */
export type StatsControllerGetPingStatsStartDateParameter = string;

/**
 * 
 * @export
 * @interface StatsOutputDTO
 */
export interface StatsOutputDTO {
    /**
     * 
     * @type {object}
     * @memberof StatsOutputDTO
     */
    'values': object;
}
/**
 * 
 * @export
 * @interface StatsOutputDTOAPI
 */
export interface StatsOutputDTOAPI {
    /**
     * 
     * @type {StatsOutputDTO}
     * @memberof StatsOutputDTOAPI
     */
    'data': StatsOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof StatsOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface TakaroEventCommandDetails
 */
export interface TakaroEventCommandDetails {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventCommandDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventCommandDetails
     */
    'name': string;
    /**
     * 
     * @type {object}
     * @memberof TakaroEventCommandDetails
     */
    'arguments': object;
}
/**
 * 
 * @export
 * @interface TakaroEventCommandExecuted
 */
export interface TakaroEventCommandExecuted {
    /**
     * 
     * @type {TakaroEventFunctionResult}
     * @memberof TakaroEventCommandExecuted
     */
    'result': TakaroEventFunctionResult;
    /**
     * 
     * @type {TakaroEventCommandDetails}
     * @memberof TakaroEventCommandExecuted
     */
    'command'?: TakaroEventCommandDetails;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventCommandExecuted
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventCronjobDetails
 */
export interface TakaroEventCronjobDetails {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventCronjobDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventCronjobDetails
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TakaroEventCronjobExecuted
 */
export interface TakaroEventCronjobExecuted {
    /**
     * 
     * @type {TakaroEventFunctionResult}
     * @memberof TakaroEventCronjobExecuted
     */
    'result': TakaroEventFunctionResult;
    /**
     * 
     * @type {TakaroEventCronjobDetails}
     * @memberof TakaroEventCronjobExecuted
     */
    'cronjob'?: TakaroEventCronjobDetails;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventCronjobExecuted
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventCurrencyAdded
 */
export interface TakaroEventCurrencyAdded {
    /**
     * 
     * @type {number}
     * @memberof TakaroEventCurrencyAdded
     */
    'amount': number;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventCurrencyAdded
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventCurrencyDeducted
 */
export interface TakaroEventCurrencyDeducted {
    /**
     * 
     * @type {number}
     * @memberof TakaroEventCurrencyDeducted
     */
    'amount': number;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventCurrencyDeducted
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventFunctionLog
 */
export interface TakaroEventFunctionLog {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventFunctionLog
     */
    'msg': string;
    /**
     * 
     * @type {any}
     * @memberof TakaroEventFunctionLog
     */
    'details'?: any;
}
/**
 * 
 * @export
 * @interface TakaroEventFunctionResult
 */
export interface TakaroEventFunctionResult {
    /**
     * 
     * @type {Array<TakaroEventFunctionLog>}
     * @memberof TakaroEventFunctionResult
     */
    'logs': Array<TakaroEventFunctionLog>;
    /**
     * 
     * @type {boolean}
     * @memberof TakaroEventFunctionResult
     */
    'success': boolean;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventFunctionResult
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof TakaroEventFunctionResult
     */
    'tryAgainIn'?: number;
}
/**
 * 
 * @export
 * @interface TakaroEventHookDetails
 */
export interface TakaroEventHookDetails {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventHookDetails
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventHookDetails
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TakaroEventHookExecuted
 */
export interface TakaroEventHookExecuted {
    /**
     * 
     * @type {TakaroEventFunctionResult}
     * @memberof TakaroEventHookExecuted
     */
    'result': TakaroEventFunctionResult;
    /**
     * 
     * @type {TakaroEventHookDetails}
     * @memberof TakaroEventHookExecuted
     */
    'hook'?: TakaroEventHookDetails;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventHookExecuted
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventModuleCreated
 */
export interface TakaroEventModuleCreated {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventModuleCreated
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventModuleDeleted
 */
export interface TakaroEventModuleDeleted {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventModuleDeleted
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventModuleInstalled
 */
export interface TakaroEventModuleInstalled {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventModuleInstalled
     */
    'userConfig': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventModuleInstalled
     */
    'systemConfig': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventModuleInstalled
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventModuleUninstalled
 */
export interface TakaroEventModuleUninstalled {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventModuleUninstalled
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventModuleUpdated
 */
export interface TakaroEventModuleUpdated {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventModuleUpdated
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventPlayerCreated
 */
export interface TakaroEventPlayerCreated {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventPlayerCreated
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventPlayerLinked
 */
export interface TakaroEventPlayerLinked {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventPlayerLinked
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventPlayerNewIpDetected
 */
export interface TakaroEventPlayerNewIpDetected {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventPlayerNewIpDetected
     */
    'country': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventPlayerNewIpDetected
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventPlayerNewIpDetected
     */
    'longitude': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventPlayerNewIpDetected
     */
    'latitude': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventPlayerNewIpDetected
     */
    'ip': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventPlayerNewIpDetected
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventRoleAssigned
 */
export interface TakaroEventRoleAssigned {
    /**
     * 
     * @type {TakaroEventRoleMeta}
     * @memberof TakaroEventRoleAssigned
     */
    'role': TakaroEventRoleMeta;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventRoleAssigned
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventRoleCreated
 */
export interface TakaroEventRoleCreated {
    /**
     * 
     * @type {TakaroEventRoleMeta}
     * @memberof TakaroEventRoleCreated
     */
    'role': TakaroEventRoleMeta;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventRoleCreated
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventRoleDeleted
 */
export interface TakaroEventRoleDeleted {
    /**
     * 
     * @type {TakaroEventRoleMeta}
     * @memberof TakaroEventRoleDeleted
     */
    'role': TakaroEventRoleMeta;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventRoleDeleted
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventRoleMeta
 */
export interface TakaroEventRoleMeta {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventRoleMeta
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventRoleMeta
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TakaroEventRoleRemoved
 */
export interface TakaroEventRoleRemoved {
    /**
     * 
     * @type {TakaroEventRoleMeta}
     * @memberof TakaroEventRoleRemoved
     */
    'role': TakaroEventRoleMeta;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventRoleRemoved
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventRoleUpdated
 */
export interface TakaroEventRoleUpdated {
    /**
     * 
     * @type {TakaroEventRoleMeta}
     * @memberof TakaroEventRoleUpdated
     */
    'role': TakaroEventRoleMeta;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventRoleUpdated
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventServerStatusChanged
 */
export interface TakaroEventServerStatusChanged {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventServerStatusChanged
     */
    'status': string;
    /**
     * 
     * @type {any}
     * @memberof TakaroEventServerStatusChanged
     */
    'details'?: any;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventServerStatusChanged
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventSettingsSet
 */
export interface TakaroEventSettingsSet {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventSettingsSet
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventSettingsSet
     */
    'value'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventSettingsSet
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventShopListingCreated
 */
export interface TakaroEventShopListingCreated {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventShopListingCreated
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventShopListingCreated
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventShopListingDeleted
 */
export interface TakaroEventShopListingDeleted {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventShopListingDeleted
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventShopListingDeleted
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventShopListingUpdated
 */
export interface TakaroEventShopListingUpdated {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventShopListingUpdated
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventShopListingUpdated
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventShopOrderCreated
 */
export interface TakaroEventShopOrderCreated {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventShopOrderCreated
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventShopOrderCreated
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroEventShopOrderStatusChanged
 */
export interface TakaroEventShopOrderStatusChanged {
    /**
     * 
     * @type {string}
     * @memberof TakaroEventShopOrderStatusChanged
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TakaroEventShopOrderStatusChanged
     */
    'status': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroEventShopOrderStatusChanged
     */
    'timestamp': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TakaroModelDTO
 */
export interface TakaroModelDTO {
    /**
     * 
     * @type {string}
     * @memberof TakaroModelDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroModelDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof TakaroModelDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface TeleportPlayerInputDTO
 */
export interface TeleportPlayerInputDTO {
    /**
     * 
     * @type {number}
     * @memberof TeleportPlayerInputDTO
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportPlayerInputDTO
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof TeleportPlayerInputDTO
     */
    'z': number;
}
/**
 * 
 * @export
 * @interface TestReachabilityOutputDTO
 */
export interface TestReachabilityOutputDTO {
    /**
     * 
     * @type {boolean}
     * @memberof TestReachabilityOutputDTO
     */
    'connectable': boolean;
    /**
     * 
     * @type {string}
     * @memberof TestReachabilityOutputDTO
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof TestReachabilityOutputDTO
     */
    'latency'?: number;
}
/**
 * 
 * @export
 * @interface TokenInputDTO
 */
export interface TokenInputDTO {
    /**
     * 
     * @type {string}
     * @memberof TokenInputDTO
     */
    'domainId': string;
}
/**
 * 
 * @export
 * @interface TokenOutputDTO
 */
export interface TokenOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof TokenOutputDTO
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface TokenOutputDTOAPI
 */
export interface TokenOutputDTOAPI {
    /**
     * 
     * @type {TokenOutputDTO}
     * @memberof TokenOutputDTOAPI
     */
    'data': TokenOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof TokenOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface UserAssignmentOutputDTO
 */
export interface UserAssignmentOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof UserAssignmentOutputDTO
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof UserAssignmentOutputDTO
     */
    'roleId': string;
    /**
     * 
     * @type {string}
     * @memberof UserAssignmentOutputDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {RoleOutputDTO}
     * @memberof UserAssignmentOutputDTO
     */
    'role': RoleOutputDTO;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserAssignmentOutputDTO
     */
    'expiresAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof UserAssignmentOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserAssignmentOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserAssignmentOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface UserCreateInputDTO
 */
export interface UserCreateInputDTO {
    /**
     * 
     * @type {string}
     * @memberof UserCreateInputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInputDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInputDTO
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateInputDTO
     */
    'idpId'?: string;
}
/**
 * 
 * @export
 * @interface UserOutputArrayDTOAPI
 */
export interface UserOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<UserOutputWithRolesDTO>}
     * @memberof UserOutputArrayDTOAPI
     */
    'data': Array<UserOutputWithRolesDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof UserOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface UserOutputDTO
 */
export interface UserOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof UserOutputDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutputDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutputDTO
     */
    'idpId': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutputDTO
     */
    'discordId'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserOutputDTO
     */
    'lastSeen': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof UserOutputDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface UserOutputDTOAPI
 */
export interface UserOutputDTOAPI {
    /**
     * 
     * @type {UserOutputWithRolesDTO}
     * @memberof UserOutputDTOAPI
     */
    'data': UserOutputWithRolesDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof UserOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface UserOutputWithRolesDTO
 */
export interface UserOutputWithRolesDTO {
    /**
     * 
     * @type {Array<UserAssignmentOutputDTO>}
     * @memberof UserOutputWithRolesDTO
     */
    'roles': Array<UserAssignmentOutputDTO>;
    /**
     * 
     * @type {string}
     * @memberof UserOutputWithRolesDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserOutputWithRolesDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserOutputWithRolesDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof UserOutputWithRolesDTO
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutputWithRolesDTO
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutputWithRolesDTO
     */
    'idpId': string;
    /**
     * 
     * @type {string}
     * @memberof UserOutputWithRolesDTO
     */
    'discordId'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserOutputWithRolesDTO
     */
    'lastSeen': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof UserOutputWithRolesDTO
     */
    'playerId'?: string;
}
/**
 * 
 * @export
 * @interface UserRoleAssignChangeDTO
 */
export interface UserRoleAssignChangeDTO {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserRoleAssignChangeDTO
     */
    'expiresAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface UserSearchInputAllowedFilters
 */
export interface UserSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSearchInputAllowedFilters
     */
    'name'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSearchInputAllowedFilters
     */
    'idpId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSearchInputAllowedFilters
     */
    'discordId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSearchInputAllowedFilters
     */
    'playerId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSearchInputAllowedFilters
     */
    'roleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserSearchInputAllowedRangeFilter
 */
export interface UserSearchInputAllowedRangeFilter {
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserSearchInputAllowedRangeFilter
     */
    'lastSeen'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserSearchInputAllowedRangeFilter
     */
    'createdAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserSearchInputAllowedRangeFilter
     */
    'updatedAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface UserSearchInputDTO
 */
export interface UserSearchInputDTO {
    /**
     * 
     * @type {UserSearchInputAllowedFilters}
     * @memberof UserSearchInputDTO
     */
    'filters'?: UserSearchInputAllowedFilters;
    /**
     * 
     * @type {UserSearchInputAllowedFilters}
     * @memberof UserSearchInputDTO
     */
    'search'?: UserSearchInputAllowedFilters;
    /**
     * 
     * @type {UserSearchInputAllowedRangeFilter}
     * @memberof UserSearchInputDTO
     */
    'greaterThan'?: UserSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {UserSearchInputAllowedRangeFilter}
     * @memberof UserSearchInputDTO
     */
    'lessThan'?: UserSearchInputAllowedRangeFilter;
    /**
     * 
     * @type {number}
     * @memberof UserSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSearchInputDTO
     */
    'sortDirection'?: UserSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const UserSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type UserSearchInputDTOSortDirectionEnum = typeof UserSearchInputDTOSortDirectionEnum[keyof typeof UserSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface UserUpdateAuthDTO
 */
export interface UserUpdateAuthDTO {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateAuthDTO
     */
    'discordId'?: string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof UserUpdateAuthDTO
     */
    'lastSeen'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface UserUpdateDTO
 */
export interface UserUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateDTO
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface VariableCreateDTO
 */
export interface VariableCreateDTO {
    /**
     * 
     * @type {string}
     * @memberof VariableCreateDTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableCreateDTO
     */
    'value': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof VariableCreateDTO
     */
    'expiresAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof VariableCreateDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableCreateDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableCreateDTO
     */
    'moduleId'?: string;
}
/**
 * 
 * @export
 * @interface VariableOutputArrayDTOAPI
 */
export interface VariableOutputArrayDTOAPI {
    /**
     * 
     * @type {Array<VariableOutputDTO>}
     * @memberof VariableOutputArrayDTOAPI
     */
    'data': Array<VariableOutputDTO>;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof VariableOutputArrayDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface VariableOutputDTO
 */
export interface VariableOutputDTO {
    /**
     * 
     * @type {string}
     * @memberof VariableOutputDTO
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof VariableOutputDTO
     */
    'value': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof VariableOutputDTO
     */
    'expiresAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof VariableOutputDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableOutputDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableOutputDTO
     */
    'moduleId'?: string;
    /**
     * 
     * @type {GameServerOutputDTO}
     * @memberof VariableOutputDTO
     */
    'gameServer'?: GameServerOutputDTO;
    /**
     * 
     * @type {ModuleOutputDTO}
     * @memberof VariableOutputDTO
     */
    'module'?: ModuleOutputDTO;
    /**
     * 
     * @type {PlayerOutputDTO}
     * @memberof VariableOutputDTO
     */
    'player'?: PlayerOutputDTO;
    /**
     * 
     * @type {string}
     * @memberof VariableOutputDTO
     */
    'id': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof VariableOutputDTO
     */
    'createdAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof VariableOutputDTO
     */
    'updatedAt': NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * 
 * @export
 * @interface VariableOutputDTOAPI
 */
export interface VariableOutputDTOAPI {
    /**
     * 
     * @type {VariableOutputDTO}
     * @memberof VariableOutputDTOAPI
     */
    'data': VariableOutputDTO;
    /**
     * 
     * @type {MetadataOutput}
     * @memberof VariableOutputDTOAPI
     */
    'meta': MetadataOutput;
}
/**
 * 
 * @export
 * @interface VariableSearchInputAllowedFilters
 */
export interface VariableSearchInputAllowedFilters {
    /**
     * 
     * @type {Array<string>}
     * @memberof VariableSearchInputAllowedFilters
     */
    'key'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariableSearchInputAllowedFilters
     */
    'gameServerId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariableSearchInputAllowedFilters
     */
    'playerId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariableSearchInputAllowedFilters
     */
    'moduleId'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariableSearchInputAllowedFilters
     */
    'id'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VariableSearchInputDTO
 */
export interface VariableSearchInputDTO {
    /**
     * 
     * @type {VariableSearchInputAllowedFilters}
     * @memberof VariableSearchInputDTO
     */
    'filters'?: VariableSearchInputAllowedFilters;
    /**
     * 
     * @type {VariableSearchInputAllowedFilters}
     * @memberof VariableSearchInputDTO
     */
    'search'?: VariableSearchInputAllowedFilters;
    /**
     * 
     * @type {any}
     * @memberof VariableSearchInputDTO
     */
    'greaterThan'?: any;
    /**
     * 
     * @type {any}
     * @memberof VariableSearchInputDTO
     */
    'lessThan'?: any;
    /**
     * 
     * @type {number}
     * @memberof VariableSearchInputDTO
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof VariableSearchInputDTO
     */
    'limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof VariableSearchInputDTO
     */
    'sortBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableSearchInputDTO
     */
    'sortDirection'?: VariableSearchInputDTOSortDirectionEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof VariableSearchInputDTO
     */
    'extend'?: Array<string>;
}

export const VariableSearchInputDTOSortDirectionEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type VariableSearchInputDTOSortDirectionEnum = typeof VariableSearchInputDTOSortDirectionEnum[keyof typeof VariableSearchInputDTOSortDirectionEnum];

/**
 * 
 * @export
 * @interface VariableUpdateDTO
 */
export interface VariableUpdateDTO {
    /**
     * 
     * @type {string}
     * @memberof VariableUpdateDTO
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableUpdateDTO
     */
    'value': string;
    /**
     * 
     * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
     * @memberof VariableUpdateDTO
     */
    'expiresAt'?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
    /**
     * 
     * @type {string}
     * @memberof VariableUpdateDTO
     */
    'gameServerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableUpdateDTO
     */
    'playerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof VariableUpdateDTO
     */
    'moduleId'?: string;
}

/**
 * CommandApi - axios parameter creator
 * @export
 */
export const CommandApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {CommandCreateDTO} [commandCreateDTO] CommandCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerCreate: async (commandCreateDTO?: CommandCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/command`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create argument
         * @param {CommandArgumentCreateDTO} [commandArgumentCreateDTO] CommandArgumentCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerCreateArgument: async (commandArgumentCreateDTO?: CommandArgumentCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/command/argument`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandArgumentCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get executions
         * @param {string} id 
         * @param {any} [success] 
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerGetExecutions: async (id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commandControllerGetExecutions', 'id', id)
            const localVarPath = `/command/{id}/executions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (success !== undefined) {
                for (const [key, value] of Object.entries(success)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commandControllerGetOne', 'id', id)
            const localVarPath = `/command/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commandControllerRemove', 'id', id)
            const localVarPath = `/command/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove argument
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerRemoveArgument: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commandControllerRemoveArgument', 'id', id)
            const localVarPath = `/command/argument/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {CommandSearchInputDTO} [commandSearchInputDTO] CommandSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerSearch: async (commandSearchInputDTO?: CommandSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/command/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Trigger
         * @param {string} id 
         * @param {CommandTriggerDTO} [commandTriggerDTO] CommandTriggerDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerTrigger: async (id: string, commandTriggerDTO?: CommandTriggerDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commandControllerTrigger', 'id', id)
            const localVarPath = `/command/{id}/trigger`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandTriggerDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {CommandUpdateDTO} [commandUpdateDTO] CommandUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerUpdate: async (id: string, commandUpdateDTO?: CommandUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commandControllerUpdate', 'id', id)
            const localVarPath = `/command/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update argument
         * @param {string} id 
         * @param {CommandArgumentUpdateDTO} [commandArgumentUpdateDTO] CommandArgumentUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerUpdateArgument: async (id: string, commandArgumentUpdateDTO?: CommandArgumentUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('commandControllerUpdateArgument', 'id', id)
            const localVarPath = `/command/argument/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandArgumentUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommandApi - functional programming interface
 * @export
 */
export const CommandApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommandApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {CommandCreateDTO} [commandCreateDTO] CommandCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerCreate(commandCreateDTO?: CommandCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerCreate(commandCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create argument
         * @param {CommandArgumentCreateDTO} [commandArgumentCreateDTO] CommandArgumentCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerCreateArgument(commandArgumentCreateDTO?: CommandArgumentCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandArgumentDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerCreateArgument(commandArgumentCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerCreateArgument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get executions
         * @param {string} id 
         * @param {any} [success] 
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerGetExecutions(id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerGetExecutions(id, success, eventSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerGetExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove argument
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerRemoveArgument(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerRemoveArgument(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerRemoveArgument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {CommandSearchInputDTO} [commandSearchInputDTO] CommandSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerSearch(commandSearchInputDTO?: CommandSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerSearch(commandSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Trigger
         * @param {string} id 
         * @param {CommandTriggerDTO} [commandTriggerDTO] CommandTriggerDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerTrigger(id: string, commandTriggerDTO?: CommandTriggerDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerTrigger(id, commandTriggerDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {CommandUpdateDTO} [commandUpdateDTO] CommandUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerUpdate(id: string, commandUpdateDTO?: CommandUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerUpdate(id, commandUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update argument
         * @param {string} id 
         * @param {CommandArgumentUpdateDTO} [commandArgumentUpdateDTO] CommandArgumentUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async commandControllerUpdateArgument(id: string, commandArgumentUpdateDTO?: CommandArgumentUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandArgumentDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerUpdateArgument(id, commandArgumentUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommandApi.commandControllerUpdateArgument']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommandApi - factory interface
 * @export
 */
export const CommandApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommandApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {CommandCreateDTO} [commandCreateDTO] CommandCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerCreate(commandCreateDTO?: CommandCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<CommandOutputDTOAPI> {
            return localVarFp.commandControllerCreate(commandCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create argument
         * @param {CommandArgumentCreateDTO} [commandArgumentCreateDTO] CommandArgumentCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerCreateArgument(commandArgumentCreateDTO?: CommandArgumentCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<CommandArgumentDTOAPI> {
            return localVarFp.commandControllerCreateArgument(commandArgumentCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get executions
         * @param {string} id 
         * @param {any} [success] 
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerGetExecutions(id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<EventOutputArrayDTOAPI> {
            return localVarFp.commandControllerGetExecutions(id, success, eventSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CommandOutputDTOAPI> {
            return localVarFp.commandControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.commandControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove argument
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerRemoveArgument(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.commandControllerRemoveArgument(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {CommandSearchInputDTO} [commandSearchInputDTO] CommandSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerSearch(commandSearchInputDTO?: CommandSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<CommandOutputArrayDTOAPI> {
            return localVarFp.commandControllerSearch(commandSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Trigger
         * @param {string} id 
         * @param {CommandTriggerDTO} [commandTriggerDTO] CommandTriggerDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerTrigger(id: string, commandTriggerDTO?: CommandTriggerDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.commandControllerTrigger(id, commandTriggerDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {CommandUpdateDTO} [commandUpdateDTO] CommandUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerUpdate(id: string, commandUpdateDTO?: CommandUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<CommandOutputDTOAPI> {
            return localVarFp.commandControllerUpdate(id, commandUpdateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update argument
         * @param {string} id 
         * @param {CommandArgumentUpdateDTO} [commandArgumentUpdateDTO] CommandArgumentUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commandControllerUpdateArgument(id: string, commandArgumentUpdateDTO?: CommandArgumentUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<CommandArgumentDTOAPI> {
            return localVarFp.commandControllerUpdateArgument(id, commandArgumentUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommandApi - object-oriented interface
 * @export
 * @class CommandApi
 * @extends {BaseAPI}
 */
export class CommandApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {CommandCreateDTO} [commandCreateDTO] CommandCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerCreate(commandCreateDTO?: CommandCreateDTO, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerCreate(commandCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Create argument
     * @param {CommandArgumentCreateDTO} [commandArgumentCreateDTO] CommandArgumentCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerCreateArgument(commandArgumentCreateDTO?: CommandArgumentCreateDTO, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerCreateArgument(commandArgumentCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get executions
     * @param {string} id 
     * @param {any} [success] 
     * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerGetExecutions(id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerGetExecutions(id, success, eventSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Remove argument
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerRemoveArgument(id: string, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerRemoveArgument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Search
     * @param {CommandSearchInputDTO} [commandSearchInputDTO] CommandSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerSearch(commandSearchInputDTO?: CommandSearchInputDTO, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerSearch(commandSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {string} id 
     * @param {CommandTriggerDTO} [commandTriggerDTO] CommandTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerTrigger(id: string, commandTriggerDTO?: CommandTriggerDTO, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerTrigger(id, commandTriggerDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id 
     * @param {CommandUpdateDTO} [commandUpdateDTO] CommandUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerUpdate(id: string, commandUpdateDTO?: CommandUpdateDTO, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerUpdate(id, commandUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Update argument
     * @param {string} id 
     * @param {CommandArgumentUpdateDTO} [commandArgumentUpdateDTO] CommandArgumentUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommandApi
     */
    public commandControllerUpdateArgument(id: string, commandArgumentUpdateDTO?: CommandArgumentUpdateDTO, options?: RawAxiosRequestConfig) {
        return CommandApiFp(this.configuration).commandControllerUpdateArgument(id, commandArgumentUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CronJobApi - axios parameter creator
 * @export
 */
export const CronJobApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {CronJobCreateDTO} [cronJobCreateDTO] CronJobCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerCreate: async (cronJobCreateDTO?: CronJobCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cronjob`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cronJobCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get executions
         * @param {string} id 
         * @param {any} [success] 
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerGetExecutions: async (id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cronJobControllerGetExecutions', 'id', id)
            const localVarPath = `/cronjob/{id}/executions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (success !== undefined) {
                for (const [key, value] of Object.entries(success)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cronJobControllerGetOne', 'id', id)
            const localVarPath = `/cronjob/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cronJobControllerRemove', 'id', id)
            const localVarPath = `/cronjob/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {CronJobSearchInputDTO} [cronJobSearchInputDTO] CronJobSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerSearch: async (cronJobSearchInputDTO?: CronJobSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cronjob/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cronJobSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Trigger
         * @param {CronJobTriggerDTO} [cronJobTriggerDTO] CronJobTriggerDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerTrigger: async (cronJobTriggerDTO?: CronJobTriggerDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/cronjob/trigger`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cronJobTriggerDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {CronJobUpdateDTO} [cronJobUpdateDTO] CronJobUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerUpdate: async (id: string, cronJobUpdateDTO?: CronJobUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cronJobControllerUpdate', 'id', id)
            const localVarPath = `/cronjob/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cronJobUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CronJobApi - functional programming interface
 * @export
 */
export const CronJobApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CronJobApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {CronJobCreateDTO} [cronJobCreateDTO] CronJobCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cronJobControllerCreate(cronJobCreateDTO?: CronJobCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronJobOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerCreate(cronJobCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronJobApi.cronJobControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get executions
         * @param {string} id 
         * @param {any} [success] 
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cronJobControllerGetExecutions(id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerGetExecutions(id, success, eventSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronJobApi.cronJobControllerGetExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cronJobControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronJobOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronJobApi.cronJobControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cronJobControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronJobApi.cronJobControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {CronJobSearchInputDTO} [cronJobSearchInputDTO] CronJobSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cronJobControllerSearch(cronJobSearchInputDTO?: CronJobSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronJobOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerSearch(cronJobSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronJobApi.cronJobControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Trigger
         * @param {CronJobTriggerDTO} [cronJobTriggerDTO] CronJobTriggerDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cronJobControllerTrigger(cronJobTriggerDTO?: CronJobTriggerDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerTrigger(cronJobTriggerDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronJobApi.cronJobControllerTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {CronJobUpdateDTO} [cronJobUpdateDTO] CronJobUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cronJobControllerUpdate(id: string, cronJobUpdateDTO?: CronJobUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronJobOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerUpdate(id, cronJobUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CronJobApi.cronJobControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CronJobApi - factory interface
 * @export
 */
export const CronJobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CronJobApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {CronJobCreateDTO} [cronJobCreateDTO] CronJobCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerCreate(cronJobCreateDTO?: CronJobCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<CronJobOutputDTOAPI> {
            return localVarFp.cronJobControllerCreate(cronJobCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get executions
         * @param {string} id 
         * @param {any} [success] 
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerGetExecutions(id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<EventOutputArrayDTOAPI> {
            return localVarFp.cronJobControllerGetExecutions(id, success, eventSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<CronJobOutputDTOAPI> {
            return localVarFp.cronJobControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.cronJobControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {CronJobSearchInputDTO} [cronJobSearchInputDTO] CronJobSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerSearch(cronJobSearchInputDTO?: CronJobSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<CronJobOutputArrayDTOAPI> {
            return localVarFp.cronJobControllerSearch(cronJobSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Trigger
         * @param {CronJobTriggerDTO} [cronJobTriggerDTO] CronJobTriggerDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerTrigger(cronJobTriggerDTO?: CronJobTriggerDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cronJobControllerTrigger(cronJobTriggerDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {CronJobUpdateDTO} [cronJobUpdateDTO] CronJobUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cronJobControllerUpdate(id: string, cronJobUpdateDTO?: CronJobUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<CronJobOutputDTOAPI> {
            return localVarFp.cronJobControllerUpdate(id, cronJobUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CronJobApi - object-oriented interface
 * @export
 * @class CronJobApi
 * @extends {BaseAPI}
 */
export class CronJobApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {CronJobCreateDTO} [cronJobCreateDTO] CronJobCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronJobApi
     */
    public cronJobControllerCreate(cronJobCreateDTO?: CronJobCreateDTO, options?: RawAxiosRequestConfig) {
        return CronJobApiFp(this.configuration).cronJobControllerCreate(cronJobCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get executions
     * @param {string} id 
     * @param {any} [success] 
     * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronJobApi
     */
    public cronJobControllerGetExecutions(id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig) {
        return CronJobApiFp(this.configuration).cronJobControllerGetExecutions(id, success, eventSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronJobApi
     */
    public cronJobControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return CronJobApiFp(this.configuration).cronJobControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronJobApi
     */
    public cronJobControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return CronJobApiFp(this.configuration).cronJobControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Search
     * @param {CronJobSearchInputDTO} [cronJobSearchInputDTO] CronJobSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronJobApi
     */
    public cronJobControllerSearch(cronJobSearchInputDTO?: CronJobSearchInputDTO, options?: RawAxiosRequestConfig) {
        return CronJobApiFp(this.configuration).cronJobControllerSearch(cronJobSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {CronJobTriggerDTO} [cronJobTriggerDTO] CronJobTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronJobApi
     */
    public cronJobControllerTrigger(cronJobTriggerDTO?: CronJobTriggerDTO, options?: RawAxiosRequestConfig) {
        return CronJobApiFp(this.configuration).cronJobControllerTrigger(cronJobTriggerDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id 
     * @param {CronJobUpdateDTO} [cronJobUpdateDTO] CronJobUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CronJobApi
     */
    public cronJobControllerUpdate(id: string, cronJobUpdateDTO?: CronJobUpdateDTO, options?: RawAxiosRequestConfig) {
        return CronJobApiFp(this.configuration).cronJobControllerUpdate(id, cronJobUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DiscordApi - axios parameter creator
 * @export
 */
export const DiscordApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordControllerGetInvite: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/discord/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search
         * @param {GuildSearchInputDTO} [guildSearchInputDTO] GuildSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordControllerSearch: async (guildSearchInputDTO?: GuildSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/discord/guilds/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guildSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Send message
         * @param {string} id 
         * @param {SendMessageInputDTO} [sendMessageInputDTO] SendMessageInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordControllerSendMessage: async (id: string, sendMessageInputDTO?: SendMessageInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discordControllerSendMessage', 'id', id)
            const localVarPath = `/discord/channels/{id}/message`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMessageInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update guild
         * @param {string} id 
         * @param {GuildApiUpdateDTO} [guildApiUpdateDTO] GuildApiUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordControllerUpdateGuild: async (id: string, guildApiUpdateDTO?: GuildApiUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discordControllerUpdateGuild', 'id', id)
            const localVarPath = `/discord/guilds/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(guildApiUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscordApi - functional programming interface
 * @export
 */
export const DiscordApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscordApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discordControllerGetInvite(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordInviteOutputDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discordControllerGetInvite(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiscordApi.discordControllerGetInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search
         * @param {GuildSearchInputDTO} [guildSearchInputDTO] GuildSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discordControllerSearch(guildSearchInputDTO?: GuildSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discordControllerSearch(guildSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiscordApi.discordControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Send message
         * @param {string} id 
         * @param {SendMessageInputDTO} [sendMessageInputDTO] SendMessageInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discordControllerSendMessage(id: string, sendMessageInputDTO?: SendMessageInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discordControllerSendMessage(id, sendMessageInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiscordApi.discordControllerSendMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update guild
         * @param {string} id 
         * @param {GuildApiUpdateDTO} [guildApiUpdateDTO] GuildApiUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discordControllerUpdateGuild(id: string, guildApiUpdateDTO?: GuildApiUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discordControllerUpdateGuild(id, guildApiUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DiscordApi.discordControllerUpdateGuild']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DiscordApi - factory interface
 * @export
 */
export const DiscordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscordApiFp(configuration)
    return {
        /**
         * 
         * @summary Get invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordControllerGetInvite(options?: RawAxiosRequestConfig): AxiosPromise<DiscordInviteOutputDTO> {
            return localVarFp.discordControllerGetInvite(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search
         * @param {GuildSearchInputDTO} [guildSearchInputDTO] GuildSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordControllerSearch(guildSearchInputDTO?: GuildSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<GuildOutputArrayDTOAPI> {
            return localVarFp.discordControllerSearch(guildSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Send message
         * @param {string} id 
         * @param {SendMessageInputDTO} [sendMessageInputDTO] SendMessageInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordControllerSendMessage(id: string, sendMessageInputDTO?: SendMessageInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.discordControllerSendMessage(id, sendMessageInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update guild
         * @param {string} id 
         * @param {GuildApiUpdateDTO} [guildApiUpdateDTO] GuildApiUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discordControllerUpdateGuild(id: string, guildApiUpdateDTO?: GuildApiUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<GuildOutputDTOAPI> {
            return localVarFp.discordControllerUpdateGuild(id, guildApiUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiscordApi - object-oriented interface
 * @export
 * @class DiscordApi
 * @extends {BaseAPI}
 */
export class DiscordApi extends BaseAPI {
    /**
     * 
     * @summary Get invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordApi
     */
    public discordControllerGetInvite(options?: RawAxiosRequestConfig) {
        return DiscordApiFp(this.configuration).discordControllerGetInvite(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search
     * @param {GuildSearchInputDTO} [guildSearchInputDTO] GuildSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordApi
     */
    public discordControllerSearch(guildSearchInputDTO?: GuildSearchInputDTO, options?: RawAxiosRequestConfig) {
        return DiscordApiFp(this.configuration).discordControllerSearch(guildSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Send message
     * @param {string} id 
     * @param {SendMessageInputDTO} [sendMessageInputDTO] SendMessageInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordApi
     */
    public discordControllerSendMessage(id: string, sendMessageInputDTO?: SendMessageInputDTO, options?: RawAxiosRequestConfig) {
        return DiscordApiFp(this.configuration).discordControllerSendMessage(id, sendMessageInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update guild
     * @param {string} id 
     * @param {GuildApiUpdateDTO} [guildApiUpdateDTO] GuildApiUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscordApi
     */
    public discordControllerUpdateGuild(id: string, guildApiUpdateDTO?: GuildApiUpdateDTO, options?: RawAxiosRequestConfig) {
        return DiscordApiFp(this.configuration).discordControllerUpdateGuild(id, guildApiUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainApi - axios parameter creator
 * @export
 */
export const DomainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create
         * @param {DomainCreateInputDTO} [domainCreateInputDTO] DomainCreateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerCreate: async (domainCreateInputDTO?: DomainCreateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/domain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-takaro-admin-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainCreateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('domainControllerGetOne', 'id', id)
            const localVarPath = `/domain/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-takaro-admin-token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get token
         * @param {TokenInputDTO} [tokenInputDTO] TokenInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerGetToken: async (tokenInputDTO?: TokenInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-takaro-admin-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('domainControllerRemove', 'id', id)
            const localVarPath = `/domain/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-takaro-admin-token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search
         * @param {DomainSearchInputDTO} [domainSearchInputDTO] DomainSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerSearch: async (domainSearchInputDTO?: DomainSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/domain/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-takaro-admin-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update
         * @param {string} id 
         * @param {DomainUpdateInputDTO} [domainUpdateInputDTO] DomainUpdateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerUpdate: async (id: string, domainUpdateInputDTO?: DomainUpdateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('domainControllerUpdate', 'id', id)
            const localVarPath = `/domain/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication adminAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-takaro-admin-token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainUpdateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainApi - functional programming interface
 * @export
 */
export const DomainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {DomainCreateInputDTO} [domainCreateInputDTO] DomainCreateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainControllerCreate(domainCreateInputDTO?: DomainCreateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainCreateOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerCreate(domainCreateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainApi.domainControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainApi.domainControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get token
         * @param {TokenInputDTO} [tokenInputDTO] TokenInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainControllerGetToken(tokenInputDTO?: TokenInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerGetToken(tokenInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainApi.domainControllerGetToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainApi.domainControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search
         * @param {DomainSearchInputDTO} [domainSearchInputDTO] DomainSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainControllerSearch(domainSearchInputDTO?: DomainSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerSearch(domainSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainApi.domainControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update
         * @param {string} id 
         * @param {DomainUpdateInputDTO} [domainUpdateInputDTO] DomainUpdateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainControllerUpdate(id: string, domainUpdateInputDTO?: DomainUpdateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerUpdate(id, domainUpdateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DomainApi.domainControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DomainApi - factory interface
 * @export
 */
export const DomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainApiFp(configuration)
    return {
        /**
         * 
         * @summary Create
         * @param {DomainCreateInputDTO} [domainCreateInputDTO] DomainCreateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerCreate(domainCreateInputDTO?: DomainCreateInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<DomainCreateOutputDTOAPI> {
            return localVarFp.domainControllerCreate(domainCreateInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<DomainOutputDTOAPI> {
            return localVarFp.domainControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get token
         * @param {TokenInputDTO} [tokenInputDTO] TokenInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerGetToken(tokenInputDTO?: TokenInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<TokenOutputDTOAPI> {
            return localVarFp.domainControllerGetToken(tokenInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.domainControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search
         * @param {DomainSearchInputDTO} [domainSearchInputDTO] DomainSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerSearch(domainSearchInputDTO?: DomainSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<DomainOutputArrayDTOAPI> {
            return localVarFp.domainControllerSearch(domainSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update
         * @param {string} id 
         * @param {DomainUpdateInputDTO} [domainUpdateInputDTO] DomainUpdateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainControllerUpdate(id: string, domainUpdateInputDTO?: DomainUpdateInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<DomainOutputDTOAPI> {
            return localVarFp.domainControllerUpdate(id, domainUpdateInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainApi - object-oriented interface
 * @export
 * @class DomainApi
 * @extends {BaseAPI}
 */
export class DomainApi extends BaseAPI {
    /**
     * 
     * @summary Create
     * @param {DomainCreateInputDTO} [domainCreateInputDTO] DomainCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public domainControllerCreate(domainCreateInputDTO?: DomainCreateInputDTO, options?: RawAxiosRequestConfig) {
        return DomainApiFp(this.configuration).domainControllerCreate(domainCreateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public domainControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return DomainApiFp(this.configuration).domainControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get token
     * @param {TokenInputDTO} [tokenInputDTO] TokenInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public domainControllerGetToken(tokenInputDTO?: TokenInputDTO, options?: RawAxiosRequestConfig) {
        return DomainApiFp(this.configuration).domainControllerGetToken(tokenInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public domainControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return DomainApiFp(this.configuration).domainControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search
     * @param {DomainSearchInputDTO} [domainSearchInputDTO] DomainSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public domainControllerSearch(domainSearchInputDTO?: DomainSearchInputDTO, options?: RawAxiosRequestConfig) {
        return DomainApiFp(this.configuration).domainControllerSearch(domainSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update
     * @param {string} id 
     * @param {DomainUpdateInputDTO} [domainUpdateInputDTO] DomainUpdateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainApi
     */
    public domainControllerUpdate(id: string, domainUpdateInputDTO?: DomainUpdateInputDTO, options?: RawAxiosRequestConfig) {
        return DomainApiFp(this.configuration).domainControllerUpdate(id, domainUpdateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_EVENTS`
         * @summary Create
         * @param {EventCreateDTO} [eventCreateDTO] EventCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerCreate: async (eventCreateDTO?: EventCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches events where cronjob, hook and command failed. Supports all the common query parameters   Required permissions: `READ_MODULES`, `READ_EVENTS`
         * @summary Get failed functions
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerGetFailedFunctions: async (eventSearchInputDTO?: EventSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event/filter/failed-functions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_EVENTS`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('eventControllerGetOne', 'id', id)
            const localVarPath = `/event/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_EVENTS`
         * @summary Search
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerSearch: async (eventSearchInputDTO?: EventSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/event/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_EVENTS`
         * @summary Create
         * @param {EventCreateDTO} [eventCreateDTO] EventCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerCreate(eventCreateDTO?: EventCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerCreate(eventCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches events where cronjob, hook and command failed. Supports all the common query parameters   Required permissions: `READ_MODULES`, `READ_EVENTS`
         * @summary Get failed functions
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerGetFailedFunctions(eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerGetFailedFunctions(eventSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventControllerGetFailedFunctions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_EVENTS`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_EVENTS`
         * @summary Search
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventControllerSearch(eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerSearch(eventSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventApi.eventControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_EVENTS`
         * @summary Create
         * @param {EventCreateDTO} [eventCreateDTO] EventCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerCreate(eventCreateDTO?: EventCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<EventOutputDTO> {
            return localVarFp.eventControllerCreate(eventCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches events where cronjob, hook and command failed. Supports all the common query parameters   Required permissions: `READ_MODULES`, `READ_EVENTS`
         * @summary Get failed functions
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerGetFailedFunctions(eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<EventOutputArrayDTOAPI> {
            return localVarFp.eventControllerGetFailedFunctions(eventSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_EVENTS`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EventOutputDTO> {
            return localVarFp.eventControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_EVENTS`
         * @summary Search
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventControllerSearch(eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<EventOutputArrayDTOAPI> {
            return localVarFp.eventControllerSearch(eventSearchInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_EVENTS`
     * @summary Create
     * @param {EventCreateDTO} [eventCreateDTO] EventCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerCreate(eventCreateDTO?: EventCreateDTO, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerCreate(eventCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches events where cronjob, hook and command failed. Supports all the common query parameters   Required permissions: `READ_MODULES`, `READ_EVENTS`
     * @summary Get failed functions
     * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerGetFailedFunctions(eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerGetFailedFunctions(eventSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_EVENTS`
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_EVENTS`
     * @summary Search
     * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventApi
     */
    public eventControllerSearch(eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig) {
        return EventApiFp(this.configuration).eventControllerSearch(eventSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExternalAuthApi - axios parameter creator
 * @export
 */
export const ExternalAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Auth discord
         * @param {string} redirect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalAuthControllerAuthDiscord: async (redirect: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirect' is not null or undefined
            assertParamExists('externalAuthControllerAuthDiscord', 'redirect', redirect)
            const localVarPath = `/auth/discord`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirect !== undefined) {
                localVarQueryParameter['redirect'] = redirect;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Auth discord return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalAuthControllerAuthDiscordReturn: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/discord/return`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalAuthApi - functional programming interface
 * @export
 */
export const ExternalAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExternalAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Auth discord
         * @param {string} redirect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalAuthControllerAuthDiscord(redirect: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalAuthControllerAuthDiscord(redirect, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAuthApi.externalAuthControllerAuthDiscord']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Auth discord return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async externalAuthControllerAuthDiscordReturn(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.externalAuthControllerAuthDiscordReturn(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExternalAuthApi.externalAuthControllerAuthDiscordReturn']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExternalAuthApi - factory interface
 * @export
 */
export const ExternalAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExternalAuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Auth discord
         * @param {string} redirect 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalAuthControllerAuthDiscord(redirect: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.externalAuthControllerAuthDiscord(redirect, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Auth discord return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        externalAuthControllerAuthDiscordReturn(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.externalAuthControllerAuthDiscordReturn(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExternalAuthApi - object-oriented interface
 * @export
 * @class ExternalAuthApi
 * @extends {BaseAPI}
 */
export class ExternalAuthApi extends BaseAPI {
    /**
     * 
     * @summary Auth discord
     * @param {string} redirect 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAuthApi
     */
    public externalAuthControllerAuthDiscord(redirect: string, options?: RawAxiosRequestConfig) {
        return ExternalAuthApiFp(this.configuration).externalAuthControllerAuthDiscord(redirect, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Auth discord return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalAuthApi
     */
    public externalAuthControllerAuthDiscordReturn(options?: RawAxiosRequestConfig) {
        return ExternalAuthApiFp(this.configuration).externalAuthControllerAuthDiscordReturn(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FunctionApi - axios parameter creator
 * @export
 */
export const FunctionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {FunctionCreateDTO} [functionCreateDTO] FunctionCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerCreate: async (functionCreateDTO?: FunctionCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/function`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(functionCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('functionControllerGetOne', 'id', id)
            const localVarPath = `/function/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('functionControllerRemove', 'id', id)
            const localVarPath = `/function/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {FunctionSearchInputDTO} [functionSearchInputDTO] FunctionSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerSearch: async (functionSearchInputDTO?: FunctionSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/function/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(functionSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {FunctionUpdateDTO} [functionUpdateDTO] FunctionUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerUpdate: async (id: string, functionUpdateDTO?: FunctionUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('functionControllerUpdate', 'id', id)
            const localVarPath = `/function/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(functionUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FunctionApi - functional programming interface
 * @export
 */
export const FunctionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FunctionApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {FunctionCreateDTO} [functionCreateDTO] FunctionCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionControllerCreate(functionCreateDTO?: FunctionCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerCreate(functionCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionApi.functionControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionApi.functionControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionApi.functionControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {FunctionSearchInputDTO} [functionSearchInputDTO] FunctionSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionControllerSearch(functionSearchInputDTO?: FunctionSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerSearch(functionSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionApi.functionControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {FunctionUpdateDTO} [functionUpdateDTO] FunctionUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionControllerUpdate(id: string, functionUpdateDTO?: FunctionUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerUpdate(id, functionUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FunctionApi.functionControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FunctionApi - factory interface
 * @export
 */
export const FunctionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FunctionApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {FunctionCreateDTO} [functionCreateDTO] FunctionCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerCreate(functionCreateDTO?: FunctionCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<FunctionOutputDTOAPI> {
            return localVarFp.functionControllerCreate(functionCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FunctionOutputDTOAPI> {
            return localVarFp.functionControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.functionControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {FunctionSearchInputDTO} [functionSearchInputDTO] FunctionSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerSearch(functionSearchInputDTO?: FunctionSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<FunctionOutputArrayDTOAPI> {
            return localVarFp.functionControllerSearch(functionSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {FunctionUpdateDTO} [functionUpdateDTO] FunctionUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionControllerUpdate(id: string, functionUpdateDTO?: FunctionUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<FunctionOutputDTOAPI> {
            return localVarFp.functionControllerUpdate(id, functionUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FunctionApi - object-oriented interface
 * @export
 * @class FunctionApi
 * @extends {BaseAPI}
 */
export class FunctionApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {FunctionCreateDTO} [functionCreateDTO] FunctionCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionApi
     */
    public functionControllerCreate(functionCreateDTO?: FunctionCreateDTO, options?: RawAxiosRequestConfig) {
        return FunctionApiFp(this.configuration).functionControllerCreate(functionCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionApi
     */
    public functionControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return FunctionApiFp(this.configuration).functionControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionApi
     */
    public functionControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return FunctionApiFp(this.configuration).functionControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Search
     * @param {FunctionSearchInputDTO} [functionSearchInputDTO] FunctionSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionApi
     */
    public functionControllerSearch(functionSearchInputDTO?: FunctionSearchInputDTO, options?: RawAxiosRequestConfig) {
        return FunctionApiFp(this.configuration).functionControllerSearch(functionSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id 
     * @param {FunctionUpdateDTO} [functionUpdateDTO] FunctionUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionApi
     */
    public functionControllerUpdate(id: string, functionUpdateDTO?: FunctionUpdateDTO, options?: RawAxiosRequestConfig) {
        return FunctionApiFp(this.configuration).functionControllerUpdate(id, functionUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GameServerApi - axios parameter creator
 * @export
 */
export const GameServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Ban a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Ban player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {BanPlayerInputDTO} [banPlayerInputDTO] BanPlayerInputDTO
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        gameServerControllerBanPlayer: async (gameServerId: string, playerId: string, banPlayerInputDTO?: BanPlayerInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('gameServerControllerBanPlayer', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('gameServerControllerBanPlayer', 'playerId', playerId)
            const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/ban`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banPlayerInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a gameserver   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Create
         * @param {GameServerCreateDTO} [gameServerCreateDTO] GameServerCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerCreate: async (gameServerCreateDTO?: GameServerCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gameserver`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameServerCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a raw command on a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Execute command
         * @param {string} id 
         * @param {CommandExecuteInputDTO} [commandExecuteInputDTO] CommandExecuteInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerExecuteCommand: async (id: string, commandExecuteInputDTO?: CommandExecuteInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerExecuteCommand', 'id', id)
            const localVarPath = `/gameserver/{id}/command`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commandExecuteInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch status of an import from CSMM   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Get import
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGetImport: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerGetImport', 'id', id)
            const localVarPath = `/gameserver/import/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a gameserver by id
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerGetOne', 'id', id)
            const localVarPath = `/gameserver/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of players on a gameserver. Requires gameserver to be online and reachable.   Required permissions: `READ_PLAYERS`
         * @summary Get players
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGetPlayers: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerGetPlayers', 'id', id)
            const localVarPath = `/gameserver/{id}/players`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch gameserver types (7dtd, Rust, ...)
         * @summary Get types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGetTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gameserver/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Give an item to a player. Requires gameserver to be online and reachable. Depending on the underlying game implementation, it\'s possible that the item is dropped on the ground instead of placed directly in the player\'s inventory.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Give item
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {GiveItemInputDTO} [giveItemInputDTO] GiveItemInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGiveItem: async (gameServerId: string, playerId: string, giveItemInputDTO?: GiveItemInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('gameServerControllerGiveItem', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('gameServerControllerGiveItem', 'playerId', playerId)
            const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/giveItem`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giveItemInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import a gameserver from CSMM.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Import from csmm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerImportFromCSMM: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gameserver/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Kick a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Kick player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {KickPlayerInputDTO} [kickPlayerInputDTO] KickPlayerInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerKickPlayer: async (gameServerId: string, playerId: string, kickPlayerInputDTO?: KickPlayerInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('gameServerControllerKickPlayer', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('gameServerControllerKickPlayer', 'playerId', playerId)
            const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/kick`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(kickPlayerInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List bans for a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary List bans
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        gameServerControllerListBans: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerListBans', 'id', id)
            const localVarPath = `/gameserver/{id}/bans`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a gameserver   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerRemove', 'id', id)
            const localVarPath = `/gameserver/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch gameservers
         * @summary Search
         * @param {GameServerSearchInputDTO} [gameServerSearchInputDTO] GameServerSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerSearch: async (gameServerSearchInputDTO?: GameServerSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gameserver/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameServerSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a message in gameserver chat. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Send message
         * @param {string} id 
         * @param {MessageSendInputDTO} [messageSendInputDTO] MessageSendInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerSendMessage: async (id: string, messageSendInputDTO?: MessageSendInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerSendMessage', 'id', id)
            const localVarPath = `/gameserver/{id}/message`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageSendInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shuts down the gameserver. This is a \'soft\' shutdown, meaning the gameserver will be stopped gracefully. If the gameserver is not reachable, this will have no effect. Note that most hosting providers will automatically restart the gameserver after a shutdown, which makes this operation act as a \'restart\' instead.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Shutdown
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerShutdown: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerShutdown', 'id', id)
            const localVarPath = `/gameserver/{id}/shutdown`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Teleport a player to a location. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Teleport player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {TeleportPlayerInputDTO} [teleportPlayerInputDTO] TeleportPlayerInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerTeleportPlayer: async (gameServerId: string, playerId: string, teleportPlayerInputDTO?: TeleportPlayerInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('gameServerControllerTeleportPlayer', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('gameServerControllerTeleportPlayer', 'playerId', playerId)
            const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/teleport`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(teleportPlayerInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if Takaro can connect to a gameserver. Will do a thorough check and report details.
         * @summary Test reachability
         * @param {GameServerTestReachabilityInputDTO} [gameServerTestReachabilityInputDTO] GameServerTestReachabilityInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerTestReachability: async (gameServerTestReachabilityInputDTO?: GameServerTestReachabilityInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gameserver/reachability`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameServerTestReachabilityInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test if Takaro can connect to a gameserver. Will do a thorough check and report details.
         * @summary Test reachability for id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerTestReachabilityForId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerTestReachabilityForId', 'id', id)
            const localVarPath = `/gameserver/{id}/reachability`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unban a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Unban player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        gameServerControllerUnbanPlayer: async (gameServerId: string, playerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('gameServerControllerUnbanPlayer', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('gameServerControllerUnbanPlayer', 'playerId', playerId)
            const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/unban`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a gameserver   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Update
         * @param {string} id 
         * @param {GameServerUpdateDTO} [gameServerUpdateDTO] GameServerUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerUpdate: async (id: string, gameServerUpdateDTO?: GameServerUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('gameServerControllerUpdate', 'id', id)
            const localVarPath = `/gameserver/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(gameServerUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameServerApi - functional programming interface
 * @export
 */
export const GameServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameServerApiAxiosParamCreator(configuration)
    return {
        /**
         * Ban a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Ban player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {BanPlayerInputDTO} [banPlayerInputDTO] BanPlayerInputDTO
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async gameServerControllerBanPlayer(gameServerId: string, playerId: string, banPlayerInputDTO?: BanPlayerInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerBanPlayer(gameServerId, playerId, banPlayerInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerBanPlayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a gameserver   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Create
         * @param {GameServerCreateDTO} [gameServerCreateDTO] GameServerCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerCreate(gameServerCreateDTO?: GameServerCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerCreate(gameServerCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Execute a raw command on a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Execute command
         * @param {string} id 
         * @param {CommandExecuteInputDTO} [commandExecuteInputDTO] CommandExecuteInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerExecuteCommand(id: string, commandExecuteInputDTO?: CommandExecuteInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandExecuteDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerExecuteCommand(id, commandExecuteInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerExecuteCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch status of an import from CSMM   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Get import
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerGetImport(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportStatusOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetImport(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerGetImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a gameserver by id
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of players on a gameserver. Requires gameserver to be online and reachable.   Required permissions: `READ_PLAYERS`
         * @summary Get players
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerGetPlayers(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetPlayers(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerGetPlayers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch gameserver types (7dtd, Rust, ...)
         * @summary Get types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerGetTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerTypesOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerGetTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Give an item to a player. Requires gameserver to be online and reachable. Depending on the underlying game implementation, it\'s possible that the item is dropped on the ground instead of placed directly in the player\'s inventory.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Give item
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {GiveItemInputDTO} [giveItemInputDTO] GiveItemInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerGiveItem(gameServerId: string, playerId: string, giveItemInputDTO?: GiveItemInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGiveItem(gameServerId, playerId, giveItemInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerGiveItem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import a gameserver from CSMM.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Import from csmm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerImportFromCSMM(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerImportFromCSMM(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerImportFromCSMM']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Kick a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Kick player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {KickPlayerInputDTO} [kickPlayerInputDTO] KickPlayerInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerKickPlayer(gameServerId: string, playerId: string, kickPlayerInputDTO?: KickPlayerInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerKickPlayer(gameServerId, playerId, kickPlayerInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerKickPlayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List bans for a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary List bans
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async gameServerControllerListBans(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanPlayerOutputDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerListBans(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerListBans']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a gameserver   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch gameservers
         * @summary Search
         * @param {GameServerSearchInputDTO} [gameServerSearchInputDTO] GameServerSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerSearch(gameServerSearchInputDTO?: GameServerSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerSearch(gameServerSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a message in gameserver chat. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Send message
         * @param {string} id 
         * @param {MessageSendInputDTO} [messageSendInputDTO] MessageSendInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerSendMessage(id: string, messageSendInputDTO?: MessageSendInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerSendMessage(id, messageSendInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerSendMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Shuts down the gameserver. This is a \'soft\' shutdown, meaning the gameserver will be stopped gracefully. If the gameserver is not reachable, this will have no effect. Note that most hosting providers will automatically restart the gameserver after a shutdown, which makes this operation act as a \'restart\' instead.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Shutdown
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerShutdown(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerShutdown(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerShutdown']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Teleport a player to a location. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Teleport player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {TeleportPlayerInputDTO} [teleportPlayerInputDTO] TeleportPlayerInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerTeleportPlayer(gameServerId: string, playerId: string, teleportPlayerInputDTO?: TeleportPlayerInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerTeleportPlayer(gameServerId, playerId, teleportPlayerInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerTeleportPlayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test if Takaro can connect to a gameserver. Will do a thorough check and report details.
         * @summary Test reachability
         * @param {GameServerTestReachabilityInputDTO} [gameServerTestReachabilityInputDTO] GameServerTestReachabilityInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerTestReachability(gameServerTestReachabilityInputDTO?: GameServerTestReachabilityInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerTestReachabilityDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerTestReachability(gameServerTestReachabilityInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerTestReachability']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test if Takaro can connect to a gameserver. Will do a thorough check and report details.
         * @summary Test reachability for id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerTestReachabilityForId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerTestReachabilityDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerTestReachabilityForId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerTestReachabilityForId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unban a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Unban player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async gameServerControllerUnbanPlayer(gameServerId: string, playerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerUnbanPlayer(gameServerId, playerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerUnbanPlayer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a gameserver   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Update
         * @param {string} id 
         * @param {GameServerUpdateDTO} [gameServerUpdateDTO] GameServerUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameServerControllerUpdate(id: string, gameServerUpdateDTO?: GameServerUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerUpdate(id, gameServerUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GameServerApi.gameServerControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GameServerApi - factory interface
 * @export
 */
export const GameServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameServerApiFp(configuration)
    return {
        /**
         * Ban a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Ban player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {BanPlayerInputDTO} [banPlayerInputDTO] BanPlayerInputDTO
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        gameServerControllerBanPlayer(gameServerId: string, playerId: string, banPlayerInputDTO?: BanPlayerInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.gameServerControllerBanPlayer(gameServerId, playerId, banPlayerInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a gameserver   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Create
         * @param {GameServerCreateDTO} [gameServerCreateDTO] GameServerCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerCreate(gameServerCreateDTO?: GameServerCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameServerOutputDTOAPI> {
            return localVarFp.gameServerControllerCreate(gameServerCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a raw command on a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Execute command
         * @param {string} id 
         * @param {CommandExecuteInputDTO} [commandExecuteInputDTO] CommandExecuteInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerExecuteCommand(id: string, commandExecuteInputDTO?: CommandExecuteInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<CommandExecuteDTOAPI> {
            return localVarFp.gameServerControllerExecuteCommand(id, commandExecuteInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch status of an import from CSMM   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Get import
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGetImport(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ImportStatusOutputDTOAPI> {
            return localVarFp.gameServerControllerGetImport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a gameserver by id
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GameServerOutputDTOAPI> {
            return localVarFp.gameServerControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of players on a gameserver. Requires gameserver to be online and reachable.   Required permissions: `READ_PLAYERS`
         * @summary Get players
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGetPlayers(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
            return localVarFp.gameServerControllerGetPlayers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch gameserver types (7dtd, Rust, ...)
         * @summary Get types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGetTypes(options?: RawAxiosRequestConfig): AxiosPromise<GameServerTypesOutputDTOAPI> {
            return localVarFp.gameServerControllerGetTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Give an item to a player. Requires gameserver to be online and reachable. Depending on the underlying game implementation, it\'s possible that the item is dropped on the ground instead of placed directly in the player\'s inventory.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Give item
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {GiveItemInputDTO} [giveItemInputDTO] GiveItemInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerGiveItem(gameServerId: string, playerId: string, giveItemInputDTO?: GiveItemInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.gameServerControllerGiveItem(gameServerId, playerId, giveItemInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Import a gameserver from CSMM.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Import from csmm
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerImportFromCSMM(options?: RawAxiosRequestConfig): AxiosPromise<ImportOutputDTOAPI> {
            return localVarFp.gameServerControllerImportFromCSMM(options).then((request) => request(axios, basePath));
        },
        /**
         * Kick a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Kick player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {KickPlayerInputDTO} [kickPlayerInputDTO] KickPlayerInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerKickPlayer(gameServerId: string, playerId: string, kickPlayerInputDTO?: KickPlayerInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.gameServerControllerKickPlayer(gameServerId, playerId, kickPlayerInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * List bans for a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary List bans
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        gameServerControllerListBans(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BanPlayerOutputDTO> {
            return localVarFp.gameServerControllerListBans(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a gameserver   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.gameServerControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch gameservers
         * @summary Search
         * @param {GameServerSearchInputDTO} [gameServerSearchInputDTO] GameServerSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerSearch(gameServerSearchInputDTO?: GameServerSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameServerOutputArrayDTOAPI> {
            return localVarFp.gameServerControllerSearch(gameServerSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a message in gameserver chat. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Send message
         * @param {string} id 
         * @param {MessageSendInputDTO} [messageSendInputDTO] MessageSendInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerSendMessage(id: string, messageSendInputDTO?: MessageSendInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.gameServerControllerSendMessage(id, messageSendInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Shuts down the gameserver. This is a \'soft\' shutdown, meaning the gameserver will be stopped gracefully. If the gameserver is not reachable, this will have no effect. Note that most hosting providers will automatically restart the gameserver after a shutdown, which makes this operation act as a \'restart\' instead.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Shutdown
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerShutdown(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.gameServerControllerShutdown(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Teleport a player to a location. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Teleport player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {TeleportPlayerInputDTO} [teleportPlayerInputDTO] TeleportPlayerInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerTeleportPlayer(gameServerId: string, playerId: string, teleportPlayerInputDTO?: TeleportPlayerInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.gameServerControllerTeleportPlayer(gameServerId, playerId, teleportPlayerInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Test if Takaro can connect to a gameserver. Will do a thorough check and report details.
         * @summary Test reachability
         * @param {GameServerTestReachabilityInputDTO} [gameServerTestReachabilityInputDTO] GameServerTestReachabilityInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerTestReachability(gameServerTestReachabilityInputDTO?: GameServerTestReachabilityInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameServerTestReachabilityDTOAPI> {
            return localVarFp.gameServerControllerTestReachability(gameServerTestReachabilityInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Test if Takaro can connect to a gameserver. Will do a thorough check and report details.
         * @summary Test reachability for id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerTestReachabilityForId(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GameServerTestReachabilityDTOAPI> {
            return localVarFp.gameServerControllerTestReachabilityForId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unban a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Unban player
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        gameServerControllerUnbanPlayer(gameServerId: string, playerId: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.gameServerControllerUnbanPlayer(gameServerId, playerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a gameserver   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Update
         * @param {string} id 
         * @param {GameServerUpdateDTO} [gameServerUpdateDTO] GameServerUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameServerControllerUpdate(id: string, gameServerUpdateDTO?: GameServerUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<GameServerOutputDTOAPI> {
            return localVarFp.gameServerControllerUpdate(id, gameServerUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameServerApi - object-oriented interface
 * @export
 * @class GameServerApi
 * @extends {BaseAPI}
 */
export class GameServerApi extends BaseAPI {
    /**
     * Ban a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Ban player
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {BanPlayerInputDTO} [banPlayerInputDTO] BanPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerBanPlayer(gameServerId: string, playerId: string, banPlayerInputDTO?: BanPlayerInputDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerBanPlayer(gameServerId, playerId, banPlayerInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a gameserver   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Create
     * @param {GameServerCreateDTO} [gameServerCreateDTO] GameServerCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerCreate(gameServerCreateDTO?: GameServerCreateDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerCreate(gameServerCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a raw command on a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Execute command
     * @param {string} id 
     * @param {CommandExecuteInputDTO} [commandExecuteInputDTO] CommandExecuteInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerExecuteCommand(id: string, commandExecuteInputDTO?: CommandExecuteInputDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerExecuteCommand(id, commandExecuteInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch status of an import from CSMM   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Get import
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerGetImport(id: string, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerGetImport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a gameserver by id
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of players on a gameserver. Requires gameserver to be online and reachable.   Required permissions: `READ_PLAYERS`
     * @summary Get players
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerGetPlayers(id: string, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerGetPlayers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch gameserver types (7dtd, Rust, ...)
     * @summary Get types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerGetTypes(options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerGetTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Give an item to a player. Requires gameserver to be online and reachable. Depending on the underlying game implementation, it\'s possible that the item is dropped on the ground instead of placed directly in the player\'s inventory.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Give item
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {GiveItemInputDTO} [giveItemInputDTO] GiveItemInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerGiveItem(gameServerId: string, playerId: string, giveItemInputDTO?: GiveItemInputDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerGiveItem(gameServerId, playerId, giveItemInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import a gameserver from CSMM.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Import from csmm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerImportFromCSMM(options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerImportFromCSMM(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Kick a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Kick player
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {KickPlayerInputDTO} [kickPlayerInputDTO] KickPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerKickPlayer(gameServerId: string, playerId: string, kickPlayerInputDTO?: KickPlayerInputDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerKickPlayer(gameServerId, playerId, kickPlayerInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List bans for a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary List bans
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerListBans(id: string, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerListBans(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a gameserver   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Remove
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch gameservers
     * @summary Search
     * @param {GameServerSearchInputDTO} [gameServerSearchInputDTO] GameServerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerSearch(gameServerSearchInputDTO?: GameServerSearchInputDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerSearch(gameServerSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a message in gameserver chat. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Send message
     * @param {string} id 
     * @param {MessageSendInputDTO} [messageSendInputDTO] MessageSendInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerSendMessage(id: string, messageSendInputDTO?: MessageSendInputDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerSendMessage(id, messageSendInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Shuts down the gameserver. This is a \'soft\' shutdown, meaning the gameserver will be stopped gracefully. If the gameserver is not reachable, this will have no effect. Note that most hosting providers will automatically restart the gameserver after a shutdown, which makes this operation act as a \'restart\' instead.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Shutdown
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerShutdown(id: string, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerShutdown(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Teleport a player to a location. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Teleport player
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {TeleportPlayerInputDTO} [teleportPlayerInputDTO] TeleportPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerTeleportPlayer(gameServerId: string, playerId: string, teleportPlayerInputDTO?: TeleportPlayerInputDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerTeleportPlayer(gameServerId, playerId, teleportPlayerInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test if Takaro can connect to a gameserver. Will do a thorough check and report details.
     * @summary Test reachability
     * @param {GameServerTestReachabilityInputDTO} [gameServerTestReachabilityInputDTO] GameServerTestReachabilityInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerTestReachability(gameServerTestReachabilityInputDTO?: GameServerTestReachabilityInputDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerTestReachability(gameServerTestReachabilityInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test if Takaro can connect to a gameserver. Will do a thorough check and report details.
     * @summary Test reachability for id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerTestReachabilityForId(id: string, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerTestReachabilityForId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unban a player from a gameserver. Requires gameserver to be online and reachable.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Unban player
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerUnbanPlayer(gameServerId: string, playerId: string, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerUnbanPlayer(gameServerId, playerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a gameserver   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Update
     * @param {string} id 
     * @param {GameServerUpdateDTO} [gameServerUpdateDTO] GameServerUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameServerApi
     */
    public gameServerControllerUpdate(id: string, gameServerUpdateDTO?: GameServerUpdateDTO, options?: RawAxiosRequestConfig) {
        return GameServerApiFp(this.configuration).gameServerControllerUpdate(id, gameServerUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HookApi - axios parameter creator
 * @export
 */
export const HookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {HookCreateDTO} [hookCreateDTO] HookCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerCreate: async (hookCreateDTO?: HookCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hookCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get executions
         * @param {string} id 
         * @param {any} [success] 
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerGetExecutions: async (id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hookControllerGetExecutions', 'id', id)
            const localVarPath = `/hook/{id}/executions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (success !== undefined) {
                for (const [key, value] of Object.entries(success)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hookControllerGetOne', 'id', id)
            const localVarPath = `/hook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hookControllerRemove', 'id', id)
            const localVarPath = `/hook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {HookSearchInputDTO} [hookSearchInputDTO] HookSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerSearch: async (hookSearchInputDTO?: HookSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hook/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hookSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a hook. This is used for testing purposes, the event will not actually be created but the hook-logic will be executed.      You can pass any data you want, but it must validate against the corresponding event metadata. Eg to trigger the `chat-message` event, you must pass an object with a `message` property   Required permissions: `MANAGE_MODULES`
         * @summary Trigger
         * @param {HookTriggerDTO} [hookTriggerDTO] HookTriggerDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerTrigger: async (hookTriggerDTO?: HookTriggerDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hook/trigger`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hookTriggerDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {HookUpdateDTO} [hookUpdateDTO] HookUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerUpdate: async (id: string, hookUpdateDTO?: HookUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('hookControllerUpdate', 'id', id)
            const localVarPath = `/hook/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(hookUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HookApi - functional programming interface
 * @export
 */
export const HookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HookApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {HookCreateDTO} [hookCreateDTO] HookCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookControllerCreate(hookCreateDTO?: HookCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerCreate(hookCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HookApi.hookControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get executions
         * @param {string} id 
         * @param {any} [success] 
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookControllerGetExecutions(id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerGetExecutions(id, success, eventSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HookApi.hookControllerGetExecutions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HookApi.hookControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HookApi.hookControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {HookSearchInputDTO} [hookSearchInputDTO] HookSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookControllerSearch(hookSearchInputDTO?: HookSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerSearch(hookSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HookApi.hookControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a hook. This is used for testing purposes, the event will not actually be created but the hook-logic will be executed.      You can pass any data you want, but it must validate against the corresponding event metadata. Eg to trigger the `chat-message` event, you must pass an object with a `message` property   Required permissions: `MANAGE_MODULES`
         * @summary Trigger
         * @param {HookTriggerDTO} [hookTriggerDTO] HookTriggerDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookControllerTrigger(hookTriggerDTO?: HookTriggerDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerTrigger(hookTriggerDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HookApi.hookControllerTrigger']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {HookUpdateDTO} [hookUpdateDTO] HookUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hookControllerUpdate(id: string, hookUpdateDTO?: HookUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerUpdate(id, hookUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HookApi.hookControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HookApi - factory interface
 * @export
 */
export const HookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HookApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Create
         * @param {HookCreateDTO} [hookCreateDTO] HookCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerCreate(hookCreateDTO?: HookCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<HookOutputDTOAPI> {
            return localVarFp.hookControllerCreate(hookCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get executions
         * @param {string} id 
         * @param {any} [success] 
         * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerGetExecutions(id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<EventOutputArrayDTOAPI> {
            return localVarFp.hookControllerGetExecutions(id, success, eventSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<HookOutputDTOAPI> {
            return localVarFp.hookControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.hookControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search
         * @param {HookSearchInputDTO} [hookSearchInputDTO] HookSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerSearch(hookSearchInputDTO?: HookSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<HookOutputArrayDTOAPI> {
            return localVarFp.hookControllerSearch(hookSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a hook. This is used for testing purposes, the event will not actually be created but the hook-logic will be executed.      You can pass any data you want, but it must validate against the corresponding event metadata. Eg to trigger the `chat-message` event, you must pass an object with a `message` property   Required permissions: `MANAGE_MODULES`
         * @summary Trigger
         * @param {HookTriggerDTO} [hookTriggerDTO] HookTriggerDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerTrigger(hookTriggerDTO?: HookTriggerDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.hookControllerTrigger(hookTriggerDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_MODULES`
         * @summary Update
         * @param {string} id 
         * @param {HookUpdateDTO} [hookUpdateDTO] HookUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hookControllerUpdate(id: string, hookUpdateDTO?: HookUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<HookOutputDTOAPI> {
            return localVarFp.hookControllerUpdate(id, hookUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HookApi - object-oriented interface
 * @export
 * @class HookApi
 * @extends {BaseAPI}
 */
export class HookApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {HookCreateDTO} [hookCreateDTO] HookCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HookApi
     */
    public hookControllerCreate(hookCreateDTO?: HookCreateDTO, options?: RawAxiosRequestConfig) {
        return HookApiFp(this.configuration).hookControllerCreate(hookCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get executions
     * @param {string} id 
     * @param {any} [success] 
     * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HookApi
     */
    public hookControllerGetExecutions(id: string, success?: any, eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig) {
        return HookApiFp(this.configuration).hookControllerGetExecutions(id, success, eventSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HookApi
     */
    public hookControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return HookApiFp(this.configuration).hookControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HookApi
     */
    public hookControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return HookApiFp(this.configuration).hookControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Search
     * @param {HookSearchInputDTO} [hookSearchInputDTO] HookSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HookApi
     */
    public hookControllerSearch(hookSearchInputDTO?: HookSearchInputDTO, options?: RawAxiosRequestConfig) {
        return HookApiFp(this.configuration).hookControllerSearch(hookSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger a hook. This is used for testing purposes, the event will not actually be created but the hook-logic will be executed.      You can pass any data you want, but it must validate against the corresponding event metadata. Eg to trigger the `chat-message` event, you must pass an object with a `message` property   Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {HookTriggerDTO} [hookTriggerDTO] HookTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HookApi
     */
    public hookControllerTrigger(hookTriggerDTO?: HookTriggerDTO, options?: RawAxiosRequestConfig) {
        return HookApiFp(this.configuration).hookControllerTrigger(hookTriggerDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id 
     * @param {HookUpdateDTO} [hookUpdateDTO] HookUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HookApi
     */
    public hookControllerUpdate(id: string, hookUpdateDTO?: HookUpdateDTO, options?: RawAxiosRequestConfig) {
        return HookApiFp(this.configuration).hookControllerUpdate(id, hookUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `READ_ITEMS`
         * @summary Find one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('itemControllerFindOne', 'id', id)
            const localVarPath = `/items/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_ITEMS`
         * @summary Search
         * @param {ItemSearchInputDTO} [itemSearchInputDTO] ItemSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerSearch: async (itemSearchInputDTO?: ItemSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/items/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `READ_ITEMS`
         * @summary Find one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_ITEMS`
         * @summary Search
         * @param {ItemSearchInputDTO} [itemSearchInputDTO] ItemSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemControllerSearch(itemSearchInputDTO?: ItemSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerSearch(itemSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.itemControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         *    Required permissions: `READ_ITEMS`
         * @summary Find one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemOutputDTOAPI> {
            return localVarFp.itemControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_ITEMS`
         * @summary Search
         * @param {ItemSearchInputDTO} [itemSearchInputDTO] ItemSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemControllerSearch(itemSearchInputDTO?: ItemSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<ItemOutputArrayDTOAPI> {
            return localVarFp.itemControllerSearch(itemSearchInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     *    Required permissions: `READ_ITEMS`
     * @summary Find one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_ITEMS`
     * @summary Search
     * @param {ItemSearchInputDTO} [itemSearchInputDTO] ItemSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public itemControllerSearch(itemSearchInputDTO?: ItemSearchInputDTO, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).itemControllerSearch(itemSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetaApi - axios parameter creator
 * @export
 */
export const MetaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get open api
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetOpenApi: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/openapi.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get open api html
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetOpenApiHtml: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api.html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetReadiness: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/readyz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetaApi - functional programming interface
 * @export
 */
export const MetaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetaApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaGetHealth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthOutputDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetHealth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.metaGetHealth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaGetMetrics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetMetrics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.metaGetMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get open api
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaGetOpenApi(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetOpenApi(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.metaGetOpenApi']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get open api html
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaGetOpenApiHtml(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetOpenApiHtml(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.metaGetOpenApiHtml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metaGetReadiness(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthOutputDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetReadiness(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetaApi.metaGetReadiness']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetaApi - factory interface
 * @export
 */
export const MetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetaApiFp(configuration)
    return {
        /**
         * 
         * @summary Get health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetHealth(options?: RawAxiosRequestConfig): AxiosPromise<HealthOutputDTO> {
            return localVarFp.metaGetHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get metrics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetMetrics(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metaGetMetrics(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get open api
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetOpenApi(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metaGetOpenApi(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get open api html
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetOpenApiHtml(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.metaGetOpenApiHtml(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get readiness
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metaGetReadiness(options?: RawAxiosRequestConfig): AxiosPromise<HealthOutputDTO> {
            return localVarFp.metaGetReadiness(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetaApi - object-oriented interface
 * @export
 * @class MetaApi
 * @extends {BaseAPI}
 */
export class MetaApi extends BaseAPI {
    /**
     * 
     * @summary Get health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaGetHealth(options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaGetHealth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaGetMetrics(options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaGetMetrics(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get open api
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaGetOpenApi(options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaGetOpenApi(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get open api html
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaGetOpenApiHtml(options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaGetOpenApiHtml(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get readiness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetaApi
     */
    public metaGetReadiness(options?: RawAxiosRequestConfig) {
        return MetaApiFp(this.configuration).metaGetReadiness(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ModuleApi - axios parameter creator
 * @export
 */
export const ModuleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new module   Required permissions: `MANAGE_MODULES`
         * @summary Create module
         * @param {ModuleCreateAPIDTO} [moduleCreateAPIDTO] ModuleCreateAPIDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerCreate: async (moduleCreateAPIDTO?: ModuleCreateAPIDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/module`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleCreateAPIDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports a module to a format that can be imported into another Takaro instance. This endpoint will export all known versions of the module   Required permissions: `READ_MODULES`
         * @summary Export a module
         * @param {string} id 
         * @param {ModuleExportOptionsDTO} [moduleExportOptionsDTO] ModuleExportOptionsDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerExport: async (id: string, moduleExportOptionsDTO?: ModuleExportOptionsDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moduleControllerExport', 'id', id)
            const localVarPath = `/module/{id}/export`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleExportOptionsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one module
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moduleControllerGetOne', 'id', id)
            const localVarPath = `/module/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports a module from a format that was exported from another Takaro instance   Required permissions: `MANAGE_MODULES`
         * @summary Import a module
         * @param {ModuleTransferDTO} [moduleTransferDTO] ModuleTransferDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerImport: async (moduleTransferDTO?: ModuleTransferDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/module/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleTransferDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a module, including all versions and config   Required permissions: `MANAGE_MODULES`
         * @summary Remove a module
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moduleControllerRemove', 'id', id)
            const localVarPath = `/module/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search modules
         * @param {ModuleSearchInputDTO} [moduleSearchInputDTO] ModuleSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerSearch: async (moduleSearchInputDTO?: ModuleSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/module/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a module   Required permissions: `MANAGE_MODULES`
         * @summary Update a module
         * @param {string} id 
         * @param {ModuleUpdateDTO} [moduleUpdateDTO] ModuleUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerUpdate: async (id: string, moduleUpdateDTO?: ModuleUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moduleControllerUpdate', 'id', id)
            const localVarPath = `/module/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search module installations
         * @param {ModuleInstallationSearchInputDTO} [moduleInstallationSearchInputDTO] ModuleInstallationSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleInstallationsControllerGetInstalledModules: async (moduleInstallationSearchInputDTO?: ModuleInstallationSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/module/installation/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleInstallationSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one installation
         * @param {string} moduleId 
         * @param {string} gameServerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleInstallationsControllerGetModuleInstallation: async (moduleId: string, gameServerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('moduleInstallationsControllerGetModuleInstallation', 'moduleId', moduleId)
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('moduleInstallationsControllerGetModuleInstallation', 'gameServerId', gameServerId)
            const localVarPath = `/module/{moduleId}/gameserver/{gameServerId}/installation`
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Install a module on a gameserver. You can have multiple installations of the same module on the same gameserver.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Install module
         * @param {InstallModuleDTO} [installModuleDTO] InstallModuleDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleInstallationsControllerInstallModule: async (installModuleDTO?: InstallModuleDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/module/installation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(installModuleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uninstall a module from a gameserver. This will not delete the module from the database.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Uninstall module
         * @param {string} moduleId 
         * @param {string} gameServerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleInstallationsControllerUninstallModule: async (moduleId: string, gameServerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('moduleInstallationsControllerUninstallModule', 'moduleId', moduleId)
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('moduleInstallationsControllerUninstallModule', 'gameServerId', gameServerId)
            const localVarPath = `/module/{moduleId}/gameserver/{gameServerId}/installation`
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one version
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersionControllerGetModuleVersion: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moduleVersionControllerGetModuleVersion', 'id', id)
            const localVarPath = `/module/version/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search module versions
         * @param {ModuleVersionSearchInputDTO} [moduleVersionSearchInputDTO] ModuleVersionSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersionControllerSearchVersions: async (moduleVersionSearchInputDTO?: ModuleVersionSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/module/version/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleVersionSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new version of a module, copying all config (commands,hooks,cronjobs,...) from the \"latest\" version into a new, immutable version   Required permissions: `MANAGE_MODULES`
         * @summary Tag a new version
         * @param {ModuleVersionCreateAPIDTO} [moduleVersionCreateAPIDTO] ModuleVersionCreateAPIDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersionControllerTagVersion: async (moduleVersionCreateAPIDTO?: ModuleVersionCreateAPIDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/module/version/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleVersionCreateAPIDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModuleApi - functional programming interface
 * @export
 */
export const ModuleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModuleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new module   Required permissions: `MANAGE_MODULES`
         * @summary Create module
         * @param {ModuleCreateAPIDTO} [moduleCreateAPIDTO] ModuleCreateAPIDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleControllerCreate(moduleCreateAPIDTO?: ModuleCreateAPIDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerCreate(moduleCreateAPIDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exports a module to a format that can be imported into another Takaro instance. This endpoint will export all known versions of the module   Required permissions: `READ_MODULES`
         * @summary Export a module
         * @param {string} id 
         * @param {ModuleExportOptionsDTO} [moduleExportOptionsDTO] ModuleExportOptionsDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleControllerExport(id: string, moduleExportOptionsDTO?: ModuleExportOptionsDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleExportDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerExport(id, moduleExportOptionsDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleControllerExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one module
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Imports a module from a format that was exported from another Takaro instance   Required permissions: `MANAGE_MODULES`
         * @summary Import a module
         * @param {ModuleTransferDTO} [moduleTransferDTO] ModuleTransferDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleControllerImport(moduleTransferDTO?: ModuleTransferDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerImport(moduleTransferDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleControllerImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a module, including all versions and config   Required permissions: `MANAGE_MODULES`
         * @summary Remove a module
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search modules
         * @param {ModuleSearchInputDTO} [moduleSearchInputDTO] ModuleSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleControllerSearch(moduleSearchInputDTO?: ModuleSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerSearch(moduleSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a module   Required permissions: `MANAGE_MODULES`
         * @summary Update a module
         * @param {string} id 
         * @param {ModuleUpdateDTO} [moduleUpdateDTO] ModuleUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleControllerUpdate(id: string, moduleUpdateDTO?: ModuleUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerUpdate(id, moduleUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search module installations
         * @param {ModuleInstallationSearchInputDTO} [moduleInstallationSearchInputDTO] ModuleInstallationSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleInstallationsControllerGetInstalledModules(moduleInstallationSearchInputDTO?: ModuleInstallationSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleInstallationOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleInstallationsControllerGetInstalledModules(moduleInstallationSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleInstallationsControllerGetInstalledModules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one installation
         * @param {string} moduleId 
         * @param {string} gameServerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleInstallationsControllerGetModuleInstallation(moduleId: string, gameServerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleInstallationOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleInstallationsControllerGetModuleInstallation(moduleId, gameServerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleInstallationsControllerGetModuleInstallation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Install a module on a gameserver. You can have multiple installations of the same module on the same gameserver.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Install module
         * @param {InstallModuleDTO} [installModuleDTO] InstallModuleDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleInstallationsControllerInstallModule(installModuleDTO?: InstallModuleDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleInstallationOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleInstallationsControllerInstallModule(installModuleDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleInstallationsControllerInstallModule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uninstall a module from a gameserver. This will not delete the module from the database.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Uninstall module
         * @param {string} moduleId 
         * @param {string} gameServerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleInstallationsControllerUninstallModule(moduleId: string, gameServerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleInstallationOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleInstallationsControllerUninstallModule(moduleId, gameServerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleInstallationsControllerUninstallModule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one version
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleVersionControllerGetModuleVersion(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleVersionOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleVersionControllerGetModuleVersion(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleVersionControllerGetModuleVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search module versions
         * @param {ModuleVersionSearchInputDTO} [moduleVersionSearchInputDTO] ModuleVersionSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleVersionControllerSearchVersions(moduleVersionSearchInputDTO?: ModuleVersionSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleVersionOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleVersionControllerSearchVersions(moduleVersionSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleVersionControllerSearchVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new version of a module, copying all config (commands,hooks,cronjobs,...) from the \"latest\" version into a new, immutable version   Required permissions: `MANAGE_MODULES`
         * @summary Tag a new version
         * @param {ModuleVersionCreateAPIDTO} [moduleVersionCreateAPIDTO] ModuleVersionCreateAPIDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moduleVersionControllerTagVersion(moduleVersionCreateAPIDTO?: ModuleVersionCreateAPIDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleVersionOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moduleVersionControllerTagVersion(moduleVersionCreateAPIDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ModuleApi.moduleVersionControllerTagVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ModuleApi - factory interface
 * @export
 */
export const ModuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModuleApiFp(configuration)
    return {
        /**
         * Create a new module   Required permissions: `MANAGE_MODULES`
         * @summary Create module
         * @param {ModuleCreateAPIDTO} [moduleCreateAPIDTO] ModuleCreateAPIDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerCreate(moduleCreateAPIDTO?: ModuleCreateAPIDTO, options?: RawAxiosRequestConfig): AxiosPromise<ModuleOutputDTOAPI> {
            return localVarFp.moduleControllerCreate(moduleCreateAPIDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports a module to a format that can be imported into another Takaro instance. This endpoint will export all known versions of the module   Required permissions: `READ_MODULES`
         * @summary Export a module
         * @param {string} id 
         * @param {ModuleExportOptionsDTO} [moduleExportOptionsDTO] ModuleExportOptionsDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerExport(id: string, moduleExportOptionsDTO?: ModuleExportOptionsDTO, options?: RawAxiosRequestConfig): AxiosPromise<ModuleExportDTOAPI> {
            return localVarFp.moduleControllerExport(id, moduleExportOptionsDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one module
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ModuleOutputDTOAPI> {
            return localVarFp.moduleControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports a module from a format that was exported from another Takaro instance   Required permissions: `MANAGE_MODULES`
         * @summary Import a module
         * @param {ModuleTransferDTO} [moduleTransferDTO] ModuleTransferDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerImport(moduleTransferDTO?: ModuleTransferDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.moduleControllerImport(moduleTransferDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a module, including all versions and config   Required permissions: `MANAGE_MODULES`
         * @summary Remove a module
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.moduleControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search modules
         * @param {ModuleSearchInputDTO} [moduleSearchInputDTO] ModuleSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerSearch(moduleSearchInputDTO?: ModuleSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<ModuleOutputArrayDTOAPI> {
            return localVarFp.moduleControllerSearch(moduleSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a module   Required permissions: `MANAGE_MODULES`
         * @summary Update a module
         * @param {string} id 
         * @param {ModuleUpdateDTO} [moduleUpdateDTO] ModuleUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleControllerUpdate(id: string, moduleUpdateDTO?: ModuleUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<ModuleOutputDTOAPI> {
            return localVarFp.moduleControllerUpdate(id, moduleUpdateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search module installations
         * @param {ModuleInstallationSearchInputDTO} [moduleInstallationSearchInputDTO] ModuleInstallationSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleInstallationsControllerGetInstalledModules(moduleInstallationSearchInputDTO?: ModuleInstallationSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<ModuleInstallationOutputArrayDTOAPI> {
            return localVarFp.moduleInstallationsControllerGetInstalledModules(moduleInstallationSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one installation
         * @param {string} moduleId 
         * @param {string} gameServerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleInstallationsControllerGetModuleInstallation(moduleId: string, gameServerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ModuleInstallationOutputDTOAPI> {
            return localVarFp.moduleInstallationsControllerGetModuleInstallation(moduleId, gameServerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Install a module on a gameserver. You can have multiple installations of the same module on the same gameserver.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Install module
         * @param {InstallModuleDTO} [installModuleDTO] InstallModuleDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleInstallationsControllerInstallModule(installModuleDTO?: InstallModuleDTO, options?: RawAxiosRequestConfig): AxiosPromise<ModuleInstallationOutputDTOAPI> {
            return localVarFp.moduleInstallationsControllerInstallModule(installModuleDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Uninstall a module from a gameserver. This will not delete the module from the database.   Required permissions: `MANAGE_GAMESERVERS`
         * @summary Uninstall module
         * @param {string} moduleId 
         * @param {string} gameServerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleInstallationsControllerUninstallModule(moduleId: string, gameServerId: string, options?: RawAxiosRequestConfig): AxiosPromise<ModuleInstallationOutputDTOAPI> {
            return localVarFp.moduleInstallationsControllerUninstallModule(moduleId, gameServerId, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Get one version
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersionControllerGetModuleVersion(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ModuleVersionOutputDTOAPI> {
            return localVarFp.moduleVersionControllerGetModuleVersion(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_MODULES`
         * @summary Search module versions
         * @param {ModuleVersionSearchInputDTO} [moduleVersionSearchInputDTO] ModuleVersionSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersionControllerSearchVersions(moduleVersionSearchInputDTO?: ModuleVersionSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<ModuleVersionOutputArrayDTOAPI> {
            return localVarFp.moduleVersionControllerSearchVersions(moduleVersionSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new version of a module, copying all config (commands,hooks,cronjobs,...) from the \"latest\" version into a new, immutable version   Required permissions: `MANAGE_MODULES`
         * @summary Tag a new version
         * @param {ModuleVersionCreateAPIDTO} [moduleVersionCreateAPIDTO] ModuleVersionCreateAPIDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moduleVersionControllerTagVersion(moduleVersionCreateAPIDTO?: ModuleVersionCreateAPIDTO, options?: RawAxiosRequestConfig): AxiosPromise<ModuleVersionOutputDTOAPI> {
            return localVarFp.moduleVersionControllerTagVersion(moduleVersionCreateAPIDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModuleApi - object-oriented interface
 * @export
 * @class ModuleApi
 * @extends {BaseAPI}
 */
export class ModuleApi extends BaseAPI {
    /**
     * Create a new module   Required permissions: `MANAGE_MODULES`
     * @summary Create module
     * @param {ModuleCreateAPIDTO} [moduleCreateAPIDTO] ModuleCreateAPIDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleControllerCreate(moduleCreateAPIDTO?: ModuleCreateAPIDTO, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleControllerCreate(moduleCreateAPIDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports a module to a format that can be imported into another Takaro instance. This endpoint will export all known versions of the module   Required permissions: `READ_MODULES`
     * @summary Export a module
     * @param {string} id 
     * @param {ModuleExportOptionsDTO} [moduleExportOptionsDTO] ModuleExportOptionsDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleControllerExport(id: string, moduleExportOptionsDTO?: ModuleExportOptionsDTO, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleControllerExport(id, moduleExportOptionsDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get one module
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports a module from a format that was exported from another Takaro instance   Required permissions: `MANAGE_MODULES`
     * @summary Import a module
     * @param {ModuleTransferDTO} [moduleTransferDTO] ModuleTransferDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleControllerImport(moduleTransferDTO?: ModuleTransferDTO, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleControllerImport(moduleTransferDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a module, including all versions and config   Required permissions: `MANAGE_MODULES`
     * @summary Remove a module
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Search modules
     * @param {ModuleSearchInputDTO} [moduleSearchInputDTO] ModuleSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleControllerSearch(moduleSearchInputDTO?: ModuleSearchInputDTO, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleControllerSearch(moduleSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a module   Required permissions: `MANAGE_MODULES`
     * @summary Update a module
     * @param {string} id 
     * @param {ModuleUpdateDTO} [moduleUpdateDTO] ModuleUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleControllerUpdate(id: string, moduleUpdateDTO?: ModuleUpdateDTO, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleControllerUpdate(id, moduleUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Search module installations
     * @param {ModuleInstallationSearchInputDTO} [moduleInstallationSearchInputDTO] ModuleInstallationSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleInstallationsControllerGetInstalledModules(moduleInstallationSearchInputDTO?: ModuleInstallationSearchInputDTO, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleInstallationsControllerGetInstalledModules(moduleInstallationSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get one installation
     * @param {string} moduleId 
     * @param {string} gameServerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleInstallationsControllerGetModuleInstallation(moduleId: string, gameServerId: string, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleInstallationsControllerGetModuleInstallation(moduleId, gameServerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Install a module on a gameserver. You can have multiple installations of the same module on the same gameserver.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Install module
     * @param {InstallModuleDTO} [installModuleDTO] InstallModuleDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleInstallationsControllerInstallModule(installModuleDTO?: InstallModuleDTO, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleInstallationsControllerInstallModule(installModuleDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uninstall a module from a gameserver. This will not delete the module from the database.   Required permissions: `MANAGE_GAMESERVERS`
     * @summary Uninstall module
     * @param {string} moduleId 
     * @param {string} gameServerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleInstallationsControllerUninstallModule(moduleId: string, gameServerId: string, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleInstallationsControllerUninstallModule(moduleId, gameServerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Get one version
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleVersionControllerGetModuleVersion(id: string, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleVersionControllerGetModuleVersion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_MODULES`
     * @summary Search module versions
     * @param {ModuleVersionSearchInputDTO} [moduleVersionSearchInputDTO] ModuleVersionSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleVersionControllerSearchVersions(moduleVersionSearchInputDTO?: ModuleVersionSearchInputDTO, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleVersionControllerSearchVersions(moduleVersionSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new version of a module, copying all config (commands,hooks,cronjobs,...) from the \"latest\" version into a new, immutable version   Required permissions: `MANAGE_MODULES`
     * @summary Tag a new version
     * @param {ModuleVersionCreateAPIDTO} [moduleVersionCreateAPIDTO] ModuleVersionCreateAPIDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public moduleVersionControllerTagVersion(moduleVersionCreateAPIDTO?: ModuleVersionCreateAPIDTO, options?: RawAxiosRequestConfig) {
        return ModuleApiFp(this.configuration).moduleVersionControllerTagVersion(moduleVersionCreateAPIDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlayerApi - axios parameter creator
 * @export
 */
export const PlayerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new ban, creating a ban via the API will always make it takaro managed.   Required permissions: `MANAGE_PLAYERS`
         * @summary Ban player
         * @param {BanCreateDTO} [banCreateDTO] BanCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerCreate: async (banCreateDTO?: BanCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/ban`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unban player. This will remove the ban from Takaro and the gameserver(s)   Required permissions: `MANAGE_PLAYERS`
         * @summary Unban player
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('banControllerDelete', 'id', id)
            const localVarPath = `/player/ban/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single ban   Required permissions: `READ_PLAYERS`
         * @summary Get a single ban
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('banControllerGetOne', 'id', id)
            const localVarPath = `/player/ban/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for bans   Required permissions: `READ_PLAYERS`
         * @summary Search for bans
         * @param {BanSearchInputDTO} [banSearchInputDTO] BanSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerSearch: async (banSearchInputDTO?: BanSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/ban/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing ban, updating a ban via the API will always make it takaro managed.   Required permissions: `MANAGE_PLAYERS`
         * @summary Update ban
         * @param {string} id 
         * @param {BanUpdateDTO} [banUpdateDTO] BanUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerUpdate: async (id: string, banUpdateDTO?: BanUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('banControllerUpdate', 'id', id)
            const localVarPath = `/player/ban/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(banUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
         * @summary Assign role
         * @param {string} id 
         * @param {string} roleId 
         * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerAssignRole: async (id: string, roleId: string, playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playerControllerAssignRole', 'id', id)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('playerControllerAssignRole', 'roleId', roleId)
            const localVarPath = `/player/{id}/role/{roleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerRoleAssignChangeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the player that is currently authenticated. This is a low-privilege route, returning limited data.
         * @summary Get current player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerGetMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playerControllerGetOne', 'id', id)
            const localVarPath = `/player/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
         * @summary Remove role
         * @param {string} id 
         * @param {string} roleId 
         * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerRemoveRole: async (id: string, roleId: string, playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('playerControllerRemoveRole', 'id', id)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('playerControllerRemoveRole', 'roleId', roleId)
            const localVarPath = `/player/{id}/role/{roleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerRoleAssignChangeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Search
         * @param {PlayerSearchInputDTO} [playerSearchInputDTO] PlayerSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerSearch: async (playerSearchInputDTO?: PlayerSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerApi - functional programming interface
 * @export
 */
export const PlayerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayerApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new ban, creating a ban via the API will always make it takaro managed.   Required permissions: `MANAGE_PLAYERS`
         * @summary Ban player
         * @param {BanCreateDTO} [banCreateDTO] BanCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banControllerCreate(banCreateDTO?: BanCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banControllerCreate(banCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.banControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unban player. This will remove the ban from Takaro and the gameserver(s)   Required permissions: `MANAGE_PLAYERS`
         * @summary Unban player
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.banControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single ban   Required permissions: `READ_PLAYERS`
         * @summary Get a single ban
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.banControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for bans   Required permissions: `READ_PLAYERS`
         * @summary Search for bans
         * @param {BanSearchInputDTO} [banSearchInputDTO] BanSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banControllerSearch(banSearchInputDTO?: BanSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banControllerSearch(banSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.banControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing ban, updating a ban via the API will always make it takaro managed.   Required permissions: `MANAGE_PLAYERS`
         * @summary Update ban
         * @param {string} id 
         * @param {BanUpdateDTO} [banUpdateDTO] BanUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banControllerUpdate(id: string, banUpdateDTO?: BanUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banControllerUpdate(id, banUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.banControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
         * @summary Assign role
         * @param {string} id 
         * @param {string} roleId 
         * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerControllerAssignRole(id: string, roleId: string, playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerControllerAssignRole(id, roleId, playerRoleAssignChangeDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerControllerAssignRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the player that is currently authenticated. This is a low-privilege route, returning limited data.
         * @summary Get current player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerControllerGetMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerMeOutputDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerControllerGetMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerControllerGetMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOutputWithRolesDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
         * @summary Remove role
         * @param {string} id 
         * @param {string} roleId 
         * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerControllerRemoveRole(id: string, roleId: string, playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerControllerRemoveRole(id, roleId, playerRoleAssignChangeDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerControllerRemoveRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Search
         * @param {PlayerSearchInputDTO} [playerSearchInputDTO] PlayerSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerControllerSearch(playerSearchInputDTO?: PlayerSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerControllerSearch(playerSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerApi.playerControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlayerApi - factory interface
 * @export
 */
export const PlayerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayerApiFp(configuration)
    return {
        /**
         * Create a new ban, creating a ban via the API will always make it takaro managed.   Required permissions: `MANAGE_PLAYERS`
         * @summary Ban player
         * @param {BanCreateDTO} [banCreateDTO] BanCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerCreate(banCreateDTO?: BanCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<BanOutputDTOAPI> {
            return localVarFp.banControllerCreate(banCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Unban player. This will remove the ban from Takaro and the gameserver(s)   Required permissions: `MANAGE_PLAYERS`
         * @summary Unban player
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.banControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single ban   Required permissions: `READ_PLAYERS`
         * @summary Get a single ban
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BanOutputDTOAPI> {
            return localVarFp.banControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for bans   Required permissions: `READ_PLAYERS`
         * @summary Search for bans
         * @param {BanSearchInputDTO} [banSearchInputDTO] BanSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerSearch(banSearchInputDTO?: BanSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<BanOutputArrayDTOAPI> {
            return localVarFp.banControllerSearch(banSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing ban, updating a ban via the API will always make it takaro managed.   Required permissions: `MANAGE_PLAYERS`
         * @summary Update ban
         * @param {string} id 
         * @param {BanUpdateDTO} [banUpdateDTO] BanUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banControllerUpdate(id: string, banUpdateDTO?: BanUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<BanOutputDTOAPI> {
            return localVarFp.banControllerUpdate(id, banUpdateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
         * @summary Assign role
         * @param {string} id 
         * @param {string} roleId 
         * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerAssignRole(id: string, roleId: string, playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.playerControllerAssignRole(id, roleId, playerRoleAssignChangeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the player that is currently authenticated. This is a low-privilege route, returning limited data.
         * @summary Get current player
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerGetMe(options?: RawAxiosRequestConfig): AxiosPromise<PlayerMeOutputDTO> {
            return localVarFp.playerControllerGetMe(options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<PlayerOutputWithRolesDTOAPI> {
            return localVarFp.playerControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
         * @summary Remove role
         * @param {string} id 
         * @param {string} roleId 
         * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerRemoveRole(id: string, roleId: string, playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.playerControllerRemoveRole(id, roleId, playerRoleAssignChangeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Search
         * @param {PlayerSearchInputDTO} [playerSearchInputDTO] PlayerSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerControllerSearch(playerSearchInputDTO?: PlayerSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<PlayerOutputArrayDTOAPI> {
            return localVarFp.playerControllerSearch(playerSearchInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayerApi - object-oriented interface
 * @export
 * @class PlayerApi
 * @extends {BaseAPI}
 */
export class PlayerApi extends BaseAPI {
    /**
     * Create a new ban, creating a ban via the API will always make it takaro managed.   Required permissions: `MANAGE_PLAYERS`
     * @summary Ban player
     * @param {BanCreateDTO} [banCreateDTO] BanCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public banControllerCreate(banCreateDTO?: BanCreateDTO, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).banControllerCreate(banCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unban player. This will remove the ban from Takaro and the gameserver(s)   Required permissions: `MANAGE_PLAYERS`
     * @summary Unban player
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public banControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).banControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single ban   Required permissions: `READ_PLAYERS`
     * @summary Get a single ban
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public banControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).banControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for bans   Required permissions: `READ_PLAYERS`
     * @summary Search for bans
     * @param {BanSearchInputDTO} [banSearchInputDTO] BanSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public banControllerSearch(banSearchInputDTO?: BanSearchInputDTO, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).banControllerSearch(banSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing ban, updating a ban via the API will always make it takaro managed.   Required permissions: `MANAGE_PLAYERS`
     * @summary Update ban
     * @param {string} id 
     * @param {BanUpdateDTO} [banUpdateDTO] BanUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public banControllerUpdate(id: string, banUpdateDTO?: BanUpdateDTO, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).banControllerUpdate(id, banUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
     * @summary Assign role
     * @param {string} id 
     * @param {string} roleId 
     * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerControllerAssignRole(id: string, roleId: string, playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerControllerAssignRole(id, roleId, playerRoleAssignChangeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the player that is currently authenticated. This is a low-privilege route, returning limited data.
     * @summary Get current player
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerControllerGetMe(options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerControllerGetMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_PLAYERS`
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
     * @summary Remove role
     * @param {string} id 
     * @param {string} roleId 
     * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerControllerRemoveRole(id: string, roleId: string, playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerControllerRemoveRole(id, roleId, playerRoleAssignChangeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_PLAYERS`
     * @summary Search
     * @param {PlayerSearchInputDTO} [playerSearchInputDTO] PlayerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerApi
     */
    public playerControllerSearch(playerSearchInputDTO?: PlayerSearchInputDTO, options?: RawAxiosRequestConfig) {
        return PlayerApiFp(this.configuration).playerControllerSearch(playerSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PlayerOnGameServerApi - axios parameter creator
 * @export
 */
export const PlayerOnGameServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Add currency
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerAddCurrency: async (gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('playerOnGameServerControllerAddCurrency', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('playerOnGameServerControllerAddCurrency', 'playerId', playerId)
            const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/add-currency`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerOnGameServerSetCurrencyInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Deduct currency
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerDeductCurrency: async (gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('playerOnGameServerControllerDeductCurrency', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('playerOnGameServerControllerDeductCurrency', 'playerId', playerId)
            const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/deduct-currency`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerOnGameServerSetCurrencyInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get one
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerGetOne: async (gameServerId: string, playerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('playerOnGameServerControllerGetOne', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('playerOnGameServerControllerGetOne', 'playerId', playerId)
            const localVarPath = `/gameserver/{gameServerId}/player/{playerId}`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Search
         * @param {PlayerOnGameServerSearchInputDTO} [playerOnGameServerSearchInputDTO] PlayerOnGameServerSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerSearch: async (playerOnGameServerSearchInputDTO?: PlayerOnGameServerSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gameserver/player/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerOnGameServerSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Set currency
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerSetCurrency: async (gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('playerOnGameServerControllerSetCurrency', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('playerOnGameServerControllerSetCurrency', 'playerId', playerId)
            const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/currency`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerOnGameServerSetCurrencyInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Transact between players
         * @param {string} gameServerId 
         * @param {string} sender 
         * @param {string} receiver 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerTransactBetweenPlayers: async (gameServerId: string, sender: string, receiver: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('playerOnGameServerControllerTransactBetweenPlayers', 'gameServerId', gameServerId)
            // verify required parameter 'sender' is not null or undefined
            assertParamExists('playerOnGameServerControllerTransactBetweenPlayers', 'sender', sender)
            // verify required parameter 'receiver' is not null or undefined
            assertParamExists('playerOnGameServerControllerTransactBetweenPlayers', 'receiver', receiver)
            const localVarPath = `/gameserver/{gameServerId}/player/{sender}/{receiver}/transfer`
                .replace(`{${"gameServerId"}}`, encodeURIComponent(String(gameServerId)))
                .replace(`{${"sender"}}`, encodeURIComponent(String(sender)))
                .replace(`{${"receiver"}}`, encodeURIComponent(String(receiver)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(playerOnGameServerSetCurrencyInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerOnGameServerApi - functional programming interface
 * @export
 */
export const PlayerOnGameServerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayerOnGameServerApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Add currency
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerOnGameServerControllerAddCurrency(gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerAddCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerAddCurrency']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Deduct currency
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerOnGameServerControllerDeductCurrency(gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerDeductCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerDeductCurrency']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get one
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerOnGameServerControllerGetOne(gameServerId: string, playerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerGetOne(gameServerId, playerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Search
         * @param {PlayerOnGameServerSearchInputDTO} [playerOnGameServerSearchInputDTO] PlayerOnGameServerSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerOnGameServerControllerSearch(playerOnGameServerSearchInputDTO?: PlayerOnGameServerSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerSearch(playerOnGameServerSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Set currency
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerOnGameServerControllerSetCurrency(gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerSetCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerSetCurrency']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Transact between players
         * @param {string} gameServerId 
         * @param {string} sender 
         * @param {string} receiver 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerOnGameServerControllerTransactBetweenPlayers(gameServerId: string, sender: string, receiver: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerTransactBetweenPlayers(gameServerId, sender, receiver, playerOnGameServerSetCurrencyInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerTransactBetweenPlayers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PlayerOnGameServerApi - factory interface
 * @export
 */
export const PlayerOnGameServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayerOnGameServerApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Add currency
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerAddCurrency(gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
            return localVarFp.playerOnGameServerControllerAddCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Deduct currency
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerDeductCurrency(gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
            return localVarFp.playerOnGameServerControllerDeductCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get one
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerGetOne(gameServerId: string, playerId: string, options?: RawAxiosRequestConfig): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
            return localVarFp.playerOnGameServerControllerGetOne(gameServerId, playerId, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Search
         * @param {PlayerOnGameServerSearchInputDTO} [playerOnGameServerSearchInputDTO] PlayerOnGameServerSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerSearch(playerOnGameServerSearchInputDTO?: PlayerOnGameServerSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<PlayerOnGameserverOutputArrayDTOAPI> {
            return localVarFp.playerOnGameServerControllerSearch(playerOnGameServerSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Set currency
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerSetCurrency(gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
            return localVarFp.playerOnGameServerControllerSetCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_PLAYERS`
         * @summary Transact between players
         * @param {string} gameServerId 
         * @param {string} sender 
         * @param {string} receiver 
         * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerOnGameServerControllerTransactBetweenPlayers(gameServerId: string, sender: string, receiver: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
            return localVarFp.playerOnGameServerControllerTransactBetweenPlayers(gameServerId, sender, receiver, playerOnGameServerSetCurrencyInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayerOnGameServerApi - object-oriented interface
 * @export
 * @class PlayerOnGameServerApi
 * @extends {BaseAPI}
 */
export class PlayerOnGameServerApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_PLAYERS`
     * @summary Add currency
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerOnGameServerApi
     */
    public playerOnGameServerControllerAddCurrency(gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig) {
        return PlayerOnGameServerApiFp(this.configuration).playerOnGameServerControllerAddCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_PLAYERS`
     * @summary Deduct currency
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerOnGameServerApi
     */
    public playerOnGameServerControllerDeductCurrency(gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig) {
        return PlayerOnGameServerApiFp(this.configuration).playerOnGameServerControllerDeductCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_PLAYERS`
     * @summary Get one
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerOnGameServerApi
     */
    public playerOnGameServerControllerGetOne(gameServerId: string, playerId: string, options?: RawAxiosRequestConfig) {
        return PlayerOnGameServerApiFp(this.configuration).playerOnGameServerControllerGetOne(gameServerId, playerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_PLAYERS`
     * @summary Search
     * @param {PlayerOnGameServerSearchInputDTO} [playerOnGameServerSearchInputDTO] PlayerOnGameServerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerOnGameServerApi
     */
    public playerOnGameServerControllerSearch(playerOnGameServerSearchInputDTO?: PlayerOnGameServerSearchInputDTO, options?: RawAxiosRequestConfig) {
        return PlayerOnGameServerApiFp(this.configuration).playerOnGameServerControllerSearch(playerOnGameServerSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_PLAYERS`
     * @summary Set currency
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerOnGameServerApi
     */
    public playerOnGameServerControllerSetCurrency(gameServerId: string, playerId: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig) {
        return PlayerOnGameServerApiFp(this.configuration).playerOnGameServerControllerSetCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_PLAYERS`
     * @summary Transact between players
     * @param {string} gameServerId 
     * @param {string} sender 
     * @param {string} receiver 
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerOnGameServerApi
     */
    public playerOnGameServerControllerTransactBetweenPlayers(gameServerId: string, sender: string, receiver: string, playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO, options?: RawAxiosRequestConfig) {
        return PlayerOnGameServerApiFp(this.configuration).playerOnGameServerControllerTransactBetweenPlayers(gameServerId, sender, receiver, playerOnGameServerSetCurrencyInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_ROLES`
         * @summary Create
         * @param {RoleCreateInputDTO} [roleCreateInputDTO] RoleCreateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerCreate: async (roleCreateInputDTO?: RoleCreateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/role`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleCreateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_ROLES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roleControllerGetOne', 'id', id)
            const localVarPath = `/role/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerGetPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_ROLES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roleControllerRemove', 'id', id)
            const localVarPath = `/role/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_ROLES`
         * @summary Search
         * @param {RoleSearchInputDTO} [roleSearchInputDTO] RoleSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerSearch: async (roleSearchInputDTO?: RoleSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/role/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_ROLES`
         * @summary Update
         * @param {string} id 
         * @param {RoleUpdateInputDTO} [roleUpdateInputDTO] RoleUpdateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerUpdate: async (id: string, roleUpdateInputDTO?: RoleUpdateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('roleControllerUpdate', 'id', id)
            const localVarPath = `/role/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleUpdateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_ROLES`
         * @summary Create
         * @param {RoleCreateInputDTO} [roleCreateInputDTO] RoleCreateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleControllerCreate(roleCreateInputDTO?: RoleCreateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerCreate(roleCreateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.roleControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_ROLES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.roleControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleControllerGetPermissions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerGetPermissions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.roleControllerGetPermissions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_ROLES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.roleControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_ROLES`
         * @summary Search
         * @param {RoleSearchInputDTO} [roleSearchInputDTO] RoleSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleControllerSearch(roleSearchInputDTO?: RoleSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerSearch(roleSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.roleControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_ROLES`
         * @summary Update
         * @param {string} id 
         * @param {RoleUpdateInputDTO} [roleUpdateInputDTO] RoleUpdateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleControllerUpdate(id: string, roleUpdateInputDTO?: RoleUpdateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerUpdate(id, roleUpdateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoleApi.roleControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_ROLES`
         * @summary Create
         * @param {RoleCreateInputDTO} [roleCreateInputDTO] RoleCreateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerCreate(roleCreateInputDTO?: RoleCreateInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<RoleOutputDTOAPI> {
            return localVarFp.roleControllerCreate(roleCreateInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_ROLES`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RoleOutputDTOAPI> {
            return localVarFp.roleControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerGetPermissions(options?: RawAxiosRequestConfig): AxiosPromise<PermissionOutputDTOAPI> {
            return localVarFp.roleControllerGetPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_ROLES`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.roleControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_ROLES`
         * @summary Search
         * @param {RoleSearchInputDTO} [roleSearchInputDTO] RoleSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerSearch(roleSearchInputDTO?: RoleSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<RoleOutputArrayDTOAPI> {
            return localVarFp.roleControllerSearch(roleSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_ROLES`
         * @summary Update
         * @param {string} id 
         * @param {RoleUpdateInputDTO} [roleUpdateInputDTO] RoleUpdateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleControllerUpdate(id: string, roleUpdateInputDTO?: RoleUpdateInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<RoleOutputDTOAPI> {
            return localVarFp.roleControllerUpdate(id, roleUpdateInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_ROLES`
     * @summary Create
     * @param {RoleCreateInputDTO} [roleCreateInputDTO] RoleCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public roleControllerCreate(roleCreateInputDTO?: RoleCreateInputDTO, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).roleControllerCreate(roleCreateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_ROLES`
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public roleControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).roleControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public roleControllerGetPermissions(options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).roleControllerGetPermissions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_ROLES`
     * @summary Remove
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public roleControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).roleControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_ROLES`
     * @summary Search
     * @param {RoleSearchInputDTO} [roleSearchInputDTO] RoleSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public roleControllerSearch(roleSearchInputDTO?: RoleSearchInputDTO, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).roleControllerSearch(roleSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_ROLES`
     * @summary Update
     * @param {string} id 
     * @param {RoleUpdateInputDTO} [roleUpdateInputDTO] RoleUpdateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleApi
     */
    public roleControllerUpdate(id: string, roleUpdateInputDTO?: RoleUpdateInputDTO, options?: RawAxiosRequestConfig) {
        return RoleApiFp(this.configuration).roleControllerUpdate(id, roleUpdateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_SETTINGS`
         * @summary Delete
         * @param {string} key 
         * @param {string} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerDelete: async (key: string, gameServerId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('settingsControllerDelete', 'key', key)
            const localVarPath = `/settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (gameServerId !== undefined) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get
         * @param {Array<SettingsControllerGetKeysEnum>} [keys] 
         * @param {string} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGet: async (keys?: Array<SettingsControllerGetKeysEnum>, gameServerId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (keys) {
                localVarQueryParameter['keys'] = keys;
            }

            if (gameServerId !== undefined) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one
         * @param {string} key 
         * @param {string} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetOne: async (key: string, gameServerId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('settingsControllerGetOne', 'key', key)
            const localVarPath = `/settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (gameServerId !== undefined) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_SETTINGS`
         * @summary Set
         * @param {string} key 
         * @param {SettingsSetDTO} [settingsSetDTO] SettingsSetDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSet: async (key: string, settingsSetDTO?: SettingsSetDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('settingsControllerSet', 'key', key)
            const localVarPath = `/settings/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(settingsSetDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_SETTINGS`
         * @summary Delete
         * @param {string} key 
         * @param {string} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerDelete(key: string, gameServerId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerDelete(key, gameServerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get
         * @param {Array<SettingsControllerGetKeysEnum>} [keys] 
         * @param {string} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGet(keys?: Array<SettingsControllerGetKeysEnum>, gameServerId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGet(keys, gameServerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsControllerGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get one
         * @param {string} key 
         * @param {string} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGetOne(key: string, gameServerId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetOne(key, gameServerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_SETTINGS`
         * @summary Set
         * @param {string} key 
         * @param {SettingsSetDTO} [settingsSetDTO] SettingsSetDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerSet(key: string, settingsSetDTO?: SettingsSetDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerSet(key, settingsSetDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SettingsApi.settingsControllerSet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_SETTINGS`
         * @summary Delete
         * @param {string} key 
         * @param {string} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerDelete(key: string, gameServerId?: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.settingsControllerDelete(key, gameServerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get
         * @param {Array<SettingsControllerGetKeysEnum>} [keys] 
         * @param {string} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGet(keys?: Array<SettingsControllerGetKeysEnum>, gameServerId?: string, options?: RawAxiosRequestConfig): AxiosPromise<SettingsOutputArrayDTOAPI> {
            return localVarFp.settingsControllerGet(keys, gameServerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one
         * @param {string} key 
         * @param {string} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetOne(key: string, gameServerId?: string, options?: RawAxiosRequestConfig): AxiosPromise<SettingsOutputDTOAPI> {
            return localVarFp.settingsControllerGetOne(key, gameServerId, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_SETTINGS`
         * @summary Set
         * @param {string} key 
         * @param {SettingsSetDTO} [settingsSetDTO] SettingsSetDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSet(key: string, settingsSetDTO?: SettingsSetDTO, options?: RawAxiosRequestConfig): AxiosPromise<SettingsOutputDTOAPI> {
            return localVarFp.settingsControllerSet(key, settingsSetDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_SETTINGS`
     * @summary Delete
     * @param {string} key 
     * @param {string} [gameServerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerDelete(key: string, gameServerId?: string, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerDelete(key, gameServerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get
     * @param {Array<SettingsControllerGetKeysEnum>} [keys] 
     * @param {string} [gameServerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerGet(keys?: Array<SettingsControllerGetKeysEnum>, gameServerId?: string, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerGet(keys, gameServerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one
     * @param {string} key 
     * @param {string} [gameServerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerGetOne(key: string, gameServerId?: string, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerGetOne(key, gameServerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_SETTINGS`
     * @summary Set
     * @param {string} key 
     * @param {SettingsSetDTO} [settingsSetDTO] SettingsSetDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerSet(key: string, settingsSetDTO?: SettingsSetDTO, options?: RawAxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerSet(key, settingsSetDTO, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SettingsControllerGetKeysEnum = {
    CommandPrefix: 'commandPrefix',
    ServerChatName: 'serverChatName',
    EconomyEnabled: 'economyEnabled',
    CurrencyName: 'currencyName',
    DeveloperMode: 'developerMode'
} as const;
export type SettingsControllerGetKeysEnum = typeof SettingsControllerGetKeysEnum[keyof typeof SettingsControllerGetKeysEnum];


/**
 * ShopListingApi - axios parameter creator
 * @export
 */
export const ShopListingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Create
         * @param {ShopListingCreateDTO} [shopListingCreateDTO] ShopListingCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerCreate: async (shopListingCreateDTO?: ShopListingCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/listing/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopListingCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Delete
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopListingControllerDelete', 'id', id)
            const localVarPath = `/shop/listing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopListingControllerGetOne', 'id', id)
            const localVarPath = `/shop/listing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Import listings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerImportListings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/listing/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search
         * @param {ShopListingSearchInputDTO} [shopListingSearchInputDTO] ShopListingSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerSearch: async (shopListingSearchInputDTO?: ShopListingSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/listing/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopListingSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Update
         * @param {string} id 
         * @param {ShopListingUpdateDTO} [shopListingUpdateDTO] ShopListingUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerUpdate: async (id: string, shopListingUpdateDTO?: ShopListingUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopListingControllerUpdate', 'id', id)
            const localVarPath = `/shop/listing/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopListingUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopListingApi - functional programming interface
 * @export
 */
export const ShopListingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopListingApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Create
         * @param {ShopListingCreateDTO} [shopListingCreateDTO] ShopListingCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopListingControllerCreate(shopListingCreateDTO?: ShopListingCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopListingOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopListingControllerCreate(shopListingCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopListingApi.shopListingControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Delete
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopListingControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopListingControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopListingApi.shopListingControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopListingControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopListingOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopListingControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopListingApi.shopListingControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Import listings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopListingControllerImportListings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopListingControllerImportListings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopListingApi.shopListingControllerImportListings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search
         * @param {ShopListingSearchInputDTO} [shopListingSearchInputDTO] ShopListingSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopListingControllerSearch(shopListingSearchInputDTO?: ShopListingSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopListingOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopListingControllerSearch(shopListingSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopListingApi.shopListingControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Update
         * @param {string} id 
         * @param {ShopListingUpdateDTO} [shopListingUpdateDTO] ShopListingUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopListingControllerUpdate(id: string, shopListingUpdateDTO?: ShopListingUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopListingOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopListingControllerUpdate(id, shopListingUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopListingApi.shopListingControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShopListingApi - factory interface
 * @export
 */
export const ShopListingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopListingApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Create
         * @param {ShopListingCreateDTO} [shopListingCreateDTO] ShopListingCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerCreate(shopListingCreateDTO?: ShopListingCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<ShopListingOutputDTOAPI> {
            return localVarFp.shopListingControllerCreate(shopListingCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Delete
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.shopListingControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ShopListingOutputDTOAPI> {
            return localVarFp.shopListingControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Import listings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerImportListings(options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.shopListingControllerImportListings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search
         * @param {ShopListingSearchInputDTO} [shopListingSearchInputDTO] ShopListingSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerSearch(shopListingSearchInputDTO?: ShopListingSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<ShopListingOutputArrayDTOAPI> {
            return localVarFp.shopListingControllerSearch(shopListingSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_SHOP_LISTINGS`
         * @summary Update
         * @param {string} id 
         * @param {ShopListingUpdateDTO} [shopListingUpdateDTO] ShopListingUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopListingControllerUpdate(id: string, shopListingUpdateDTO?: ShopListingUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<ShopListingOutputDTOAPI> {
            return localVarFp.shopListingControllerUpdate(id, shopListingUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShopListingApi - object-oriented interface
 * @export
 * @class ShopListingApi
 * @extends {BaseAPI}
 */
export class ShopListingApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_SHOP_LISTINGS`
     * @summary Create
     * @param {ShopListingCreateDTO} [shopListingCreateDTO] ShopListingCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListingApi
     */
    public shopListingControllerCreate(shopListingCreateDTO?: ShopListingCreateDTO, options?: RawAxiosRequestConfig) {
        return ShopListingApiFp(this.configuration).shopListingControllerCreate(shopListingCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_SHOP_LISTINGS`
     * @summary Delete
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListingApi
     */
    public shopListingControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return ShopListingApiFp(this.configuration).shopListingControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListingApi
     */
    public shopListingControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return ShopListingApiFp(this.configuration).shopListingControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_SHOP_LISTINGS`
     * @summary Import listings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListingApi
     */
    public shopListingControllerImportListings(options?: RawAxiosRequestConfig) {
        return ShopListingApiFp(this.configuration).shopListingControllerImportListings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search
     * @param {ShopListingSearchInputDTO} [shopListingSearchInputDTO] ShopListingSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListingApi
     */
    public shopListingControllerSearch(shopListingSearchInputDTO?: ShopListingSearchInputDTO, options?: RawAxiosRequestConfig) {
        return ShopListingApiFp(this.configuration).shopListingControllerSearch(shopListingSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_SHOP_LISTINGS`
     * @summary Update
     * @param {string} id 
     * @param {ShopListingUpdateDTO} [shopListingUpdateDTO] ShopListingUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopListingApi
     */
    public shopListingControllerUpdate(id: string, shopListingUpdateDTO?: ShopListingUpdateDTO, options?: RawAxiosRequestConfig) {
        return ShopListingApiFp(this.configuration).shopListingControllerUpdate(id, shopListingUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ShopOrderApi - axios parameter creator
 * @export
 */
export const ShopOrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Cancel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerCancel: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopOrderControllerCancel', 'id', id)
            const localVarPath = `/shop/order/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Claiming an order will mark it as completed and give the user the item in-game
         * @summary Claim an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerClaim: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopOrderControllerClaim', 'id', id)
            const localVarPath = `/shop/order/{id}/claim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create
         * @param {ShopOrderCreateDTO} [shopOrderCreateDTO] ShopOrderCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerCreate: async (shopOrderCreateDTO?: ShopOrderCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/order/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopOrderCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an order by its ID. This endpoint only returns orders that belong to the caller. When the caller has permission to view all orders, they can get any order.
         * @summary Get order by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shopOrderControllerGetOne', 'id', id)
            const localVarPath = `/shop/order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for orders. By default, this endpoint only returns your own orders. When the caller has permission to view all orders, they can search for all orders.
         * @summary Search orders
         * @param {ShopOrderSearchInputDTO} [shopOrderSearchInputDTO] ShopOrderSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerSearch: async (shopOrderSearchInputDTO?: ShopOrderSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/shop/order/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shopOrderSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShopOrderApi - functional programming interface
 * @export
 */
export const ShopOrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShopOrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Cancel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderControllerCancel(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopOrderOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderControllerCancel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopOrderApi.shopOrderControllerCancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Claiming an order will mark it as completed and give the user the item in-game
         * @summary Claim an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderControllerClaim(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopOrderOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderControllerClaim(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopOrderApi.shopOrderControllerClaim']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create
         * @param {ShopOrderCreateDTO} [shopOrderCreateDTO] ShopOrderCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderControllerCreate(shopOrderCreateDTO?: ShopOrderCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopOrderOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderControllerCreate(shopOrderCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopOrderApi.shopOrderControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an order by its ID. This endpoint only returns orders that belong to the caller. When the caller has permission to view all orders, they can get any order.
         * @summary Get order by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopOrderOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopOrderApi.shopOrderControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for orders. By default, this endpoint only returns your own orders. When the caller has permission to view all orders, they can search for all orders.
         * @summary Search orders
         * @param {ShopOrderSearchInputDTO} [shopOrderSearchInputDTO] ShopOrderSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shopOrderControllerSearch(shopOrderSearchInputDTO?: ShopOrderSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShopOrderOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shopOrderControllerSearch(shopOrderSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ShopOrderApi.shopOrderControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ShopOrderApi - factory interface
 * @export
 */
export const ShopOrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShopOrderApiFp(configuration)
    return {
        /**
         * 
         * @summary Cancel
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerCancel(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ShopOrderOutputDTOAPI> {
            return localVarFp.shopOrderControllerCancel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Claiming an order will mark it as completed and give the user the item in-game
         * @summary Claim an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerClaim(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ShopOrderOutputDTOAPI> {
            return localVarFp.shopOrderControllerClaim(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create
         * @param {ShopOrderCreateDTO} [shopOrderCreateDTO] ShopOrderCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerCreate(shopOrderCreateDTO?: ShopOrderCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<ShopOrderOutputDTOAPI> {
            return localVarFp.shopOrderControllerCreate(shopOrderCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an order by its ID. This endpoint only returns orders that belong to the caller. When the caller has permission to view all orders, they can get any order.
         * @summary Get order by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ShopOrderOutputDTOAPI> {
            return localVarFp.shopOrderControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for orders. By default, this endpoint only returns your own orders. When the caller has permission to view all orders, they can search for all orders.
         * @summary Search orders
         * @param {ShopOrderSearchInputDTO} [shopOrderSearchInputDTO] ShopOrderSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shopOrderControllerSearch(shopOrderSearchInputDTO?: ShopOrderSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<ShopOrderOutputArrayDTOAPI> {
            return localVarFp.shopOrderControllerSearch(shopOrderSearchInputDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShopOrderApi - object-oriented interface
 * @export
 * @class ShopOrderApi
 * @extends {BaseAPI}
 */
export class ShopOrderApi extends BaseAPI {
    /**
     * 
     * @summary Cancel
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopOrderApi
     */
    public shopOrderControllerCancel(id: string, options?: RawAxiosRequestConfig) {
        return ShopOrderApiFp(this.configuration).shopOrderControllerCancel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Claiming an order will mark it as completed and give the user the item in-game
     * @summary Claim an order
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopOrderApi
     */
    public shopOrderControllerClaim(id: string, options?: RawAxiosRequestConfig) {
        return ShopOrderApiFp(this.configuration).shopOrderControllerClaim(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create
     * @param {ShopOrderCreateDTO} [shopOrderCreateDTO] ShopOrderCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopOrderApi
     */
    public shopOrderControllerCreate(shopOrderCreateDTO?: ShopOrderCreateDTO, options?: RawAxiosRequestConfig) {
        return ShopOrderApiFp(this.configuration).shopOrderControllerCreate(shopOrderCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an order by its ID. This endpoint only returns orders that belong to the caller. When the caller has permission to view all orders, they can get any order.
     * @summary Get order by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopOrderApi
     */
    public shopOrderControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return ShopOrderApiFp(this.configuration).shopOrderControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for orders. By default, this endpoint only returns your own orders. When the caller has permission to view all orders, they can search for all orders.
     * @summary Search orders
     * @param {ShopOrderSearchInputDTO} [shopOrderSearchInputDTO] ShopOrderSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShopOrderApi
     */
    public shopOrderControllerSearch(shopOrderSearchInputDTO?: ShopOrderSearchInputDTO, options?: RawAxiosRequestConfig) {
        return ShopOrderApiFp(this.configuration).shopOrderControllerSearch(shopOrderSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatsApi - axios parameter creator
 * @export
 */
export const StatsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get activity stats
         * @param {StatsControllerGetActivityStatsTimeTypeEnum} timeType 
         * @param {StatsControllerGetActivityStatsDataTypeEnum} dataType 
         * @param {string} [gameServerId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetActivityStats: async (timeType: StatsControllerGetActivityStatsTimeTypeEnum, dataType: StatsControllerGetActivityStatsDataTypeEnum, gameServerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'timeType' is not null or undefined
            assertParamExists('statsControllerGetActivityStats', 'timeType', timeType)
            // verify required parameter 'dataType' is not null or undefined
            assertParamExists('statsControllerGetActivityStats', 'dataType', dataType)
            const localVarPath = `/stats/activity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (gameServerId !== undefined) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }

            if (timeType !== undefined) {
                localVarQueryParameter['timeType'] = timeType;
            }

            if (dataType !== undefined) {
                localVarQueryParameter['dataType'] = dataType;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculates how many players are from each country. Returns a count per country (ISO3166).   Required permissions: `READ_PLAYERS`
         * @summary Get statistics about the countries of the players
         * @param {Array<string>} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetCountryStats: async (gameServerId?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats/countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (gameServerId) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get currency stats
         * @param {string} gameServerId 
         * @param {string} [playerId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetCurrencyStats: async (gameServerId: string, playerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('statsControllerGetCurrencyStats', 'gameServerId', gameServerId)
            const localVarPath = `/stats/currency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (gameServerId !== undefined) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calculates how many times an event type has occured over `bucketStep` time. Supports different filters and can return multiple series at a time.   Required permissions: `READ_PLAYERS`
         * @summary Get event count over time
         * @param {StatsControllerGetEventsCountEventNameEnum} eventName 
         * @param {StatsControllerGetEventsCountBucketStepEnum} bucketStep 
         * @param {Array<StatsControllerGetEventsCountSumByEnum>} [sumBy] 
         * @param {string} [gameServerId] 
         * @param {string} [moduleId] 
         * @param {string} [playerId] 
         * @param {string} [userId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetEventsCount: async (eventName: StatsControllerGetEventsCountEventNameEnum, bucketStep: StatsControllerGetEventsCountBucketStepEnum, sumBy?: Array<StatsControllerGetEventsCountSumByEnum>, gameServerId?: string, moduleId?: string, playerId?: string, userId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventName' is not null or undefined
            assertParamExists('statsControllerGetEventsCount', 'eventName', eventName)
            // verify required parameter 'bucketStep' is not null or undefined
            assertParamExists('statsControllerGetEventsCount', 'bucketStep', bucketStep)
            const localVarPath = `/stats/events-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }

            if (sumBy) {
                localVarQueryParameter['sumBy'] = sumBy;
            }

            if (gameServerId !== undefined) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }

            if (moduleId !== undefined) {
                localVarQueryParameter['moduleId'] = moduleId;
            }

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (bucketStep !== undefined) {
                localVarQueryParameter['bucketStep'] = bucketStep;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The roundtrip time for reachability tests between Takaro and the game server
         * @summary Get latency stats
         * @param {string} gameServerId 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetLatencyStats: async (gameServerId: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('statsControllerGetLatencyStats', 'gameServerId', gameServerId)
            const localVarPath = `/stats/latency`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (gameServerId !== undefined) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get ping stats
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetPingStats: async (gameServerId: string, playerId: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'gameServerId' is not null or undefined
            assertParamExists('statsControllerGetPingStats', 'gameServerId', gameServerId)
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('statsControllerGetPingStats', 'playerId', playerId)
            const localVarPath = `/stats/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (gameServerId !== undefined) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get player online stats
         * @param {string} [gameServerId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetPlayerOnlineStats: async (gameServerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stats/players-online`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required

            if (gameServerId !== undefined) {
                localVarQueryParameter['gameServerId'] = gameServerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsApi - functional programming interface
 * @export
 */
export const StatsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get activity stats
         * @param {StatsControllerGetActivityStatsTimeTypeEnum} timeType 
         * @param {StatsControllerGetActivityStatsDataTypeEnum} dataType 
         * @param {string} [gameServerId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsControllerGetActivityStats(timeType: StatsControllerGetActivityStatsTimeTypeEnum, dataType: StatsControllerGetActivityStatsDataTypeEnum, gameServerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statsControllerGetActivityStats(timeType, dataType, gameServerId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.statsControllerGetActivityStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculates how many players are from each country. Returns a count per country (ISO3166).   Required permissions: `READ_PLAYERS`
         * @summary Get statistics about the countries of the players
         * @param {Array<string>} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsControllerGetCountryStats(gameServerId?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statsControllerGetCountryStats(gameServerId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.statsControllerGetCountryStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get currency stats
         * @param {string} gameServerId 
         * @param {string} [playerId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsControllerGetCurrencyStats(gameServerId: string, playerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statsControllerGetCurrencyStats(gameServerId, playerId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.statsControllerGetCurrencyStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Calculates how many times an event type has occured over `bucketStep` time. Supports different filters and can return multiple series at a time.   Required permissions: `READ_PLAYERS`
         * @summary Get event count over time
         * @param {StatsControllerGetEventsCountEventNameEnum} eventName 
         * @param {StatsControllerGetEventsCountBucketStepEnum} bucketStep 
         * @param {Array<StatsControllerGetEventsCountSumByEnum>} [sumBy] 
         * @param {string} [gameServerId] 
         * @param {string} [moduleId] 
         * @param {string} [playerId] 
         * @param {string} [userId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsControllerGetEventsCount(eventName: StatsControllerGetEventsCountEventNameEnum, bucketStep: StatsControllerGetEventsCountBucketStepEnum, sumBy?: Array<StatsControllerGetEventsCountSumByEnum>, gameServerId?: string, moduleId?: string, playerId?: string, userId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statsControllerGetEventsCount(eventName, bucketStep, sumBy, gameServerId, moduleId, playerId, userId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.statsControllerGetEventsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * The roundtrip time for reachability tests between Takaro and the game server
         * @summary Get latency stats
         * @param {string} gameServerId 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsControllerGetLatencyStats(gameServerId: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statsControllerGetLatencyStats(gameServerId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.statsControllerGetLatencyStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get ping stats
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsControllerGetPingStats(gameServerId: string, playerId: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statsControllerGetPingStats(gameServerId, playerId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.statsControllerGetPingStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get player online stats
         * @param {string} [gameServerId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statsControllerGetPlayerOnlineStats(gameServerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statsControllerGetPlayerOnlineStats(gameServerId, startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsApi.statsControllerGetPlayerOnlineStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatsApi - factory interface
 * @export
 */
export const StatsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsApiFp(configuration)
    return {
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get activity stats
         * @param {StatsControllerGetActivityStatsTimeTypeEnum} timeType 
         * @param {StatsControllerGetActivityStatsDataTypeEnum} dataType 
         * @param {string} [gameServerId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetActivityStats(timeType: StatsControllerGetActivityStatsTimeTypeEnum, dataType: StatsControllerGetActivityStatsDataTypeEnum, gameServerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): AxiosPromise<StatsOutputDTOAPI> {
            return localVarFp.statsControllerGetActivityStats(timeType, dataType, gameServerId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculates how many players are from each country. Returns a count per country (ISO3166).   Required permissions: `READ_PLAYERS`
         * @summary Get statistics about the countries of the players
         * @param {Array<string>} [gameServerId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetCountryStats(gameServerId?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<StatsOutputDTOAPI> {
            return localVarFp.statsControllerGetCountryStats(gameServerId, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get currency stats
         * @param {string} gameServerId 
         * @param {string} [playerId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetCurrencyStats(gameServerId: string, playerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): AxiosPromise<StatsOutputDTOAPI> {
            return localVarFp.statsControllerGetCurrencyStats(gameServerId, playerId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Calculates how many times an event type has occured over `bucketStep` time. Supports different filters and can return multiple series at a time.   Required permissions: `READ_PLAYERS`
         * @summary Get event count over time
         * @param {StatsControllerGetEventsCountEventNameEnum} eventName 
         * @param {StatsControllerGetEventsCountBucketStepEnum} bucketStep 
         * @param {Array<StatsControllerGetEventsCountSumByEnum>} [sumBy] 
         * @param {string} [gameServerId] 
         * @param {string} [moduleId] 
         * @param {string} [playerId] 
         * @param {string} [userId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetEventsCount(eventName: StatsControllerGetEventsCountEventNameEnum, bucketStep: StatsControllerGetEventsCountBucketStepEnum, sumBy?: Array<StatsControllerGetEventsCountSumByEnum>, gameServerId?: string, moduleId?: string, playerId?: string, userId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): AxiosPromise<StatsOutputDTOAPI> {
            return localVarFp.statsControllerGetEventsCount(eventName, bucketStep, sumBy, gameServerId, moduleId, playerId, userId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * The roundtrip time for reachability tests between Takaro and the game server
         * @summary Get latency stats
         * @param {string} gameServerId 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetLatencyStats(gameServerId: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): AxiosPromise<StatsOutputDTOAPI> {
            return localVarFp.statsControllerGetLatencyStats(gameServerId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get ping stats
         * @param {string} gameServerId 
         * @param {string} playerId 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetPingStats(gameServerId: string, playerId: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): AxiosPromise<StatsOutputDTOAPI> {
            return localVarFp.statsControllerGetPingStats(gameServerId, playerId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_PLAYERS`
         * @summary Get player online stats
         * @param {string} [gameServerId] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
         * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statsControllerGetPlayerOnlineStats(gameServerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig): AxiosPromise<StatsOutputDTOAPI> {
            return localVarFp.statsControllerGetPlayerOnlineStats(gameServerId, startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsApi - object-oriented interface
 * @export
 * @class StatsApi
 * @extends {BaseAPI}
 */
export class StatsApi extends BaseAPI {
    /**
     *    Required permissions: `READ_PLAYERS`
     * @summary Get activity stats
     * @param {StatsControllerGetActivityStatsTimeTypeEnum} timeType 
     * @param {StatsControllerGetActivityStatsDataTypeEnum} dataType 
     * @param {string} [gameServerId] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsControllerGetActivityStats(timeType: StatsControllerGetActivityStatsTimeTypeEnum, dataType: StatsControllerGetActivityStatsDataTypeEnum, gameServerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).statsControllerGetActivityStats(timeType, dataType, gameServerId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculates how many players are from each country. Returns a count per country (ISO3166).   Required permissions: `READ_PLAYERS`
     * @summary Get statistics about the countries of the players
     * @param {Array<string>} [gameServerId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsControllerGetCountryStats(gameServerId?: Array<string>, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).statsControllerGetCountryStats(gameServerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_PLAYERS`
     * @summary Get currency stats
     * @param {string} gameServerId 
     * @param {string} [playerId] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsControllerGetCurrencyStats(gameServerId: string, playerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).statsControllerGetCurrencyStats(gameServerId, playerId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Calculates how many times an event type has occured over `bucketStep` time. Supports different filters and can return multiple series at a time.   Required permissions: `READ_PLAYERS`
     * @summary Get event count over time
     * @param {StatsControllerGetEventsCountEventNameEnum} eventName 
     * @param {StatsControllerGetEventsCountBucketStepEnum} bucketStep 
     * @param {Array<StatsControllerGetEventsCountSumByEnum>} [sumBy] 
     * @param {string} [gameServerId] 
     * @param {string} [moduleId] 
     * @param {string} [playerId] 
     * @param {string} [userId] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsControllerGetEventsCount(eventName: StatsControllerGetEventsCountEventNameEnum, bucketStep: StatsControllerGetEventsCountBucketStepEnum, sumBy?: Array<StatsControllerGetEventsCountSumByEnum>, gameServerId?: string, moduleId?: string, playerId?: string, userId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).statsControllerGetEventsCount(eventName, bucketStep, sumBy, gameServerId, moduleId, playerId, userId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The roundtrip time for reachability tests between Takaro and the game server
     * @summary Get latency stats
     * @param {string} gameServerId 
     * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsControllerGetLatencyStats(gameServerId: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).statsControllerGetLatencyStats(gameServerId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_PLAYERS`
     * @summary Get ping stats
     * @param {string} gameServerId 
     * @param {string} playerId 
     * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsControllerGetPingStats(gameServerId: string, playerId: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).statsControllerGetPingStats(gameServerId, playerId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_PLAYERS`
     * @summary Get player online stats
     * @param {string} [gameServerId] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [startDate] 
     * @param {StatsControllerGetPingStatsStartDateParameter} [endDate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsApi
     */
    public statsControllerGetPlayerOnlineStats(gameServerId?: string, startDate?: StatsControllerGetPingStatsStartDateParameter, endDate?: StatsControllerGetPingStatsStartDateParameter, options?: RawAxiosRequestConfig) {
        return StatsApiFp(this.configuration).statsControllerGetPlayerOnlineStats(gameServerId, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const StatsControllerGetActivityStatsTimeTypeEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;
export type StatsControllerGetActivityStatsTimeTypeEnum = typeof StatsControllerGetActivityStatsTimeTypeEnum[keyof typeof StatsControllerGetActivityStatsTimeTypeEnum];
/**
 * @export
 */
export const StatsControllerGetActivityStatsDataTypeEnum = {
    Users: 'users',
    Players: 'players'
} as const;
export type StatsControllerGetActivityStatsDataTypeEnum = typeof StatsControllerGetActivityStatsDataTypeEnum[keyof typeof StatsControllerGetActivityStatsDataTypeEnum];
/**
 * @export
 */
export const StatsControllerGetEventsCountEventNameEnum = {
    RoleAssigned: 'role-assigned',
    RoleRemoved: 'role-removed',
    RoleCreated: 'role-created',
    RoleUpdated: 'role-updated',
    RoleDeleted: 'role-deleted',
    CommandExecuted: 'command-executed',
    HookExecuted: 'hook-executed',
    CronjobExecuted: 'cronjob-executed',
    CurrencyAdded: 'currency-added',
    CurrencyDeducted: 'currency-deducted',
    SettingsSet: 'settings-set',
    PlayerNewIpDetected: 'player-new-ip-detected',
    ServerStatusChanged: 'server-status-changed',
    ModuleCreated: 'module-created',
    ModuleUpdated: 'module-updated',
    ModuleDeleted: 'module-deleted',
    ModuleInstalled: 'module-installed',
    ModuleUninstalled: 'module-uninstalled',
    PlayerCreated: 'player-created',
    ShopListingCreated: 'shop-listing-created',
    ShopListingUpdated: 'shop-listing-updated',
    ShopListingDeleted: 'shop-listing-deleted',
    ShopOrderCreated: 'shop-order-created',
    ShopOrderStatusChanged: 'shop-order-status-changed',
    PlayerLinked: 'player-linked',
    PlayerConnected: 'player-connected',
    PlayerDisconnected: 'player-disconnected',
    ChatMessage: 'chat-message',
    PlayerDeath: 'player-death',
    EntityKilled: 'entity-killed'
} as const;
export type StatsControllerGetEventsCountEventNameEnum = typeof StatsControllerGetEventsCountEventNameEnum[keyof typeof StatsControllerGetEventsCountEventNameEnum];
/**
 * @export
 */
export const StatsControllerGetEventsCountBucketStepEnum = {
    _5m: '5m',
    _30m: '30m',
    _1h: '1h',
    _6h: '6h',
    _12h: '12h',
    _24h: '24h'
} as const;
export type StatsControllerGetEventsCountBucketStepEnum = typeof StatsControllerGetEventsCountBucketStepEnum[keyof typeof StatsControllerGetEventsCountBucketStepEnum];
/**
 * @export
 */
export const StatsControllerGetEventsCountSumByEnum = {
    Player: 'player',
    Module: 'module',
    User: 'user',
    Gameserver: 'gameserver'
} as const;
export type StatsControllerGetEventsCountSumByEnum = typeof StatsControllerGetEventsCountSumByEnum[keyof typeof StatsControllerGetEventsCountSumByEnum];


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
         * @summary Assign role
         * @param {string} id 
         * @param {string} roleId 
         * @param {UserRoleAssignChangeDTO} [userRoleAssignChangeDTO] UserRoleAssignChangeDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAssignRole: async (id: string, roleId: string, userRoleAssignChangeDTO?: UserRoleAssignChangeDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerAssignRole', 'id', id)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('userControllerAssignRole', 'roleId', roleId)
            const localVarPath = `/user/{id}/role/{roleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleAssignChangeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Create
         * @param {UserCreateInputDTO} [userCreateInputDTO] UserCreateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate: async (userCreateInputDTO?: UserCreateInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unset the selected domain for the user, this will clear the domain cookie. On the next request, the backend will set this again.
         * @summary Unset the selected domain for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteSelectedDomainCookie: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/selected-domain`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_USERS`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerGetOne', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Invite
         * @param {InviteCreateDTO} [inviteCreateDTO] InviteCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerInvite: async (inviteCreateDTO?: InviteCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/invite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Link your player profile to Takaro, allowing web access for things like shop and stats. To get the code, use the /link command in the game.
         * @summary Link player profile
         * @param {LinkPlayerUnauthedInputDTO} [linkPlayerUnauthedInputDTO] LinkPlayerUnauthedInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLinkPlayerProfile: async (linkPlayerUnauthedInputDTO?: LinkPlayerUnauthedInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/player`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(linkPlayerUnauthedInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {LoginDTO} [loginDTO] LoginDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLogin: async (loginDTO?: LoginDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the current user and the domains that the user has access to. Note that you can only make requests in the scope of a single domain. In order to switch the domain, you need to use the domain selection endpoints
         * @summary Get the current logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerRemove', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
         * @summary Remove role
         * @param {string} id 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveRole: async (id: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerRemoveRole', 'id', id)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('userControllerRemoveRole', 'roleId', roleId)
            const localVarPath = `/user/{id}/role/{roleId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_USERS`
         * @summary Search
         * @param {UserSearchInputDTO} [userSearchInputDTO] UserSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerSearch: async (userSearchInputDTO?: UserSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * One user can have multiple domains, this endpoint is a helper to set the selected domain for the user
         * @summary Set the selected domain for the user
         * @param {string} domainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerSetSelectedDomain: async (domainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('userControllerSetSelectedDomain', 'domainId', domainId)
            const localVarPath = `/selected-domain/{domainId}`
                .replace(`{${"domainId"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Update
         * @param {string} id 
         * @param {UserUpdateDTO} [userUpdateDTO] UserUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate: async (id: string, userUpdateDTO?: UserUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerUpdate', 'id', id)
            const localVarPath = `/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
         * @summary Assign role
         * @param {string} id 
         * @param {string} roleId 
         * @param {UserRoleAssignChangeDTO} [userRoleAssignChangeDTO] UserRoleAssignChangeDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerAssignRole(id: string, roleId: string, userRoleAssignChangeDTO?: UserRoleAssignChangeDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerAssignRole(id, roleId, userRoleAssignChangeDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerAssignRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Create
         * @param {UserCreateInputDTO} [userCreateInputDTO] UserCreateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerCreate(userCreateInputDTO?: UserCreateInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreate(userCreateInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unset the selected domain for the user, this will clear the domain cookie. On the next request, the backend will set this again.
         * @summary Unset the selected domain for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerDeleteSelectedDomainCookie(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerDeleteSelectedDomainCookie(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerDeleteSelectedDomainCookie']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_USERS`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerGetOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerGetOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Invite
         * @param {InviteCreateDTO} [inviteCreateDTO] InviteCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerInvite(inviteCreateDTO?: InviteCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerInvite(inviteCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Link your player profile to Takaro, allowing web access for things like shop and stats. To get the code, use the /link command in the game.
         * @summary Link player profile
         * @param {LinkPlayerUnauthedInputDTO} [linkPlayerUnauthedInputDTO] LinkPlayerUnauthedInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerLinkPlayerProfile(linkPlayerUnauthedInputDTO?: LinkPlayerUnauthedInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerLinkPlayerProfile(linkPlayerUnauthedInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerLinkPlayerProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Login
         * @param {LoginDTO} [loginDTO] LoginDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerLogin(loginDTO?: LoginDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerLogin(loginDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerLogout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerLogout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerLogout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the current user and the domains that the user has access to. Note that you can only make requests in the scope of a single domain. In order to switch the domain, you need to use the domain selection endpoints
         * @summary Get the current logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerMe(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeOutoutDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerMe(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerMe']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemove(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemove(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerRemove']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
         * @summary Remove role
         * @param {string} id 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerRemoveRole(id: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemoveRole(id, roleId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerRemoveRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_USERS`
         * @summary Search
         * @param {UserSearchInputDTO} [userSearchInputDTO] UserSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerSearch(userSearchInputDTO?: UserSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSearch(userSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * One user can have multiple domains, this endpoint is a helper to set the selected domain for the user
         * @summary Set the selected domain for the user
         * @param {string} domainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerSetSelectedDomain(domainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSetSelectedDomain(domainId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerSetSelectedDomain']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Update
         * @param {string} id 
         * @param {UserUpdateDTO} [userUpdateDTO] UserUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerUpdate(id: string, userUpdateDTO?: UserUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(id, userUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
         * @summary Assign role
         * @param {string} id 
         * @param {string} roleId 
         * @param {UserRoleAssignChangeDTO} [userRoleAssignChangeDTO] UserRoleAssignChangeDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerAssignRole(id: string, roleId: string, userRoleAssignChangeDTO?: UserRoleAssignChangeDTO, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.userControllerAssignRole(id, roleId, userRoleAssignChangeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Create
         * @param {UserCreateInputDTO} [userCreateInputDTO] UserCreateInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerCreate(userCreateInputDTO?: UserCreateInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserOutputDTOAPI> {
            return localVarFp.userControllerCreate(userCreateInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Unset the selected domain for the user, this will clear the domain cookie. On the next request, the backend will set this again.
         * @summary Unset the selected domain for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerDeleteSelectedDomainCookie(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userControllerDeleteSelectedDomainCookie(options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_USERS`
         * @summary Get one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerGetOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserOutputDTOAPI> {
            return localVarFp.userControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Invite
         * @param {InviteCreateDTO} [inviteCreateDTO] InviteCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerInvite(inviteCreateDTO?: InviteCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserOutputDTOAPI> {
            return localVarFp.userControllerInvite(inviteCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Link your player profile to Takaro, allowing web access for things like shop and stats. To get the code, use the /link command in the game.
         * @summary Link player profile
         * @param {LinkPlayerUnauthedInputDTO} [linkPlayerUnauthedInputDTO] LinkPlayerUnauthedInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLinkPlayerProfile(linkPlayerUnauthedInputDTO?: LinkPlayerUnauthedInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userControllerLinkPlayerProfile(linkPlayerUnauthedInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {LoginDTO} [loginDTO] LoginDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLogin(loginDTO?: LoginDTO, options?: RawAxiosRequestConfig): AxiosPromise<LoginOutputDTOAPI> {
            return localVarFp.userControllerLogin(loginDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerLogout(options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.userControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the current user and the domains that the user has access to. Note that you can only make requests in the scope of a single domain. In order to switch the domain, you need to use the domain selection endpoints
         * @summary Get the current logged in user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerMe(options?: RawAxiosRequestConfig): AxiosPromise<MeOutoutDTOAPI> {
            return localVarFp.userControllerMe(options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Remove
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemove(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.userControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
         * @summary Remove role
         * @param {string} id 
         * @param {string} roleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerRemoveRole(id: string, roleId: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.userControllerRemoveRole(id, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_USERS`
         * @summary Search
         * @param {UserSearchInputDTO} [userSearchInputDTO] UserSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerSearch(userSearchInputDTO?: UserSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserOutputArrayDTOAPI> {
            return localVarFp.userControllerSearch(userSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * One user can have multiple domains, this endpoint is a helper to set the selected domain for the user
         * @summary Set the selected domain for the user
         * @param {string} domainId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerSetSelectedDomain(domainId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.userControllerSetSelectedDomain(domainId, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_USERS`
         * @summary Update
         * @param {string} id 
         * @param {UserUpdateDTO} [userUpdateDTO] UserUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerUpdate(id: string, userUpdateDTO?: UserUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<UserOutputDTOAPI> {
            return localVarFp.userControllerUpdate(id, userUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
     * @summary Assign role
     * @param {string} id 
     * @param {string} roleId 
     * @param {UserRoleAssignChangeDTO} [userRoleAssignChangeDTO] UserRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerAssignRole(id: string, roleId: string, userRoleAssignChangeDTO?: UserRoleAssignChangeDTO, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerAssignRole(id, roleId, userRoleAssignChangeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_USERS`
     * @summary Create
     * @param {UserCreateInputDTO} [userCreateInputDTO] UserCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerCreate(userCreateInputDTO?: UserCreateInputDTO, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerCreate(userCreateInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unset the selected domain for the user, this will clear the domain cookie. On the next request, the backend will set this again.
     * @summary Unset the selected domain for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerDeleteSelectedDomainCookie(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerDeleteSelectedDomainCookie(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_USERS`
     * @summary Get one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_USERS`
     * @summary Invite
     * @param {InviteCreateDTO} [inviteCreateDTO] InviteCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerInvite(inviteCreateDTO?: InviteCreateDTO, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerInvite(inviteCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Link your player profile to Takaro, allowing web access for things like shop and stats. To get the code, use the /link command in the game.
     * @summary Link player profile
     * @param {LinkPlayerUnauthedInputDTO} [linkPlayerUnauthedInputDTO] LinkPlayerUnauthedInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerLinkPlayerProfile(linkPlayerUnauthedInputDTO?: LinkPlayerUnauthedInputDTO, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerLinkPlayerProfile(linkPlayerUnauthedInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {LoginDTO} [loginDTO] LoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerLogin(loginDTO?: LoginDTO, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerLogin(loginDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerLogout(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the current user and the domains that the user has access to. Note that you can only make requests in the scope of a single domain. In order to switch the domain, you need to use the domain selection endpoints
     * @summary Get the current logged in user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerMe(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_USERS`
     * @summary Remove
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerRemove(id: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
     * @summary Remove role
     * @param {string} id 
     * @param {string} roleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerRemoveRole(id: string, roleId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerRemoveRole(id, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_USERS`
     * @summary Search
     * @param {UserSearchInputDTO} [userSearchInputDTO] UserSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerSearch(userSearchInputDTO?: UserSearchInputDTO, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerSearch(userSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * One user can have multiple domains, this endpoint is a helper to set the selected domain for the user
     * @summary Set the selected domain for the user
     * @param {string} domainId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerSetSelectedDomain(domainId: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerSetSelectedDomain(domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_USERS`
     * @summary Update
     * @param {string} id 
     * @param {UserUpdateDTO} [userUpdateDTO] UserUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerUpdate(id: string, userUpdateDTO?: UserUpdateDTO, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerUpdate(id, userUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VariableApi - axios parameter creator
 * @export
 */
export const VariableApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *    Required permissions: `MANAGE_VARIABLES`
         * @summary Create
         * @param {VariableCreateDTO} [variableCreateDTO] VariableCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerCreate: async (variableCreateDTO?: VariableCreateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variables`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableCreateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_VARIABLES`
         * @summary Delete
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('variableControllerDelete', 'id', id)
            const localVarPath = `/variables/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_VARIABLES`
         * @summary Find one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('variableControllerFindOne', 'id', id)
            const localVarPath = `/variables/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `READ_VARIABLES`
         * @summary Search
         * @param {VariableSearchInputDTO} [variableSearchInputDTO] VariableSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerSearch: async (variableSearchInputDTO?: VariableSearchInputDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/variables/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableSearchInputDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *    Required permissions: `MANAGE_VARIABLES`
         * @summary Update
         * @param {string} id 
         * @param {VariableUpdateDTO} [variableUpdateDTO] VariableUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerUpdate: async (id: string, variableUpdateDTO?: VariableUpdateDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('variableControllerUpdate', 'id', id)
            const localVarPath = `/variables/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication domainAuth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(variableUpdateDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VariableApi - functional programming interface
 * @export
 */
export const VariableApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VariableApiAxiosParamCreator(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_VARIABLES`
         * @summary Create
         * @param {VariableCreateDTO} [variableCreateDTO] VariableCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variableControllerCreate(variableCreateDTO?: VariableCreateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerCreate(variableCreateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableApi.variableControllerCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_VARIABLES`
         * @summary Delete
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variableControllerDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableApi.variableControllerDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_VARIABLES`
         * @summary Find one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variableControllerFindOne(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerFindOne(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableApi.variableControllerFindOne']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `READ_VARIABLES`
         * @summary Search
         * @param {VariableSearchInputDTO} [variableSearchInputDTO] VariableSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variableControllerSearch(variableSearchInputDTO?: VariableSearchInputDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableOutputArrayDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerSearch(variableSearchInputDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableApi.variableControllerSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *    Required permissions: `MANAGE_VARIABLES`
         * @summary Update
         * @param {string} id 
         * @param {VariableUpdateDTO} [variableUpdateDTO] VariableUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async variableControllerUpdate(id: string, variableUpdateDTO?: VariableUpdateDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableOutputDTOAPI>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerUpdate(id, variableUpdateDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VariableApi.variableControllerUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VariableApi - factory interface
 * @export
 */
export const VariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VariableApiFp(configuration)
    return {
        /**
         *    Required permissions: `MANAGE_VARIABLES`
         * @summary Create
         * @param {VariableCreateDTO} [variableCreateDTO] VariableCreateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerCreate(variableCreateDTO?: VariableCreateDTO, options?: RawAxiosRequestConfig): AxiosPromise<VariableOutputDTOAPI> {
            return localVarFp.variableControllerCreate(variableCreateDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_VARIABLES`
         * @summary Delete
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerDelete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<APIOutput> {
            return localVarFp.variableControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_VARIABLES`
         * @summary Find one
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerFindOne(id: string, options?: RawAxiosRequestConfig): AxiosPromise<VariableOutputDTOAPI> {
            return localVarFp.variableControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `READ_VARIABLES`
         * @summary Search
         * @param {VariableSearchInputDTO} [variableSearchInputDTO] VariableSearchInputDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerSearch(variableSearchInputDTO?: VariableSearchInputDTO, options?: RawAxiosRequestConfig): AxiosPromise<VariableOutputArrayDTOAPI> {
            return localVarFp.variableControllerSearch(variableSearchInputDTO, options).then((request) => request(axios, basePath));
        },
        /**
         *    Required permissions: `MANAGE_VARIABLES`
         * @summary Update
         * @param {string} id 
         * @param {VariableUpdateDTO} [variableUpdateDTO] VariableUpdateDTO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        variableControllerUpdate(id: string, variableUpdateDTO?: VariableUpdateDTO, options?: RawAxiosRequestConfig): AxiosPromise<VariableOutputDTOAPI> {
            return localVarFp.variableControllerUpdate(id, variableUpdateDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VariableApi - object-oriented interface
 * @export
 * @class VariableApi
 * @extends {BaseAPI}
 */
export class VariableApi extends BaseAPI {
    /**
     *    Required permissions: `MANAGE_VARIABLES`
     * @summary Create
     * @param {VariableCreateDTO} [variableCreateDTO] VariableCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableApi
     */
    public variableControllerCreate(variableCreateDTO?: VariableCreateDTO, options?: RawAxiosRequestConfig) {
        return VariableApiFp(this.configuration).variableControllerCreate(variableCreateDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_VARIABLES`
     * @summary Delete
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableApi
     */
    public variableControllerDelete(id: string, options?: RawAxiosRequestConfig) {
        return VariableApiFp(this.configuration).variableControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_VARIABLES`
     * @summary Find one
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableApi
     */
    public variableControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
        return VariableApiFp(this.configuration).variableControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `READ_VARIABLES`
     * @summary Search
     * @param {VariableSearchInputDTO} [variableSearchInputDTO] VariableSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableApi
     */
    public variableControllerSearch(variableSearchInputDTO?: VariableSearchInputDTO, options?: RawAxiosRequestConfig) {
        return VariableApiFp(this.configuration).variableControllerSearch(variableSearchInputDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *    Required permissions: `MANAGE_VARIABLES`
     * @summary Update
     * @param {string} id 
     * @param {VariableUpdateDTO} [variableUpdateDTO] VariableUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VariableApi
     */
    public variableControllerUpdate(id: string, variableUpdateDTO?: VariableUpdateDTO, options?: RawAxiosRequestConfig) {
        return VariableApiFp(this.configuration).variableControllerUpdate(id, variableUpdateDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



