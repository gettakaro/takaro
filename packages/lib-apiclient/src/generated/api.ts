/* tslint:disable */
/* eslint-disable */
/**
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from './configuration.js';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common.js';
import type { RequestArgs } from './base.js';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base.js';

/**
 *
 * @export
 * @interface APIOutput
 */
export interface APIOutput {
  /**
   *
   * @type {MetadataOutput}
   * @memberof APIOutput
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface BanDTO
 */
export interface BanDTO {
  /**
   *
   * @type {IPlayerReferenceDTO}
   * @memberof BanDTO
   */
  player: IPlayerReferenceDTO;
  /**
   *
   * @type {string}
   * @memberof BanDTO
   */
  reason: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof BanDTO
   */
  expiresAt?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface BanPlayerInputDTO
 */
export interface BanPlayerInputDTO {
  /**
   *
   * @type {string}
   * @memberof BanPlayerInputDTO
   */
  reason?: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof BanPlayerInputDTO
   */
  expiresAt?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface BanPlayerOutputDTO
 */
export interface BanPlayerOutputDTO {
  /**
   *
   * @type {Array<BanDTO>}
   * @memberof BanPlayerOutputDTO
   */
  data: Array<BanDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof BanPlayerOutputDTO
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface BaseDiscordEvent
 */
export interface BaseDiscordEvent {
  /**
   *
   * @type {string}
   * @memberof BaseDiscordEvent
   */
  msg: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof BaseDiscordEvent
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface BaseEvent
 */
export interface BaseEvent {
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof BaseEvent
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface BaseGameEvent
 */
export interface BaseGameEvent {
  /**
   *
   * @type {string}
   * @memberof BaseGameEvent
   */
  msg?: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof BaseGameEvent
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface BaseTakaroEvent
 */
export interface BaseTakaroEvent {
  /**
   *
   * @type {string}
   * @memberof BaseTakaroEvent
   */
  msg: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof BaseTakaroEvent
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface CommandArgumentCreateDTO
 */
export interface CommandArgumentCreateDTO {
  /**
   *
   * @type {string}
   * @memberof CommandArgumentCreateDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentCreateDTO
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentCreateDTO
   */
  helpText?: string;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentCreateDTO
   */
  defaultValue?: string;
  /**
   *
   * @type {number}
   * @memberof CommandArgumentCreateDTO
   */
  position: number;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentCreateDTO
   */
  commandId?: string;
}
/**
 *
 * @export
 * @interface CommandArgumentDTOAPI
 */
export interface CommandArgumentDTOAPI {
  /**
   *
   * @type {CommandArgumentOutputDTO}
   * @memberof CommandArgumentDTOAPI
   */
  data: CommandArgumentOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof CommandArgumentDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface CommandArgumentOutputDTO
 */
export interface CommandArgumentOutputDTO {
  /**
   *
   * @type {string}
   * @memberof CommandArgumentOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentOutputDTO
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentOutputDTO
   */
  helpText: string;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentOutputDTO
   */
  defaultValue?: string;
  /**
   *
   * @type {number}
   * @memberof CommandArgumentOutputDTO
   */
  position: number;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof CommandArgumentOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof CommandArgumentOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface CommandArgumentUpdateDTO
 */
export interface CommandArgumentUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof CommandArgumentUpdateDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentUpdateDTO
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentUpdateDTO
   */
  helpText?: string;
  /**
   *
   * @type {string}
   * @memberof CommandArgumentUpdateDTO
   */
  defaultValue?: string;
}
/**
 *
 * @export
 * @interface CommandCreateDTO
 */
export interface CommandCreateDTO {
  /**
   *
   * @type {string}
   * @memberof CommandCreateDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CommandCreateDTO
   */
  trigger: string;
  /**
   *
   * @type {string}
   * @memberof CommandCreateDTO
   */
  helpText?: string;
  /**
   *
   * @type {string}
   * @memberof CommandCreateDTO
   */
  moduleId: string;
  /**
   *
   * @type {string}
   * @memberof CommandCreateDTO
   */
  function?: string;
  /**
   *
   * @type {Array<CommandArgumentCreateDTO>}
   * @memberof CommandCreateDTO
   */
  arguments?: Array<CommandArgumentCreateDTO>;
}
/**
 *
 * @export
 * @interface CommandExecuteDTOAPI
 */
export interface CommandExecuteDTOAPI {
  /**
   *
   * @type {CommandOutput}
   * @memberof CommandExecuteDTOAPI
   */
  data: CommandOutput;
  /**
   *
   * @type {MetadataOutput}
   * @memberof CommandExecuteDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface CommandExecuteInputDTO
 */
export interface CommandExecuteInputDTO {
  /**
   *
   * @type {string}
   * @memberof CommandExecuteInputDTO
   */
  command: string;
}
/**
 *
 * @export
 * @interface CommandOutput
 */
export interface CommandOutput {
  /**
   *
   * @type {string}
   * @memberof CommandOutput
   */
  rawResult: string;
  /**
   *
   * @type {boolean}
   * @memberof CommandOutput
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof CommandOutput
   */
  errorMessage?: string;
}
/**
 *
 * @export
 * @interface CommandOutputArrayDTOAPI
 */
export interface CommandOutputArrayDTOAPI {
  /**
   *
   * @type {Array<CommandOutputDTO>}
   * @memberof CommandOutputArrayDTOAPI
   */
  data: Array<CommandOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof CommandOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface CommandOutputDTO
 */
export interface CommandOutputDTO {
  /**
   *
   * @type {string}
   * @memberof CommandOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CommandOutputDTO
   */
  trigger: string;
  /**
   *
   * @type {string}
   * @memberof CommandOutputDTO
   */
  helpText: string;
  /**
   *
   * @type {FunctionOutputDTO}
   * @memberof CommandOutputDTO
   */
  function: FunctionOutputDTO;
  /**
   *
   * @type {string}
   * @memberof CommandOutputDTO
   */
  functionId: string;
  /**
   *
   * @type {string}
   * @memberof CommandOutputDTO
   */
  moduleId: string;
  /**
   *
   * @type {Array<CommandArgumentOutputDTO>}
   * @memberof CommandOutputDTO
   */
  arguments: Array<CommandArgumentOutputDTO>;
  /**
   *
   * @type {string}
   * @memberof CommandOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof CommandOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof CommandOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface CommandOutputDTOAPI
 */
export interface CommandOutputDTOAPI {
  /**
   *
   * @type {CommandOutputDTO}
   * @memberof CommandOutputDTOAPI
   */
  data: CommandOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof CommandOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface CommandSearchInputAllowedFilters
 */
export interface CommandSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof CommandSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof CommandSearchInputAllowedFilters
   */
  moduleId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof CommandSearchInputAllowedFilters
   */
  name?: Array<string>;
  /**
   *
   * @type {Array<boolean>}
   * @memberof CommandSearchInputAllowedFilters
   */
  enabled?: Array<boolean>;
}
/**
 *
 * @export
 * @interface CommandSearchInputDTO
 */
export interface CommandSearchInputDTO {
  /**
   *
   * @type {CommandSearchInputAllowedFilters}
   * @memberof CommandSearchInputDTO
   */
  filters?: CommandSearchInputAllowedFilters;
  /**
   *
   * @type {CommandSearchInputAllowedFilters}
   * @memberof CommandSearchInputDTO
   */
  search?: CommandSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof CommandSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof CommandSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof CommandSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof CommandSearchInputDTO
   */
  sortDirection?: CommandSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof CommandSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof CommandSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CommandSearchInputDTO
   */
  extend?: Array<string>;
}

export const CommandSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type CommandSearchInputDTOSortDirectionEnum =
  (typeof CommandSearchInputDTOSortDirectionEnum)[keyof typeof CommandSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface CommandTriggerDTO
 */
export interface CommandTriggerDTO {
  /**
   *
   * @type {string}
   * @memberof CommandTriggerDTO
   */
  playerId: string;
  /**
   *
   * @type {string}
   * @memberof CommandTriggerDTO
   */
  msg: string;
}
/**
 *
 * @export
 * @interface CommandUpdateDTO
 */
export interface CommandUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof CommandUpdateDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CommandUpdateDTO
   */
  trigger?: string;
  /**
   *
   * @type {string}
   * @memberof CommandUpdateDTO
   */
  helpText?: string;
  /**
   *
   * @type {string}
   * @memberof CommandUpdateDTO
   */
  function?: string;
  /**
   *
   * @type {Array<CommandArgumentCreateDTO>}
   * @memberof CommandUpdateDTO
   */
  arguments?: Array<CommandArgumentCreateDTO>;
}
/**
 *
 * @export
 * @interface CronJobCreateDTO
 */
export interface CronJobCreateDTO {
  /**
   *
   * @type {string}
   * @memberof CronJobCreateDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CronJobCreateDTO
   */
  temporalValue: string;
  /**
   *
   * @type {string}
   * @memberof CronJobCreateDTO
   */
  moduleId: string;
  /**
   *
   * @type {string}
   * @memberof CronJobCreateDTO
   */
  function?: string;
}
/**
 *
 * @export
 * @interface CronJobOutputArrayDTOAPI
 */
export interface CronJobOutputArrayDTOAPI {
  /**
   *
   * @type {Array<CronJobOutputDTO>}
   * @memberof CronJobOutputArrayDTOAPI
   */
  data: Array<CronJobOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof CronJobOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface CronJobOutputDTO
 */
export interface CronJobOutputDTO {
  /**
   *
   * @type {string}
   * @memberof CronJobOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof CronJobOutputDTO
   */
  temporalValue: string;
  /**
   *
   * @type {FunctionOutputDTO}
   * @memberof CronJobOutputDTO
   */
  function: FunctionOutputDTO;
  /**
   *
   * @type {string}
   * @memberof CronJobOutputDTO
   */
  moduleId: string;
  /**
   *
   * @type {string}
   * @memberof CronJobOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof CronJobOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof CronJobOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface CronJobOutputDTOAPI
 */
export interface CronJobOutputDTOAPI {
  /**
   *
   * @type {CronJobOutputDTO}
   * @memberof CronJobOutputDTOAPI
   */
  data: CronJobOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof CronJobOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface CronJobSearchInputAllowedFilters
 */
export interface CronJobSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof CronJobSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof CronJobSearchInputAllowedFilters
   */
  moduleId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof CronJobSearchInputAllowedFilters
   */
  name?: Array<string>;
}
/**
 *
 * @export
 * @interface CronJobSearchInputDTO
 */
export interface CronJobSearchInputDTO {
  /**
   *
   * @type {CronJobSearchInputAllowedFilters}
   * @memberof CronJobSearchInputDTO
   */
  filters?: CronJobSearchInputAllowedFilters;
  /**
   *
   * @type {CronJobSearchInputAllowedFilters}
   * @memberof CronJobSearchInputDTO
   */
  search?: CronJobSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof CronJobSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof CronJobSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof CronJobSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof CronJobSearchInputDTO
   */
  sortDirection?: CronJobSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof CronJobSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof CronJobSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof CronJobSearchInputDTO
   */
  extend?: Array<string>;
}

export const CronJobSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type CronJobSearchInputDTOSortDirectionEnum =
  (typeof CronJobSearchInputDTOSortDirectionEnum)[keyof typeof CronJobSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface CronJobTriggerDTO
 */
export interface CronJobTriggerDTO {
  /**
   *
   * @type {string}
   * @memberof CronJobTriggerDTO
   */
  gameServerId: string;
  /**
   *
   * @type {string}
   * @memberof CronJobTriggerDTO
   */
  cronjobId: string;
  /**
   *
   * @type {string}
   * @memberof CronJobTriggerDTO
   */
  moduleId: string;
}
/**
 *
 * @export
 * @interface CronJobUpdateDTO
 */
export interface CronJobUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof CronJobUpdateDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CronJobUpdateDTO
   */
  temporalValue?: string;
  /**
   *
   * @type {string}
   * @memberof CronJobUpdateDTO
   */
  function?: string;
}
/**
 *
 * @export
 * @interface DiscordInviteOutputDTO
 */
export interface DiscordInviteOutputDTO {
  /**
   *
   * @type {InviteOutputDTO}
   * @memberof DiscordInviteOutputDTO
   */
  data: InviteOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof DiscordInviteOutputDTO
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface DiscordParamId
 */
export interface DiscordParamId {
  /**
   *
   * @type {string}
   * @memberof DiscordParamId
   */
  id: string;
}
/**
 *
 * @export
 * @interface DomainCreateInputDTO
 */
export interface DomainCreateInputDTO {
  /**
   *
   * @type {string}
   * @memberof DomainCreateInputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof DomainCreateInputDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DomainCreateInputDTO
   */
  state?: DomainCreateInputDTOStateEnum;
}

export const DomainCreateInputDTOStateEnum = {
  Active: 'ACTIVE',
  Disabled: 'DISABLED',
  Maintenance: 'MAINTENANCE',
} as const;

export type DomainCreateInputDTOStateEnum =
  (typeof DomainCreateInputDTOStateEnum)[keyof typeof DomainCreateInputDTOStateEnum];

/**
 *
 * @export
 * @interface DomainCreateOutputDTO
 */
export interface DomainCreateOutputDTO {
  /**
   *
   * @type {DomainOutputDTO}
   * @memberof DomainCreateOutputDTO
   */
  createdDomain: DomainOutputDTO;
  /**
   *
   * @type {UserOutputDTO}
   * @memberof DomainCreateOutputDTO
   */
  rootUser: UserOutputDTO;
  /**
   *
   * @type {RoleOutputDTO}
   * @memberof DomainCreateOutputDTO
   */
  rootRole: RoleOutputDTO;
  /**
   *
   * @type {string}
   * @memberof DomainCreateOutputDTO
   */
  password: string;
}
/**
 *
 * @export
 * @interface DomainCreateOutputDTOAPI
 */
export interface DomainCreateOutputDTOAPI {
  /**
   *
   * @type {DomainCreateOutputDTO}
   * @memberof DomainCreateOutputDTOAPI
   */
  data: DomainCreateOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof DomainCreateOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface DomainOutputArrayDTOAPI
 */
export interface DomainOutputArrayDTOAPI {
  /**
   *
   * @type {Array<DomainOutputDTO>}
   * @memberof DomainOutputArrayDTOAPI
   */
  data: Array<DomainOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof DomainOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface DomainOutputDTO
 */
export interface DomainOutputDTO {
  /**
   *
   * @type {string}
   * @memberof DomainOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof DomainOutputDTO
   */
  state: DomainOutputDTOStateEnum;
  /**
   *
   * @type {string}
   * @memberof DomainOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof DomainOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof DomainOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}

export const DomainOutputDTOStateEnum = {
  Active: 'ACTIVE',
  Disabled: 'DISABLED',
  Maintenance: 'MAINTENANCE',
} as const;

export type DomainOutputDTOStateEnum = (typeof DomainOutputDTOStateEnum)[keyof typeof DomainOutputDTOStateEnum];

/**
 *
 * @export
 * @interface DomainOutputDTOAPI
 */
export interface DomainOutputDTOAPI {
  /**
   *
   * @type {DomainOutputDTO}
   * @memberof DomainOutputDTOAPI
   */
  data: DomainOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof DomainOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface DomainSearchInputAllowedFilters
 */
export interface DomainSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSearchInputAllowedFilters
   */
  name?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSearchInputAllowedFilters
   */
  state?: Array<DomainSearchInputAllowedFiltersStateEnum>;
}

export const DomainSearchInputAllowedFiltersStateEnum = {
  Active: 'ACTIVE',
  Disabled: 'DISABLED',
  Maintenance: 'MAINTENANCE',
} as const;

export type DomainSearchInputAllowedFiltersStateEnum =
  (typeof DomainSearchInputAllowedFiltersStateEnum)[keyof typeof DomainSearchInputAllowedFiltersStateEnum];

/**
 *
 * @export
 * @interface DomainSearchInputDTO
 */
export interface DomainSearchInputDTO {
  /**
   *
   * @type {DomainSearchInputAllowedFilters}
   * @memberof DomainSearchInputDTO
   */
  filters?: DomainSearchInputAllowedFilters;
  /**
   *
   * @type {DomainSearchInputAllowedFilters}
   * @memberof DomainSearchInputDTO
   */
  search?: DomainSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof DomainSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof DomainSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof DomainSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof DomainSearchInputDTO
   */
  sortDirection?: DomainSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof DomainSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof DomainSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DomainSearchInputDTO
   */
  extend?: Array<string>;
}

export const DomainSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type DomainSearchInputDTOSortDirectionEnum =
  (typeof DomainSearchInputDTOSortDirectionEnum)[keyof typeof DomainSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface DomainUpdateInputDTO
 */
export interface DomainUpdateInputDTO {
  /**
   *
   * @type {string}
   * @memberof DomainUpdateInputDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof DomainUpdateInputDTO
   */
  state?: DomainUpdateInputDTOStateEnum;
}

export const DomainUpdateInputDTOStateEnum = {
  Active: 'ACTIVE',
  Disabled: 'DISABLED',
  Maintenance: 'MAINTENANCE',
} as const;

export type DomainUpdateInputDTOStateEnum =
  (typeof DomainUpdateInputDTOStateEnum)[keyof typeof DomainUpdateInputDTOStateEnum];

/**
 *
 * @export
 * @interface ErrorOutput
 */
export interface ErrorOutput {
  /**
   *
   * @type {string}
   * @memberof ErrorOutput
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ErrorOutput
   */
  message: string;
  /**
   *
   * @type {string}
   * @memberof ErrorOutput
   */
  details: string;
}
/**
 *
 * @export
 * @interface EventChatMessage
 */
export interface EventChatMessage {
  /**
   *
   * @type {IGamePlayer}
   * @memberof EventChatMessage
   */
  player: IGamePlayer;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof EventChatMessage
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof EventChatMessage
   */
  msg?: string;
}
/**
 *
 * @export
 * @interface EventCreateDTO
 */
export interface EventCreateDTO {
  /**
   *
   * @type {string}
   * @memberof EventCreateDTO
   */
  eventName: EventCreateDTOEventNameEnum;
  /**
   *
   * @type {string}
   * @memberof EventCreateDTO
   */
  moduleId?: string;
  /**
   *
   * @type {string}
   * @memberof EventCreateDTO
   */
  playerId?: string;
  /**
   *
   * @type {string}
   * @memberof EventCreateDTO
   */
  userId?: string;
  /**
   *
   * @type {string}
   * @memberof EventCreateDTO
   */
  gameserverId?: string;
  /**
   *
   * @type {object}
   * @memberof EventCreateDTO
   */
  meta?: object;
}

export const EventCreateDTOEventNameEnum = {
  RoleAssigned: 'role-assigned',
  RoleRemoved: 'role-removed',
  RoleCreated: 'role-created',
  RoleUpdated: 'role-updated',
  RoleDeleted: 'role-deleted',
  CommandExecuted: 'command-executed',
  HookExecuted: 'hook-executed',
  CronjobExecuted: 'cronjob-executed',
  CurrencyAdded: 'currency-added',
  CurrencyDeducted: 'currency-deducted',
  SettingsSet: 'settings-set',
  PlayerNewIpDetected: 'player-new-ip-detected',
  ServerStatusChanged: 'server-status-changed',
  ModuleCreated: 'module-created',
  ModuleUpdated: 'module-updated',
  ModuleDeleted: 'module-deleted',
  ModuleInstalled: 'module-installed',
  ModuleUninstalled: 'module-uninstalled',
  PlayerConnected: 'player-connected',
  PlayerDisconnected: 'player-disconnected',
  ChatMessage: 'chat-message',
  PlayerDeath: 'player-death',
  EntityKilled: 'entity-killed',
} as const;

export type EventCreateDTOEventNameEnum =
  (typeof EventCreateDTOEventNameEnum)[keyof typeof EventCreateDTOEventNameEnum];

/**
 *
 * @export
 * @interface EventDiscordChannel
 */
export interface EventDiscordChannel {
  /**
   *
   * @type {string}
   * @memberof EventDiscordChannel
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof EventDiscordChannel
   */
  name: string;
}
/**
 *
 * @export
 * @interface EventDiscordUser
 */
export interface EventDiscordUser {
  /**
   *
   * @type {string}
   * @memberof EventDiscordUser
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof EventDiscordUser
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof EventDiscordUser
   */
  displayName: string;
  /**
   *
   * @type {boolean}
   * @memberof EventDiscordUser
   */
  isBot: boolean;
  /**
   *
   * @type {boolean}
   * @memberof EventDiscordUser
   */
  isTakaroBot: boolean;
}
/**
 *
 * @export
 * @interface EventEntityKilled
 */
export interface EventEntityKilled {
  /**
   *
   * @type {IGamePlayer}
   * @memberof EventEntityKilled
   */
  player: IGamePlayer;
  /**
   *
   * @type {string}
   * @memberof EventEntityKilled
   */
  entity: string;
  /**
   *
   * @type {string}
   * @memberof EventEntityKilled
   */
  weapon: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof EventEntityKilled
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof EventEntityKilled
   */
  msg?: string;
}
/**
 *
 * @export
 * @interface EventLogLine
 */
export interface EventLogLine {
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof EventLogLine
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof EventLogLine
   */
  msg?: string;
}
/**
 *
 * @export
 * @interface EventOutputArrayDTOAPI
 */
export interface EventOutputArrayDTOAPI {
  /**
   *
   * @type {Array<EventOutputDTO>}
   * @memberof EventOutputArrayDTOAPI
   */
  data: Array<EventOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof EventOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface EventOutputDTO
 */
export interface EventOutputDTO {
  /**
   *
   * @type {string}
   * @memberof EventOutputDTO
   */
  eventName: EventOutputDTOEventNameEnum;
  /**
   *
   * @type {string}
   * @memberof EventOutputDTO
   */
  moduleId?: string;
  /**
   *
   * @type {string}
   * @memberof EventOutputDTO
   */
  playerId?: string;
  /**
   *
   * @type {string}
   * @memberof EventOutputDTO
   */
  userId?: string;
  /**
   *
   * @type {string}
   * @memberof EventOutputDTO
   */
  gameserverId?: string;
  /**
   *
   * @type {EventOutputDTOMeta}
   * @memberof EventOutputDTO
   */
  meta?: EventOutputDTOMeta;
  /**
   *
   * @type {PlayerOutputDTO}
   * @memberof EventOutputDTO
   */
  player?: PlayerOutputDTO;
  /**
   *
   * @type {GameServerOutputDTO}
   * @memberof EventOutputDTO
   */
  gameServer?: GameServerOutputDTO;
  /**
   *
   * @type {ModuleOutputDTO}
   * @memberof EventOutputDTO
   */
  module?: ModuleOutputDTO;
  /**
   *
   * @type {UserOutputDTO}
   * @memberof EventOutputDTO
   */
  user?: UserOutputDTO;
  /**
   *
   * @type {string}
   * @memberof EventOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof EventOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof EventOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}

export const EventOutputDTOEventNameEnum = {
  RoleAssigned: 'role-assigned',
  RoleRemoved: 'role-removed',
  RoleCreated: 'role-created',
  RoleUpdated: 'role-updated',
  RoleDeleted: 'role-deleted',
  CommandExecuted: 'command-executed',
  HookExecuted: 'hook-executed',
  CronjobExecuted: 'cronjob-executed',
  CurrencyAdded: 'currency-added',
  CurrencyDeducted: 'currency-deducted',
  SettingsSet: 'settings-set',
  PlayerNewIpDetected: 'player-new-ip-detected',
  ServerStatusChanged: 'server-status-changed',
  ModuleCreated: 'module-created',
  ModuleUpdated: 'module-updated',
  ModuleDeleted: 'module-deleted',
  ModuleInstalled: 'module-installed',
  ModuleUninstalled: 'module-uninstalled',
  PlayerConnected: 'player-connected',
  PlayerDisconnected: 'player-disconnected',
  ChatMessage: 'chat-message',
  PlayerDeath: 'player-death',
  EntityKilled: 'entity-killed',
} as const;

export type EventOutputDTOEventNameEnum =
  (typeof EventOutputDTOEventNameEnum)[keyof typeof EventOutputDTOEventNameEnum];

/**
 * @type EventOutputDTOMeta
 * @export
 */
export type EventOutputDTOMeta =
  | EventChatMessage
  | EventEntityKilled
  | EventLogLine
  | EventPlayerConnected
  | EventPlayerDeath
  | EventPlayerDisconnected
  | HookEventDiscordMessage
  | TakaroEventCommandExecuted
  | TakaroEventCronjobExecuted
  | TakaroEventCurrencyAdded
  | TakaroEventCurrencyDeducted
  | TakaroEventHookExecuted
  | TakaroEventModuleCreated
  | TakaroEventModuleDeleted
  | TakaroEventModuleInstalled
  | TakaroEventModuleUninstalled
  | TakaroEventModuleUpdated
  | TakaroEventPlayerNewIpDetected
  | TakaroEventRoleAssigned
  | TakaroEventRoleCreated
  | TakaroEventRoleDeleted
  | TakaroEventRoleRemoved
  | TakaroEventRoleUpdated
  | TakaroEventServerStatusChanged
  | TakaroEventSettingsSet;

/**
 *
 * @export
 * @interface EventPlayerConnected
 */
export interface EventPlayerConnected {
  /**
   *
   * @type {IGamePlayer}
   * @memberof EventPlayerConnected
   */
  player: IGamePlayer;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof EventPlayerConnected
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof EventPlayerConnected
   */
  msg?: string;
}
/**
 *
 * @export
 * @interface EventPlayerDeath
 */
export interface EventPlayerDeath {
  /**
   *
   * @type {IGamePlayer}
   * @memberof EventPlayerDeath
   */
  player: IGamePlayer;
  /**
   *
   * @type {IGamePlayer}
   * @memberof EventPlayerDeath
   */
  attacker?: IGamePlayer;
  /**
   *
   * @type {IPosition}
   * @memberof EventPlayerDeath
   */
  position?: IPosition;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof EventPlayerDeath
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof EventPlayerDeath
   */
  msg?: string;
}
/**
 *
 * @export
 * @interface EventPlayerDisconnected
 */
export interface EventPlayerDisconnected {
  /**
   *
   * @type {IGamePlayer}
   * @memberof EventPlayerDisconnected
   */
  player: IGamePlayer;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof EventPlayerDisconnected
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof EventPlayerDisconnected
   */
  msg?: string;
}
/**
 *
 * @export
 * @interface EventSearchInputAllowedFilters
 */
export interface EventSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof EventSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof EventSearchInputAllowedFilters
   */
  eventName?: Array<EventSearchInputAllowedFiltersEventNameEnum>;
  /**
   *
   * @type {Array<string>}
   * @memberof EventSearchInputAllowedFilters
   */
  moduleId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof EventSearchInputAllowedFilters
   */
  playerId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof EventSearchInputAllowedFilters
   */
  gameserverId?: Array<string>;
}

export const EventSearchInputAllowedFiltersEventNameEnum = {
  RoleAssigned: 'role-assigned',
  RoleRemoved: 'role-removed',
  RoleCreated: 'role-created',
  RoleUpdated: 'role-updated',
  RoleDeleted: 'role-deleted',
  CommandExecuted: 'command-executed',
  HookExecuted: 'hook-executed',
  CronjobExecuted: 'cronjob-executed',
  CurrencyAdded: 'currency-added',
  CurrencyDeducted: 'currency-deducted',
  SettingsSet: 'settings-set',
  PlayerNewIpDetected: 'player-new-ip-detected',
  ServerStatusChanged: 'server-status-changed',
  ModuleCreated: 'module-created',
  ModuleUpdated: 'module-updated',
  ModuleDeleted: 'module-deleted',
  ModuleInstalled: 'module-installed',
  ModuleUninstalled: 'module-uninstalled',
  PlayerConnected: 'player-connected',
  PlayerDisconnected: 'player-disconnected',
  ChatMessage: 'chat-message',
  PlayerDeath: 'player-death',
  EntityKilled: 'entity-killed',
} as const;

export type EventSearchInputAllowedFiltersEventNameEnum =
  (typeof EventSearchInputAllowedFiltersEventNameEnum)[keyof typeof EventSearchInputAllowedFiltersEventNameEnum];

/**
 *
 * @export
 * @interface EventSearchInputDTO
 */
export interface EventSearchInputDTO {
  /**
   *
   * @type {EventSearchInputAllowedFilters}
   * @memberof EventSearchInputDTO
   */
  filters?: EventSearchInputAllowedFilters;
  /**
   *
   * @type {EventSearchInputAllowedFilters}
   * @memberof EventSearchInputDTO
   */
  search?: EventSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof EventSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof EventSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof EventSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof EventSearchInputDTO
   */
  sortDirection?: EventSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof EventSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof EventSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof EventSearchInputDTO
   */
  extend?: Array<string>;
}

export const EventSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type EventSearchInputDTOSortDirectionEnum =
  (typeof EventSearchInputDTOSortDirectionEnum)[keyof typeof EventSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface FunctionCreateDTO
 */
export interface FunctionCreateDTO {
  /**
   *
   * @type {string}
   * @memberof FunctionCreateDTO
   */
  code?: string;
}
/**
 *
 * @export
 * @interface FunctionOutputArrayDTOAPI
 */
export interface FunctionOutputArrayDTOAPI {
  /**
   *
   * @type {Array<FunctionOutputDTO>}
   * @memberof FunctionOutputArrayDTOAPI
   */
  data: Array<FunctionOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof FunctionOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface FunctionOutputDTO
 */
export interface FunctionOutputDTO {
  /**
   *
   * @type {string}
   * @memberof FunctionOutputDTO
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof FunctionOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof FunctionOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof FunctionOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface FunctionOutputDTOAPI
 */
export interface FunctionOutputDTOAPI {
  /**
   *
   * @type {FunctionOutputDTO}
   * @memberof FunctionOutputDTOAPI
   */
  data: FunctionOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof FunctionOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface FunctionSearchInputAllowedFilters
 */
export interface FunctionSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof FunctionSearchInputAllowedFilters
   */
  id: Array<string>;
}
/**
 *
 * @export
 * @interface FunctionSearchInputDTO
 */
export interface FunctionSearchInputDTO {
  /**
   *
   * @type {FunctionSearchInputAllowedFilters}
   * @memberof FunctionSearchInputDTO
   */
  filters?: FunctionSearchInputAllowedFilters;
  /**
   *
   * @type {FunctionSearchInputAllowedFilters}
   * @memberof FunctionSearchInputDTO
   */
  search?: FunctionSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof FunctionSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof FunctionSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof FunctionSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionSearchInputDTO
   */
  sortDirection?: FunctionSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof FunctionSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof FunctionSearchInputDTO
   */
  extend?: Array<string>;
}

export const FunctionSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type FunctionSearchInputDTOSortDirectionEnum =
  (typeof FunctionSearchInputDTOSortDirectionEnum)[keyof typeof FunctionSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface FunctionUpdateDTO
 */
export interface FunctionUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof FunctionUpdateDTO
   */
  code: string;
}
/**
 *
 * @export
 * @interface GameServerCreateDTO
 */
export interface GameServerCreateDTO {
  /**
   *
   * @type {string}
   * @memberof GameServerCreateDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GameServerCreateDTO
   */
  connectionInfo: string;
  /**
   *
   * @type {string}
   * @memberof GameServerCreateDTO
   */
  type: GameServerCreateDTOTypeEnum;
}

export const GameServerCreateDTOTypeEnum = {
  Mock: 'MOCK',
  Sevendaystodie: 'SEVENDAYSTODIE',
  Rust: 'RUST',
} as const;

export type GameServerCreateDTOTypeEnum =
  (typeof GameServerCreateDTOTypeEnum)[keyof typeof GameServerCreateDTOTypeEnum];

/**
 *
 * @export
 * @interface GameServerOutputArrayDTOAPI
 */
export interface GameServerOutputArrayDTOAPI {
  /**
   *
   * @type {Array<GameServerOutputDTO>}
   * @memberof GameServerOutputArrayDTOAPI
   */
  data: Array<GameServerOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof GameServerOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface GameServerOutputDTO
 */
export interface GameServerOutputDTO {
  /**
   *
   * @type {string}
   * @memberof GameServerOutputDTO
   */
  name: string;
  /**
   *
   * @type {object}
   * @memberof GameServerOutputDTO
   */
  connectionInfo: object;
  /**
   *
   * @type {string}
   * @memberof GameServerOutputDTO
   */
  type: GameServerOutputDTOTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof GameServerOutputDTO
   */
  reachable: boolean;
  /**
   *
   * @type {string}
   * @memberof GameServerOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof GameServerOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof GameServerOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}

export const GameServerOutputDTOTypeEnum = {
  Mock: 'MOCK',
  Sevendaystodie: 'SEVENDAYSTODIE',
  Rust: 'RUST',
} as const;

export type GameServerOutputDTOTypeEnum =
  (typeof GameServerOutputDTOTypeEnum)[keyof typeof GameServerOutputDTOTypeEnum];

/**
 *
 * @export
 * @interface GameServerOutputDTOAPI
 */
export interface GameServerOutputDTOAPI {
  /**
   *
   * @type {GameServerOutputDTO}
   * @memberof GameServerOutputDTOAPI
   */
  data: GameServerOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof GameServerOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface GameServerSearchInputAllowedFilters
 */
export interface GameServerSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof GameServerSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof GameServerSearchInputAllowedFilters
   */
  name?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof GameServerSearchInputAllowedFilters
   */
  type?: Array<GameServerSearchInputAllowedFiltersTypeEnum>;
}

export const GameServerSearchInputAllowedFiltersTypeEnum = {
  Mock: 'MOCK',
  Sevendaystodie: 'SEVENDAYSTODIE',
  Rust: 'RUST',
} as const;

export type GameServerSearchInputAllowedFiltersTypeEnum =
  (typeof GameServerSearchInputAllowedFiltersTypeEnum)[keyof typeof GameServerSearchInputAllowedFiltersTypeEnum];

/**
 *
 * @export
 * @interface GameServerSearchInputDTO
 */
export interface GameServerSearchInputDTO {
  /**
   *
   * @type {GameServerSearchInputAllowedFilters}
   * @memberof GameServerSearchInputDTO
   */
  filters?: GameServerSearchInputAllowedFilters;
  /**
   *
   * @type {GameServerSearchInputAllowedFilters}
   * @memberof GameServerSearchInputDTO
   */
  search?: GameServerSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof GameServerSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof GameServerSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof GameServerSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof GameServerSearchInputDTO
   */
  sortDirection?: GameServerSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof GameServerSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof GameServerSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GameServerSearchInputDTO
   */
  extend?: Array<string>;
}

export const GameServerSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type GameServerSearchInputDTOSortDirectionEnum =
  (typeof GameServerSearchInputDTOSortDirectionEnum)[keyof typeof GameServerSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface GameServerTestReachabilityDTOAPI
 */
export interface GameServerTestReachabilityDTOAPI {
  /**
   *
   * @type {TestReachabilityOutputDTO}
   * @memberof GameServerTestReachabilityDTOAPI
   */
  data: TestReachabilityOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof GameServerTestReachabilityDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface GameServerTestReachabilityInputDTO
 */
export interface GameServerTestReachabilityInputDTO {
  /**
   *
   * @type {string}
   * @memberof GameServerTestReachabilityInputDTO
   */
  connectionInfo: string;
  /**
   *
   * @type {string}
   * @memberof GameServerTestReachabilityInputDTO
   */
  type: GameServerTestReachabilityInputDTOTypeEnum;
}

export const GameServerTestReachabilityInputDTOTypeEnum = {
  Mock: 'MOCK',
  Sevendaystodie: 'SEVENDAYSTODIE',
  Rust: 'RUST',
} as const;

export type GameServerTestReachabilityInputDTOTypeEnum =
  (typeof GameServerTestReachabilityInputDTOTypeEnum)[keyof typeof GameServerTestReachabilityInputDTOTypeEnum];

/**
 *
 * @export
 * @interface GameServerTypesOutputDTO
 */
export interface GameServerTypesOutputDTO {
  /**
   *
   * @type {string}
   * @memberof GameServerTypesOutputDTO
   */
  type: GameServerTypesOutputDTOTypeEnum;
  /**
   *
   * @type {string}
   * @memberof GameServerTypesOutputDTO
   */
  connectionInfoSchema: string;
}

export const GameServerTypesOutputDTOTypeEnum = {
  Mock: 'MOCK',
  Sevendaystodie: 'SEVENDAYSTODIE',
  Rust: 'RUST',
} as const;

export type GameServerTypesOutputDTOTypeEnum =
  (typeof GameServerTypesOutputDTOTypeEnum)[keyof typeof GameServerTypesOutputDTOTypeEnum];

/**
 *
 * @export
 * @interface GameServerTypesOutputDTOAPI
 */
export interface GameServerTypesOutputDTOAPI {
  /**
   *
   * @type {Array<GameServerOutputDTO>}
   * @memberof GameServerTypesOutputDTOAPI
   */
  data: Array<GameServerOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof GameServerTypesOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface GameServerUpdateDTO
 */
export interface GameServerUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof GameServerUpdateDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GameServerUpdateDTO
   */
  connectionInfo: string;
  /**
   *
   * @type {string}
   * @memberof GameServerUpdateDTO
   */
  type: GameServerUpdateDTOTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof GameServerUpdateDTO
   */
  reachable?: boolean;
}

export const GameServerUpdateDTOTypeEnum = {
  Mock: 'MOCK',
  Sevendaystodie: 'SEVENDAYSTODIE',
  Rust: 'RUST',
} as const;

export type GameServerUpdateDTOTypeEnum =
  (typeof GameServerUpdateDTOTypeEnum)[keyof typeof GameServerUpdateDTOTypeEnum];

/**
 *
 * @export
 * @interface GetSettingsInput
 */
export interface GetSettingsInput {
  /**
   *
   * @type {Array<string>}
   * @memberof GetSettingsInput
   */
  keys?: Array<GetSettingsInputKeysEnum>;
  /**
   *
   * @type {string}
   * @memberof GetSettingsInput
   */
  gameServerId?: string;
}

export const GetSettingsInputKeysEnum = {
  CommandPrefix: 'commandPrefix',
  ServerChatName: 'serverChatName',
  EconomyEnabled: 'economyEnabled',
  CurrencyName: 'currencyName',
} as const;

export type GetSettingsInputKeysEnum = (typeof GetSettingsInputKeysEnum)[keyof typeof GetSettingsInputKeysEnum];

/**
 *
 * @export
 * @interface GetSettingsOneInput
 */
export interface GetSettingsOneInput {
  /**
   *
   * @type {string}
   * @memberof GetSettingsOneInput
   */
  gameServerId?: string;
}
/**
 *
 * @export
 * @interface GetUserDTO
 */
export interface GetUserDTO {
  /**
   *
   * @type {string}
   * @memberof GetUserDTO
   */
  name: string;
}
/**
 *
 * @export
 * @interface GiveItemInputDTO
 */
export interface GiveItemInputDTO {
  /**
   *
   * @type {string}
   * @memberof GiveItemInputDTO
   */
  name: string;
  /**
   *
   * @type {number}
   * @memberof GiveItemInputDTO
   */
  amount: number;
}
/**
 *
 * @export
 * @interface GuildApiUpdateDTO
 */
export interface GuildApiUpdateDTO {
  /**
   *
   * @type {boolean}
   * @memberof GuildApiUpdateDTO
   */
  takaroEnabled?: boolean;
}
/**
 *
 * @export
 * @interface GuildCreateInputDTO
 */
export interface GuildCreateInputDTO {
  /**
   *
   * @type {string}
   * @memberof GuildCreateInputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GuildCreateInputDTO
   */
  discordId: string;
  /**
   *
   * @type {string}
   * @memberof GuildCreateInputDTO
   */
  icon?: string;
}
/**
 *
 * @export
 * @interface GuildOutputArrayDTOAPI
 */
export interface GuildOutputArrayDTOAPI {
  /**
   *
   * @type {Array<GuildOutputDTO>}
   * @memberof GuildOutputArrayDTOAPI
   */
  data: Array<GuildOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof GuildOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface GuildOutputDTO
 */
export interface GuildOutputDTO {
  /**
   *
   * @type {string}
   * @memberof GuildOutputDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof GuildOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof GuildOutputDTO
   */
  discordId: string;
  /**
   *
   * @type {boolean}
   * @memberof GuildOutputDTO
   */
  takaroEnabled: boolean;
  /**
   *
   * @type {string}
   * @memberof GuildOutputDTO
   */
  icon?: string;
}
/**
 *
 * @export
 * @interface GuildOutputDTOAPI
 */
export interface GuildOutputDTOAPI {
  /**
   *
   * @type {GuildOutputDTO}
   * @memberof GuildOutputDTOAPI
   */
  data: GuildOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof GuildOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface GuildSearchInputAllowedFilters
 */
export interface GuildSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof GuildSearchInputAllowedFilters
   */
  name?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof GuildSearchInputAllowedFilters
   */
  discordId?: Array<string>;
  /**
   *
   * @type {Array<boolean>}
   * @memberof GuildSearchInputAllowedFilters
   */
  takaroEnabled?: Array<boolean>;
}
/**
 *
 * @export
 * @interface GuildSearchInputDTO
 */
export interface GuildSearchInputDTO {
  /**
   *
   * @type {GuildSearchInputAllowedFilters}
   * @memberof GuildSearchInputDTO
   */
  filters?: GuildSearchInputAllowedFilters;
  /**
   *
   * @type {GuildSearchInputAllowedFilters}
   * @memberof GuildSearchInputDTO
   */
  search?: GuildSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof GuildSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof GuildSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof GuildSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof GuildSearchInputDTO
   */
  sortDirection?: GuildSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof GuildSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof GuildSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GuildSearchInputDTO
   */
  extend?: Array<string>;
}

export const GuildSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type GuildSearchInputDTOSortDirectionEnum =
  (typeof GuildSearchInputDTOSortDirectionEnum)[keyof typeof GuildSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface GuildUpdateDTO
 */
export interface GuildUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof GuildUpdateDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof GuildUpdateDTO
   */
  icon?: string;
  /**
   *
   * @type {boolean}
   * @memberof GuildUpdateDTO
   */
  takaroEnabled?: boolean;
}
/**
 *
 * @export
 * @interface HealthOutputDTO
 */
export interface HealthOutputDTO {
  /**
   *
   * @type {boolean}
   * @memberof HealthOutputDTO
   */
  healthy: boolean;
}
/**
 *
 * @export
 * @interface HookCreateDTO
 */
export interface HookCreateDTO {
  /**
   *
   * @type {string}
   * @memberof HookCreateDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof HookCreateDTO
   */
  regex: string;
  /**
   *
   * @type {string}
   * @memberof HookCreateDTO
   */
  moduleId: string;
  /**
   *
   * @type {string}
   * @memberof HookCreateDTO
   */
  eventType: HookCreateDTOEventTypeEnum;
  /**
   *
   * @type {string}
   * @memberof HookCreateDTO
   */
  function?: string;
  /**
   *
   * @type {string}
   * @memberof HookCreateDTO
   */
  discordChannelId?: string;
}

export const HookCreateDTOEventTypeEnum = {
  Log: 'log',
  PlayerConnected: 'player-connected',
  PlayerDisconnected: 'player-disconnected',
  ChatMessage: 'chat-message',
  PlayerDeath: 'player-death',
  EntityKilled: 'entity-killed',
  DiscordMessage: 'discord-message',
  RoleAssigned: 'role-assigned',
  RoleRemoved: 'role-removed',
  RoleCreated: 'role-created',
  RoleUpdated: 'role-updated',
  RoleDeleted: 'role-deleted',
  CommandExecuted: 'command-executed',
  HookExecuted: 'hook-executed',
  CronjobExecuted: 'cronjob-executed',
  CurrencyAdded: 'currency-added',
  CurrencyDeducted: 'currency-deducted',
  SettingsSet: 'settings-set',
  PlayerNewIpDetected: 'player-new-ip-detected',
  ServerStatusChanged: 'server-status-changed',
  ModuleCreated: 'module-created',
  ModuleUpdated: 'module-updated',
  ModuleDeleted: 'module-deleted',
  ModuleInstalled: 'module-installed',
  ModuleUninstalled: 'module-uninstalled',
} as const;

export type HookCreateDTOEventTypeEnum = (typeof HookCreateDTOEventTypeEnum)[keyof typeof HookCreateDTOEventTypeEnum];

/**
 *
 * @export
 * @interface HookEventDiscordMessage
 */
export interface HookEventDiscordMessage {
  /**
   *
   * @type {string}
   * @memberof HookEventDiscordMessage
   */
  msg: string;
  /**
   *
   * @type {EventDiscordUser}
   * @memberof HookEventDiscordMessage
   */
  author: EventDiscordUser;
  /**
   *
   * @type {EventDiscordChannel}
   * @memberof HookEventDiscordMessage
   */
  channel: EventDiscordChannel;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof HookEventDiscordMessage
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface HookOutputArrayDTOAPI
 */
export interface HookOutputArrayDTOAPI {
  /**
   *
   * @type {Array<HookOutputDTO>}
   * @memberof HookOutputArrayDTOAPI
   */
  data: Array<HookOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof HookOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface HookOutputDTO
 */
export interface HookOutputDTO {
  /**
   *
   * @type {string}
   * @memberof HookOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof HookOutputDTO
   */
  regex: string;
  /**
   *
   * @type {FunctionOutputDTO}
   * @memberof HookOutputDTO
   */
  function: FunctionOutputDTO;
  /**
   *
   * @type {string}
   * @memberof HookOutputDTO
   */
  eventType: HookOutputDTOEventTypeEnum;
  /**
   *
   * @type {string}
   * @memberof HookOutputDTO
   */
  moduleId: string;
  /**
   *
   * @type {string}
   * @memberof HookOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof HookOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof HookOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}

export const HookOutputDTOEventTypeEnum = {
  Log: 'log',
  PlayerConnected: 'player-connected',
  PlayerDisconnected: 'player-disconnected',
  ChatMessage: 'chat-message',
  PlayerDeath: 'player-death',
  EntityKilled: 'entity-killed',
  DiscordMessage: 'discord-message',
  RoleAssigned: 'role-assigned',
  RoleRemoved: 'role-removed',
  RoleCreated: 'role-created',
  RoleUpdated: 'role-updated',
  RoleDeleted: 'role-deleted',
  CommandExecuted: 'command-executed',
  HookExecuted: 'hook-executed',
  CronjobExecuted: 'cronjob-executed',
  CurrencyAdded: 'currency-added',
  CurrencyDeducted: 'currency-deducted',
  SettingsSet: 'settings-set',
  PlayerNewIpDetected: 'player-new-ip-detected',
  ServerStatusChanged: 'server-status-changed',
  ModuleCreated: 'module-created',
  ModuleUpdated: 'module-updated',
  ModuleDeleted: 'module-deleted',
  ModuleInstalled: 'module-installed',
  ModuleUninstalled: 'module-uninstalled',
} as const;

export type HookOutputDTOEventTypeEnum = (typeof HookOutputDTOEventTypeEnum)[keyof typeof HookOutputDTOEventTypeEnum];

/**
 *
 * @export
 * @interface HookOutputDTOAPI
 */
export interface HookOutputDTOAPI {
  /**
   *
   * @type {HookOutputDTO}
   * @memberof HookOutputDTOAPI
   */
  data: HookOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof HookOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface HookSearchInputAllowedFilters
 */
export interface HookSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof HookSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof HookSearchInputAllowedFilters
   */
  moduleId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof HookSearchInputAllowedFilters
   */
  name?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof HookSearchInputAllowedFilters
   */
  eventType?: Array<HookSearchInputAllowedFiltersEventTypeEnum>;
}

export const HookSearchInputAllowedFiltersEventTypeEnum = {
  Log: 'log',
  PlayerConnected: 'player-connected',
  PlayerDisconnected: 'player-disconnected',
  ChatMessage: 'chat-message',
  PlayerDeath: 'player-death',
  EntityKilled: 'entity-killed',
  DiscordMessage: 'discord-message',
  RoleAssigned: 'role-assigned',
  RoleRemoved: 'role-removed',
  RoleCreated: 'role-created',
  RoleUpdated: 'role-updated',
  RoleDeleted: 'role-deleted',
  CommandExecuted: 'command-executed',
  HookExecuted: 'hook-executed',
  CronjobExecuted: 'cronjob-executed',
  CurrencyAdded: 'currency-added',
  CurrencyDeducted: 'currency-deducted',
  SettingsSet: 'settings-set',
  PlayerNewIpDetected: 'player-new-ip-detected',
  ServerStatusChanged: 'server-status-changed',
  ModuleCreated: 'module-created',
  ModuleUpdated: 'module-updated',
  ModuleDeleted: 'module-deleted',
  ModuleInstalled: 'module-installed',
  ModuleUninstalled: 'module-uninstalled',
} as const;

export type HookSearchInputAllowedFiltersEventTypeEnum =
  (typeof HookSearchInputAllowedFiltersEventTypeEnum)[keyof typeof HookSearchInputAllowedFiltersEventTypeEnum];

/**
 *
 * @export
 * @interface HookSearchInputDTO
 */
export interface HookSearchInputDTO {
  /**
   *
   * @type {HookSearchInputAllowedFilters}
   * @memberof HookSearchInputDTO
   */
  filters?: HookSearchInputAllowedFilters;
  /**
   *
   * @type {HookSearchInputAllowedFilters}
   * @memberof HookSearchInputDTO
   */
  search?: HookSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof HookSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof HookSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof HookSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof HookSearchInputDTO
   */
  sortDirection?: HookSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof HookSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof HookSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof HookSearchInputDTO
   */
  extend?: Array<string>;
}

export const HookSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type HookSearchInputDTOSortDirectionEnum =
  (typeof HookSearchInputDTOSortDirectionEnum)[keyof typeof HookSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface HookTriggerDTO
 */
export interface HookTriggerDTO {
  /**
   *
   * @type {string}
   * @memberof HookTriggerDTO
   */
  gameServerId: string;
  /**
   *
   * @type {string}
   * @memberof HookTriggerDTO
   */
  playerId?: string;
  /**
   *
   * @type {string}
   * @memberof HookTriggerDTO
   */
  moduleId?: string;
  /**
   *
   * @type {string}
   * @memberof HookTriggerDTO
   */
  eventType: HookTriggerDTOEventTypeEnum;
  /**
   *
   * @type {object}
   * @memberof HookTriggerDTO
   */
  eventMeta: object;
}

export const HookTriggerDTOEventTypeEnum = {
  Log: 'log',
  PlayerConnected: 'player-connected',
  PlayerDisconnected: 'player-disconnected',
  ChatMessage: 'chat-message',
  PlayerDeath: 'player-death',
  EntityKilled: 'entity-killed',
  DiscordMessage: 'discord-message',
  RoleAssigned: 'role-assigned',
  RoleRemoved: 'role-removed',
  RoleCreated: 'role-created',
  RoleUpdated: 'role-updated',
  RoleDeleted: 'role-deleted',
  CommandExecuted: 'command-executed',
  HookExecuted: 'hook-executed',
  CronjobExecuted: 'cronjob-executed',
  CurrencyAdded: 'currency-added',
  CurrencyDeducted: 'currency-deducted',
  SettingsSet: 'settings-set',
  PlayerNewIpDetected: 'player-new-ip-detected',
  ServerStatusChanged: 'server-status-changed',
  ModuleCreated: 'module-created',
  ModuleUpdated: 'module-updated',
  ModuleDeleted: 'module-deleted',
  ModuleInstalled: 'module-installed',
  ModuleUninstalled: 'module-uninstalled',
} as const;

export type HookTriggerDTOEventTypeEnum =
  (typeof HookTriggerDTOEventTypeEnum)[keyof typeof HookTriggerDTOEventTypeEnum];

/**
 *
 * @export
 * @interface HookUpdateDTO
 */
export interface HookUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof HookUpdateDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof HookUpdateDTO
   */
  regex?: string;
  /**
   *
   * @type {string}
   * @memberof HookUpdateDTO
   */
  eventType?: HookUpdateDTOEventTypeEnum;
  /**
   *
   * @type {string}
   * @memberof HookUpdateDTO
   */
  function?: string;
  /**
   *
   * @type {string}
   * @memberof HookUpdateDTO
   */
  discordChannelId?: string;
}

export const HookUpdateDTOEventTypeEnum = {
  Log: 'log',
  PlayerConnected: 'player-connected',
  PlayerDisconnected: 'player-disconnected',
  ChatMessage: 'chat-message',
  PlayerDeath: 'player-death',
  EntityKilled: 'entity-killed',
  DiscordMessage: 'discord-message',
  RoleAssigned: 'role-assigned',
  RoleRemoved: 'role-removed',
  RoleCreated: 'role-created',
  RoleUpdated: 'role-updated',
  RoleDeleted: 'role-deleted',
  CommandExecuted: 'command-executed',
  HookExecuted: 'hook-executed',
  CronjobExecuted: 'cronjob-executed',
  CurrencyAdded: 'currency-added',
  CurrencyDeducted: 'currency-deducted',
  SettingsSet: 'settings-set',
  PlayerNewIpDetected: 'player-new-ip-detected',
  ServerStatusChanged: 'server-status-changed',
  ModuleCreated: 'module-created',
  ModuleUpdated: 'module-updated',
  ModuleDeleted: 'module-deleted',
  ModuleInstalled: 'module-installed',
  ModuleUninstalled: 'module-uninstalled',
} as const;

export type HookUpdateDTOEventTypeEnum = (typeof HookUpdateDTOEventTypeEnum)[keyof typeof HookUpdateDTOEventTypeEnum];

/**
 *
 * @export
 * @interface IGamePlayer
 */
export interface IGamePlayer {
  /**
   *
   * @type {string}
   * @memberof IGamePlayer
   */
  gameId: string;
  /**
   *
   * @type {string}
   * @memberof IGamePlayer
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof IGamePlayer
   */
  steamId?: string;
  /**
   *
   * @type {string}
   * @memberof IGamePlayer
   */
  epicOnlineServicesId?: string;
  /**
   *
   * @type {string}
   * @memberof IGamePlayer
   */
  xboxLiveId?: string;
  /**
   *
   * @type {string}
   * @memberof IGamePlayer
   */
  platformId?: string;
  /**
   *
   * @type {string}
   * @memberof IGamePlayer
   */
  ip?: string;
  /**
   *
   * @type {number}
   * @memberof IGamePlayer
   */
  ping?: number;
}
/**
 *
 * @export
 * @interface IItemDTO
 */
export interface IItemDTO {
  /**
   *
   * @type {string}
   * @memberof IItemDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof IItemDTO
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof IItemDTO
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof IItemDTO
   */
  amount?: number;
}
/**
 *
 * @export
 * @interface IMessageOptsDTO
 */
export interface IMessageOptsDTO {
  /**
   *
   * @type {IPlayerReferenceDTO}
   * @memberof IMessageOptsDTO
   */
  recipient: IPlayerReferenceDTO;
}
/**
 *
 * @export
 * @interface IPlayerReferenceDTO
 */
export interface IPlayerReferenceDTO {
  /**
   *
   * @type {string}
   * @memberof IPlayerReferenceDTO
   */
  gameId: string;
}
/**
 *
 * @export
 * @interface IPosition
 */
export interface IPosition {
  /**
   *
   * @type {number}
   * @memberof IPosition
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof IPosition
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof IPosition
   */
  z: number;
}
/**
 *
 * @export
 * @interface ITakaroQuery
 */
export interface ITakaroQuery {
  /**
   *
   * @type {any}
   * @memberof ITakaroQuery
   */
  filters?: any;
  /**
   *
   * @type {any}
   * @memberof ITakaroQuery
   */
  search?: any;
  /**
   *
   * @type {number}
   * @memberof ITakaroQuery
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof ITakaroQuery
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof ITakaroQuery
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof ITakaroQuery
   */
  sortDirection?: ITakaroQuerySortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof ITakaroQuery
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof ITakaroQuery
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ITakaroQuery
   */
  extend?: Array<string>;
}

export const ITakaroQuerySortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type ITakaroQuerySortDirectionEnum =
  (typeof ITakaroQuerySortDirectionEnum)[keyof typeof ITakaroQuerySortDirectionEnum];

/**
 *
 * @export
 * @interface IdUuidDTO
 */
export interface IdUuidDTO {
  /**
   *
   * @type {string}
   * @memberof IdUuidDTO
   */
  id: string;
}
/**
 *
 * @export
 * @interface IdUuidDTOAPI
 */
export interface IdUuidDTOAPI {
  /**
   *
   * @type {IdUuidDTO}
   * @memberof IdUuidDTOAPI
   */
  data: IdUuidDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof IdUuidDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface ImportOutputDTO
 */
export interface ImportOutputDTO {
  /**
   *
   * @type {string}
   * @memberof ImportOutputDTO
   */
  id: string;
}
/**
 *
 * @export
 * @interface ImportOutputDTOAPI
 */
export interface ImportOutputDTOAPI {
  /**
   *
   * @type {ImportOutputDTO}
   * @memberof ImportOutputDTOAPI
   */
  data: ImportOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof ImportOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface InviteCreateDTO
 */
export interface InviteCreateDTO {
  /**
   *
   * @type {string}
   * @memberof InviteCreateDTO
   */
  email: string;
}
/**
 *
 * @export
 * @interface InviteOutputDTO
 */
export interface InviteOutputDTO {
  /**
   *
   * @type {string}
   * @memberof InviteOutputDTO
   */
  botInvite: string;
  /**
   *
   * @type {string}
   * @memberof InviteOutputDTO
   */
  devServer: string;
}
/**
 *
 * @export
 * @interface IpHistoryOutputDTO
 */
export interface IpHistoryOutputDTO {
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof IpHistoryOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof IpHistoryOutputDTO
   */
  ip: string;
  /**
   *
   * @type {string}
   * @memberof IpHistoryOutputDTO
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof IpHistoryOutputDTO
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof IpHistoryOutputDTO
   */
  latitude?: string;
  /**
   *
   * @type {string}
   * @memberof IpHistoryOutputDTO
   */
  longitude?: string;
}
/**
 *
 * @export
 * @interface ItemCreateDTO
 */
export interface ItemCreateDTO {
  /**
   *
   * @type {string}
   * @memberof ItemCreateDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ItemCreateDTO
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ItemCreateDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ItemCreateDTO
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof ItemCreateDTO
   */
  gameserverId: string;
}
/**
 *
 * @export
 * @interface ItemOutputArrayDTOAPI
 */
export interface ItemOutputArrayDTOAPI {
  /**
   *
   * @type {Array<ItemsOutputDTO>}
   * @memberof ItemOutputArrayDTOAPI
   */
  data: Array<ItemsOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof ItemOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface ItemOutputDTOAPI
 */
export interface ItemOutputDTOAPI {
  /**
   *
   * @type {ItemsOutputDTO}
   * @memberof ItemOutputDTOAPI
   */
  data: ItemsOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof ItemOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface ItemSearchInputAllowedFilters
 */
export interface ItemSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof ItemSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ItemSearchInputAllowedFilters
   */
  name?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ItemSearchInputAllowedFilters
   */
  code?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ItemSearchInputAllowedFilters
   */
  gameserverId?: Array<string>;
}
/**
 *
 * @export
 * @interface ItemSearchInputDTO
 */
export interface ItemSearchInputDTO {
  /**
   *
   * @type {ItemSearchInputAllowedFilters}
   * @memberof ItemSearchInputDTO
   */
  filters?: ItemSearchInputAllowedFilters;
  /**
   *
   * @type {ItemSearchInputAllowedFilters}
   * @memberof ItemSearchInputDTO
   */
  search?: ItemSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof ItemSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof ItemSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof ItemSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof ItemSearchInputDTO
   */
  sortDirection?: ItemSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof ItemSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof ItemSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ItemSearchInputDTO
   */
  extend?: Array<string>;
}

export const ItemSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type ItemSearchInputDTOSortDirectionEnum =
  (typeof ItemSearchInputDTOSortDirectionEnum)[keyof typeof ItemSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface ItemUpdateDTO
 */
export interface ItemUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof ItemUpdateDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ItemUpdateDTO
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof ItemUpdateDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ItemUpdateDTO
   */
  icon?: string;
}
/**
 *
 * @export
 * @interface ItemsOutputDTO
 */
export interface ItemsOutputDTO {
  /**
   *
   * @type {string}
   * @memberof ItemsOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ItemsOutputDTO
   */
  code: string;
  /**
   *
   * @type {string}
   * @memberof ItemsOutputDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ItemsOutputDTO
   */
  icon?: string;
  /**
   *
   * @type {string}
   * @memberof ItemsOutputDTO
   */
  gameserverId: string;
  /**
   *
   * @type {string}
   * @memberof ItemsOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof ItemsOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof ItemsOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface KickPlayerInputDTO
 */
export interface KickPlayerInputDTO {
  /**
   *
   * @type {string}
   * @memberof KickPlayerInputDTO
   */
  reason: string;
}
/**
 *
 * @export
 * @interface LoginDTO
 */
export interface LoginDTO {
  /**
   *
   * @type {string}
   * @memberof LoginDTO
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof LoginDTO
   */
  password: string;
}
/**
 *
 * @export
 * @interface LoginOutputDTO
 */
export interface LoginOutputDTO {
  /**
   *
   * @type {string}
   * @memberof LoginOutputDTO
   */
  token: string;
}
/**
 *
 * @export
 * @interface LoginOutputDTOAPI
 */
export interface LoginOutputDTOAPI {
  /**
   *
   * @type {LoginOutputDTO}
   * @memberof LoginOutputDTOAPI
   */
  data: LoginOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof LoginOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface MessageSendInputDTO
 */
export interface MessageSendInputDTO {
  /**
   *
   * @type {string}
   * @memberof MessageSendInputDTO
   */
  message: string;
  /**
   *
   * @type {IMessageOptsDTO}
   * @memberof MessageSendInputDTO
   */
  opts?: IMessageOptsDTO;
}
/**
 *
 * @export
 * @interface MetadataOutput
 */
export interface MetadataOutput {
  /**
   *
   * @type {MetadataOutputServerTime}
   * @memberof MetadataOutput
   */
  serverTime: MetadataOutputServerTime;
  /**
   *
   * @type {ErrorOutput}
   * @memberof MetadataOutput
   */
  error: ErrorOutput;
  /**
   *
   * @type {number}
   * @memberof MetadataOutput
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataOutput
   */
  limit?: number;
  /**
   *
   * @type {number}
   * @memberof MetadataOutput
   */
  total?: number;
}
/**
 * @type MetadataOutputServerTime
 * @export
 */
export type MetadataOutputServerTime = string;

/**
 *
 * @export
 * @interface MockConnectionInfo
 */
export interface MockConnectionInfo {
  /**
   *
   * @type {string}
   * @memberof MockConnectionInfo
   */
  host: string;
  /**
   *
   * @type {string}
   * @memberof MockConnectionInfo
   */
  name: string;
}
/**
 *
 * @export
 * @interface ModuleCreateDTO
 */
export interface ModuleCreateDTO {
  /**
   *
   * @type {string}
   * @memberof ModuleCreateDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ModuleCreateDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleCreateDTO
   */
  configSchema?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleCreateDTO
   */
  uiSchema?: string;
  /**
   *
   * @type {Array<PermissionCreateDTO>}
   * @memberof ModuleCreateDTO
   */
  permissions?: Array<PermissionCreateDTO>;
}
/**
 *
 * @export
 * @interface ModuleCreateInternalDTO
 */
export interface ModuleCreateInternalDTO {
  /**
   *
   * @type {string}
   * @memberof ModuleCreateInternalDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ModuleCreateInternalDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleCreateInternalDTO
   */
  configSchema?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleCreateInternalDTO
   */
  uiSchema?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleCreateInternalDTO
   */
  builtin?: string;
  /**
   *
   * @type {Array<PermissionCreateDTO>}
   * @memberof ModuleCreateInternalDTO
   */
  permissions?: Array<PermissionCreateDTO>;
}
/**
 *
 * @export
 * @interface ModuleInstallDTO
 */
export interface ModuleInstallDTO {
  /**
   *
   * @type {string}
   * @memberof ModuleInstallDTO
   */
  userConfig?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleInstallDTO
   */
  systemConfig?: string;
}
/**
 *
 * @export
 * @interface ModuleInstallationOutputArrayDTOAPI
 */
export interface ModuleInstallationOutputArrayDTOAPI {
  /**
   *
   * @type {Array<ModuleInstallationOutputDTO>}
   * @memberof ModuleInstallationOutputArrayDTOAPI
   */
  data: Array<ModuleInstallationOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof ModuleInstallationOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface ModuleInstallationOutputDTO
 */
export interface ModuleInstallationOutputDTO {
  /**
   *
   * @type {string}
   * @memberof ModuleInstallationOutputDTO
   */
  gameserverId: string;
  /**
   *
   * @type {string}
   * @memberof ModuleInstallationOutputDTO
   */
  moduleId: string;
  /**
   *
   * @type {object}
   * @memberof ModuleInstallationOutputDTO
   */
  userConfig: object;
  /**
   *
   * @type {object}
   * @memberof ModuleInstallationOutputDTO
   */
  systemConfig: object;
  /**
   *
   * @type {string}
   * @memberof ModuleInstallationOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof ModuleInstallationOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof ModuleInstallationOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface ModuleInstallationOutputDTOAPI
 */
export interface ModuleInstallationOutputDTOAPI {
  /**
   *
   * @type {ModuleInstallationOutputDTO}
   * @memberof ModuleInstallationOutputDTOAPI
   */
  data: ModuleInstallationOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof ModuleInstallationOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface ModuleOutputArrayDTOAPI
 */
export interface ModuleOutputArrayDTOAPI {
  /**
   *
   * @type {Array<ModuleOutputDTO>}
   * @memberof ModuleOutputArrayDTOAPI
   */
  data: Array<ModuleOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof ModuleOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface ModuleOutputDTO
 */
export interface ModuleOutputDTO {
  /**
   *
   * @type {string}
   * @memberof ModuleOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof ModuleOutputDTO
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof ModuleOutputDTO
   */
  configSchema: string;
  /**
   *
   * @type {string}
   * @memberof ModuleOutputDTO
   */
  uiSchema: string;
  /**
   *
   * @type {string}
   * @memberof ModuleOutputDTO
   */
  systemConfigSchema: string;
  /**
   *
   * @type {string}
   * @memberof ModuleOutputDTO
   */
  builtin?: string;
  /**
   *
   * @type {Array<CronJobOutputDTO>}
   * @memberof ModuleOutputDTO
   */
  cronJobs: Array<CronJobOutputDTO>;
  /**
   *
   * @type {Array<HookOutputDTO>}
   * @memberof ModuleOutputDTO
   */
  hooks: Array<HookOutputDTO>;
  /**
   *
   * @type {Array<CommandOutputDTO>}
   * @memberof ModuleOutputDTO
   */
  commands: Array<CommandOutputDTO>;
  /**
   *
   * @type {Array<PermissionOutputDTO>}
   * @memberof ModuleOutputDTO
   */
  permissions: Array<PermissionOutputDTO>;
  /**
   *
   * @type {string}
   * @memberof ModuleOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof ModuleOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof ModuleOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface ModuleOutputDTOAPI
 */
export interface ModuleOutputDTOAPI {
  /**
   *
   * @type {ModuleOutputDTO}
   * @memberof ModuleOutputDTOAPI
   */
  data: ModuleOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof ModuleOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface ModuleSearchInputAllowedFilters
 */
export interface ModuleSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof ModuleSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ModuleSearchInputAllowedFilters
   */
  name?: Array<string>;
}
/**
 *
 * @export
 * @interface ModuleSearchInputDTO
 */
export interface ModuleSearchInputDTO {
  /**
   *
   * @type {ModuleSearchInputAllowedFilters}
   * @memberof ModuleSearchInputDTO
   */
  filters?: ModuleSearchInputAllowedFilters;
  /**
   *
   * @type {ModuleSearchInputAllowedFilters}
   * @memberof ModuleSearchInputDTO
   */
  search?: ModuleSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof ModuleSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof ModuleSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof ModuleSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleSearchInputDTO
   */
  sortDirection?: ModuleSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof ModuleSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ModuleSearchInputDTO
   */
  extend?: Array<string>;
}

export const ModuleSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type ModuleSearchInputDTOSortDirectionEnum =
  (typeof ModuleSearchInputDTOSortDirectionEnum)[keyof typeof ModuleSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface ModuleUpdateDTO
 */
export interface ModuleUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof ModuleUpdateDTO
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleUpdateDTO
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleUpdateDTO
   */
  configSchema?: string;
  /**
   *
   * @type {string}
   * @memberof ModuleUpdateDTO
   */
  uiSchema?: string;
  /**
   *
   * @type {Array<PermissionCreateDTO>}
   * @memberof ModuleUpdateDTO
   */
  permissions?: Array<PermissionCreateDTO>;
}
/**
 *
 * @export
 * @interface NOTDOMAINSCOPEDTakaroModelDTO
 */
export interface NOTDOMAINSCOPEDTakaroModelDTO {
  /**
   *
   * @type {string}
   * @memberof NOTDOMAINSCOPEDTakaroModelDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof NOTDOMAINSCOPEDTakaroModelDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof NOTDOMAINSCOPEDTakaroModelDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 * @type NOTDOMAINSCOPEDTakaroModelDTOCreatedAt
 * @export
 */
export type NOTDOMAINSCOPEDTakaroModelDTOCreatedAt = string;

/**
 *
 * @export
 * @enum {string}
 */

export const PERMISSIONS = {
  Root: 'ROOT',
  ManageUsers: 'MANAGE_USERS',
  ReadUsers: 'READ_USERS',
  ManageRoles: 'MANAGE_ROLES',
  ReadRoles: 'READ_ROLES',
  ManageGameservers: 'MANAGE_GAMESERVERS',
  ReadGameservers: 'READ_GAMESERVERS',
  ReadModules: 'READ_MODULES',
  ManageModules: 'MANAGE_MODULES',
  ReadPlayers: 'READ_PLAYERS',
  ManagePlayers: 'MANAGE_PLAYERS',
  ManageSettings: 'MANAGE_SETTINGS',
  ReadSettings: 'READ_SETTINGS',
  ReadVariables: 'READ_VARIABLES',
  ManageVariables: 'MANAGE_VARIABLES',
  ReadEvents: 'READ_EVENTS',
  ManageEvents: 'MANAGE_EVENTS',
  ReadItems: 'READ_ITEMS',
  ManageItems: 'MANAGE_ITEMS',
} as const;

export type PERMISSIONS = (typeof PERMISSIONS)[keyof typeof PERMISSIONS];

/**
 *
 * @export
 * @interface ParamId
 */
export interface ParamId {
  /**
   *
   * @type {string}
   * @memberof ParamId
   */
  id: string;
}
/**
 *
 * @export
 * @interface ParamIdAndModuleId
 */
export interface ParamIdAndModuleId {
  /**
   *
   * @type {string}
   * @memberof ParamIdAndModuleId
   */
  gameServerId: string;
  /**
   *
   * @type {string}
   * @memberof ParamIdAndModuleId
   */
  moduleId: string;
}
/**
 *
 * @export
 * @interface ParamIdAndRoleId
 */
export interface ParamIdAndRoleId {
  /**
   *
   * @type {string}
   * @memberof ParamIdAndRoleId
   */
  roleId: string;
  /**
   *
   * @type {string}
   * @memberof ParamIdAndRoleId
   */
  id: string;
}
/**
 *
 * @export
 * @interface ParamKey
 */
export interface ParamKey {
  /**
   *
   * @type {string}
   * @memberof ParamKey
   */
  key: ParamKeyKeyEnum;
}

export const ParamKeyKeyEnum = {
  CommandPrefix: 'commandPrefix',
  ServerChatName: 'serverChatName',
  EconomyEnabled: 'economyEnabled',
  CurrencyName: 'currencyName',
} as const;

export type ParamKeyKeyEnum = (typeof ParamKeyKeyEnum)[keyof typeof ParamKeyKeyEnum];

/**
 *
 * @export
 * @interface ParamSenderReceiver
 */
export interface ParamSenderReceiver {
  /**
   *
   * @type {string}
   * @memberof ParamSenderReceiver
   */
  gameServerId: string;
  /**
   *
   * @type {string}
   * @memberof ParamSenderReceiver
   */
  sender: string;
  /**
   *
   * @type {string}
   * @memberof ParamSenderReceiver
   */
  receiver: string;
}
/**
 *
 * @export
 * @interface PermissionCreateDTO
 */
export interface PermissionCreateDTO {
  /**
   *
   * @type {string}
   * @memberof PermissionCreateDTO
   */
  permission: string;
  /**
   *
   * @type {string}
   * @memberof PermissionCreateDTO
   */
  friendlyName: string;
  /**
   *
   * @type {string}
   * @memberof PermissionCreateDTO
   */
  description: string;
  /**
   *
   * @type {boolean}
   * @memberof PermissionCreateDTO
   */
  canHaveCount?: boolean;
}
/**
 *
 * @export
 * @interface PermissionInputDTO
 */
export interface PermissionInputDTO {
  /**
   *
   * @type {string}
   * @memberof PermissionInputDTO
   */
  permissionId: string;
  /**
   *
   * @type {number}
   * @memberof PermissionInputDTO
   */
  count?: number;
}
/**
 *
 * @export
 * @interface PermissionModuleDTO
 */
export interface PermissionModuleDTO {
  /**
   *
   * @type {string}
   * @memberof PermissionModuleDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof PermissionModuleDTO
   */
  name: string;
}
/**
 *
 * @export
 * @interface PermissionOnRoleDTO
 */
export interface PermissionOnRoleDTO {
  /**
   *
   * @type {string}
   * @memberof PermissionOnRoleDTO
   */
  permissionId: string;
  /**
   *
   * @type {PermissionOutputDTO}
   * @memberof PermissionOnRoleDTO
   */
  permission: PermissionOutputDTO;
  /**
   *
   * @type {number}
   * @memberof PermissionOnRoleDTO
   */
  count: number;
  /**
   *
   * @type {string}
   * @memberof PermissionOnRoleDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PermissionOnRoleDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PermissionOnRoleDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface PermissionOutputDTO
 */
export interface PermissionOutputDTO {
  /**
   *
   * @type {PermissionModuleDTO}
   * @memberof PermissionOutputDTO
   */
  module?: PermissionModuleDTO;
  /**
   *
   * @type {string}
   * @memberof PermissionOutputDTO
   */
  permission: string;
  /**
   *
   * @type {string}
   * @memberof PermissionOutputDTO
   */
  friendlyName: string;
  /**
   *
   * @type {string}
   * @memberof PermissionOutputDTO
   */
  description: string;
  /**
   *
   * @type {boolean}
   * @memberof PermissionOutputDTO
   */
  canHaveCount?: boolean;
  /**
   *
   * @type {string}
   * @memberof PermissionOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PermissionOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PermissionOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface PermissionOutputDTOAPI
 */
export interface PermissionOutputDTOAPI {
  /**
   *
   * @type {Array<PermissionOutputDTO>}
   * @memberof PermissionOutputDTOAPI
   */
  data: Array<PermissionOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof PermissionOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface PlayerCreateDTO
 */
export interface PlayerCreateDTO {
  /**
   *
   * @type {string}
   * @memberof PlayerCreateDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PlayerCreateDTO
   */
  steamId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerCreateDTO
   */
  xboxLiveId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerCreateDTO
   */
  epicOnlineServicesId?: string;
}
/**
 *
 * @export
 * @interface PlayerOnGameServerCreateDTO
 */
export interface PlayerOnGameServerCreateDTO {
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameServerCreateDTO
   */
  gameServerId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameServerCreateDTO
   */
  playerId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameServerCreateDTO
   */
  gameId: string;
}
/**
 *
 * @export
 * @interface PlayerOnGameServerSearchInputAllowedFilters
 */
export interface PlayerOnGameServerSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerOnGameServerSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerOnGameServerSearchInputAllowedFilters
   */
  gameId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerOnGameServerSearchInputAllowedFilters
   */
  gameServerId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerOnGameServerSearchInputAllowedFilters
   */
  playerId?: Array<string>;
  /**
   *
   * @type {Array<boolean>}
   * @memberof PlayerOnGameServerSearchInputAllowedFilters
   */
  online?: Array<boolean>;
}
/**
 *
 * @export
 * @interface PlayerOnGameServerSearchInputDTO
 */
export interface PlayerOnGameServerSearchInputDTO {
  /**
   *
   * @type {PlayerOnGameServerSearchInputAllowedFilters}
   * @memberof PlayerOnGameServerSearchInputDTO
   */
  filters?: PlayerOnGameServerSearchInputAllowedFilters;
  /**
   *
   * @type {PlayerOnGameServerSearchInputAllowedFilters}
   * @memberof PlayerOnGameServerSearchInputDTO
   */
  search?: PlayerOnGameServerSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameServerSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameServerSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameServerSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameServerSearchInputDTO
   */
  sortDirection?: PlayerOnGameServerSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameServerSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameServerSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerOnGameServerSearchInputDTO
   */
  extend?: Array<string>;
}

export const PlayerOnGameServerSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type PlayerOnGameServerSearchInputDTOSortDirectionEnum =
  (typeof PlayerOnGameServerSearchInputDTOSortDirectionEnum)[keyof typeof PlayerOnGameServerSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface PlayerOnGameServerSetCurrencyInputDTO
 */
export interface PlayerOnGameServerSetCurrencyInputDTO {
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameServerSetCurrencyInputDTO
   */
  currency: number;
}
/**
 *
 * @export
 * @interface PlayerOnGameServerUpdateDTO
 */
export interface PlayerOnGameServerUpdateDTO {
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameServerUpdateDTO
   */
  positionX?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameServerUpdateDTO
   */
  positionY?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameServerUpdateDTO
   */
  positionZ?: number;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameServerUpdateDTO
   */
  ip?: string;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameServerUpdateDTO
   */
  ping?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameServerUpdateDTO
   */
  currency?: number;
  /**
   *
   * @type {boolean}
   * @memberof PlayerOnGameServerUpdateDTO
   */
  online: boolean;
}
/**
 *
 * @export
 * @interface PlayerOnGameserverOutputArrayDTOAPI
 */
export interface PlayerOnGameserverOutputArrayDTOAPI {
  /**
   *
   * @type {Array<PlayerOnGameserverOutputWithRolesDTO>}
   * @memberof PlayerOnGameserverOutputArrayDTOAPI
   */
  data: Array<PlayerOnGameserverOutputWithRolesDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof PlayerOnGameserverOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface PlayerOnGameserverOutputDTO
 */
export interface PlayerOnGameserverOutputDTO {
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputDTO
   */
  gameServerId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputDTO
   */
  playerId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputDTO
   */
  gameId: string;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputDTO
   */
  positionX?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputDTO
   */
  positionY?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputDTO
   */
  positionZ?: number;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputDTO
   */
  ip?: string;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputDTO
   */
  ping?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputDTO
   */
  currency: number;
  /**
   *
   * @type {boolean}
   * @memberof PlayerOnGameserverOutputDTO
   */
  online: boolean;
  /**
   *
   * @type {Array<IItemDTO>}
   * @memberof PlayerOnGameserverOutputDTO
   */
  inventory: Array<IItemDTO>;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOnGameserverOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOnGameserverOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface PlayerOnGameserverOutputDTOAPI
 */
export interface PlayerOnGameserverOutputDTOAPI {
  /**
   *
   * @type {PlayerOnGameserverOutputWithRolesDTO}
   * @memberof PlayerOnGameserverOutputDTOAPI
   */
  data: PlayerOnGameserverOutputWithRolesDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof PlayerOnGameserverOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface PlayerOnGameserverOutputWithRolesDTO
 */
export interface PlayerOnGameserverOutputWithRolesDTO {
  /**
   *
   * @type {Array<PlayerRoleAssignmentOutputDTO>}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  roles: Array<PlayerRoleAssignmentOutputDTO>;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  gameServerId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  playerId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  gameId: string;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  positionX?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  positionY?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  positionZ?: number;
  /**
   *
   * @type {string}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  ip?: string;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  ping?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  currency: number;
  /**
   *
   * @type {boolean}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  online: boolean;
  /**
   *
   * @type {Array<IItemDTO>}
   * @memberof PlayerOnGameserverOutputWithRolesDTO
   */
  inventory: Array<IItemDTO>;
}
/**
 *
 * @export
 * @interface PlayerOutputArrayDTOAPI
 */
export interface PlayerOutputArrayDTOAPI {
  /**
   *
   * @type {Array<PlayerOutputDTO>}
   * @memberof PlayerOutputArrayDTOAPI
   */
  data: Array<PlayerOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof PlayerOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface PlayerOutputDTO
 */
export interface PlayerOutputDTO {
  /**
   *
   * @type {string}
   * @memberof PlayerOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputDTO
   */
  steamId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputDTO
   */
  xboxLiveId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputDTO
   */
  epicOnlineServicesId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputDTO
   */
  steamAvatar?: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOutputDTO
   */
  steamAccountCreated?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {boolean}
   * @memberof PlayerOutputDTO
   */
  steamCommunityBanned?: boolean;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputDTO
   */
  steamEconomyBan?: string;
  /**
   *
   * @type {boolean}
   * @memberof PlayerOutputDTO
   */
  steamVacBanned?: boolean;
  /**
   *
   * @type {number}
   * @memberof PlayerOutputDTO
   */
  steamsDaysSinceLastBan?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOutputDTO
   */
  steamNumberOfVACBans?: number;
  /**
   *
   * @type {Array<PlayerOnGameserverOutputDTO>}
   * @memberof PlayerOutputDTO
   */
  playerOnGameServers?: Array<PlayerOnGameserverOutputDTO>;
  /**
   *
   * @type {Array<IpHistoryOutputDTO>}
   * @memberof PlayerOutputDTO
   */
  ipHistory: Array<IpHistoryOutputDTO>;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface PlayerOutputDTOAPI
 */
export interface PlayerOutputDTOAPI {
  /**
   *
   * @type {PlayerOutputWithRolesDTO}
   * @memberof PlayerOutputDTOAPI
   */
  data: PlayerOutputWithRolesDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof PlayerOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface PlayerOutputWithRolesDTO
 */
export interface PlayerOutputWithRolesDTO {
  /**
   *
   * @type {Array<PlayerRoleAssignmentOutputDTO>}
   * @memberof PlayerOutputWithRolesDTO
   */
  roleAssignments: Array<PlayerRoleAssignmentOutputDTO>;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputWithRolesDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOutputWithRolesDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOutputWithRolesDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputWithRolesDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputWithRolesDTO
   */
  steamId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputWithRolesDTO
   */
  xboxLiveId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputWithRolesDTO
   */
  epicOnlineServicesId?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputWithRolesDTO
   */
  steamAvatar?: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerOutputWithRolesDTO
   */
  steamAccountCreated?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {boolean}
   * @memberof PlayerOutputWithRolesDTO
   */
  steamCommunityBanned?: boolean;
  /**
   *
   * @type {string}
   * @memberof PlayerOutputWithRolesDTO
   */
  steamEconomyBan?: string;
  /**
   *
   * @type {boolean}
   * @memberof PlayerOutputWithRolesDTO
   */
  steamVacBanned?: boolean;
  /**
   *
   * @type {number}
   * @memberof PlayerOutputWithRolesDTO
   */
  steamsDaysSinceLastBan?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerOutputWithRolesDTO
   */
  steamNumberOfVACBans?: number;
  /**
   *
   * @type {Array<PlayerOnGameserverOutputDTO>}
   * @memberof PlayerOutputWithRolesDTO
   */
  playerOnGameServers?: Array<PlayerOnGameserverOutputDTO>;
  /**
   *
   * @type {Array<IpHistoryOutputDTO>}
   * @memberof PlayerOutputWithRolesDTO
   */
  ipHistory: Array<IpHistoryOutputDTO>;
}
/**
 *
 * @export
 * @interface PlayerOutputWithRolesDTOAPI
 */
export interface PlayerOutputWithRolesDTOAPI {
  /**
   *
   * @type {PlayerOutputWithRolesDTO}
   * @memberof PlayerOutputWithRolesDTOAPI
   */
  data: PlayerOutputWithRolesDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof PlayerOutputWithRolesDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface PlayerRoleAssignChangeDTO
 */
export interface PlayerRoleAssignChangeDTO {
  /**
   *
   * @type {string}
   * @memberof PlayerRoleAssignChangeDTO
   */
  gameServerId?: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerRoleAssignChangeDTO
   */
  expiresAt?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface PlayerRoleAssignmentOutputDTO
 */
export interface PlayerRoleAssignmentOutputDTO {
  /**
   *
   * @type {string}
   * @memberof PlayerRoleAssignmentOutputDTO
   */
  playerId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerRoleAssignmentOutputDTO
   */
  roleId: string;
  /**
   *
   * @type {string}
   * @memberof PlayerRoleAssignmentOutputDTO
   */
  gameServerId?: string;
  /**
   *
   * @type {RoleOutputDTO}
   * @memberof PlayerRoleAssignmentOutputDTO
   */
  role: RoleOutputDTO;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerRoleAssignmentOutputDTO
   */
  expiresAt?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof PlayerRoleAssignmentOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerRoleAssignmentOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof PlayerRoleAssignmentOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface PlayerSearchInputAllowedFilters
 */
export interface PlayerSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerSearchInputAllowedFilters
   */
  name?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerSearchInputAllowedFilters
   */
  steamId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerSearchInputAllowedFilters
   */
  epicOnlineServicesId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerSearchInputAllowedFilters
   */
  xboxLiveId?: Array<string>;
  /**
   *
   * @type {Array<boolean>}
   * @memberof PlayerSearchInputAllowedFilters
   */
  steamCommunityBanned?: Array<boolean>;
  /**
   *
   * @type {Array<boolean>}
   * @memberof PlayerSearchInputAllowedFilters
   */
  steamVacBanned?: Array<boolean>;
}
/**
 *
 * @export
 * @interface PlayerSearchInputDTO
 */
export interface PlayerSearchInputDTO {
  /**
   *
   * @type {PlayerSearchInputAllowedFilters}
   * @memberof PlayerSearchInputDTO
   */
  filters?: PlayerSearchInputAllowedFilters;
  /**
   *
   * @type {PlayerSearchInputAllowedFilters}
   * @memberof PlayerSearchInputDTO
   */
  search?: PlayerSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof PlayerSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof PlayerSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof PlayerSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerSearchInputDTO
   */
  sortDirection?: PlayerSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof PlayerSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof PlayerSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof PlayerSearchInputDTO
   */
  extend?: Array<string>;
}

export const PlayerSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type PlayerSearchInputDTOSortDirectionEnum =
  (typeof PlayerSearchInputDTOSortDirectionEnum)[keyof typeof PlayerSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface PlayerUpdateDTO
 */
export interface PlayerUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof PlayerUpdateDTO
   */
  name: string;
}
/**
 *
 * @export
 * @interface PogParam
 */
export interface PogParam {
  /**
   *
   * @type {string}
   * @memberof PogParam
   */
  gameServerId: string;
  /**
   *
   * @type {string}
   * @memberof PogParam
   */
  playerId: string;
}
/**
 *
 * @export
 * @interface RedirectQs
 */
export interface RedirectQs {
  /**
   *
   * @type {string}
   * @memberof RedirectQs
   */
  redirect: string;
}
/**
 *
 * @export
 * @interface RoleCreateInputDTO
 */
export interface RoleCreateInputDTO {
  /**
   *
   * @type {string}
   * @memberof RoleCreateInputDTO
   */
  name: string;
  /**
   *
   * @type {Array<PermissionInputDTO>}
   * @memberof RoleCreateInputDTO
   */
  permissions: Array<PermissionInputDTO>;
}
/**
 *
 * @export
 * @interface RoleOutputArrayDTOAPI
 */
export interface RoleOutputArrayDTOAPI {
  /**
   *
   * @type {Array<RoleOutputDTO>}
   * @memberof RoleOutputArrayDTOAPI
   */
  data: Array<RoleOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof RoleOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface RoleOutputDTO
 */
export interface RoleOutputDTO {
  /**
   *
   * @type {string}
   * @memberof RoleOutputDTO
   */
  name: string;
  /**
   *
   * @type {Array<PermissionOnRoleDTO>}
   * @memberof RoleOutputDTO
   */
  permissions: Array<PermissionOnRoleDTO>;
  /**
   *
   * @type {boolean}
   * @memberof RoleOutputDTO
   */
  system: boolean;
  /**
   *
   * @type {string}
   * @memberof RoleOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof RoleOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof RoleOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface RoleOutputDTOAPI
 */
export interface RoleOutputDTOAPI {
  /**
   *
   * @type {RoleOutputDTO}
   * @memberof RoleOutputDTOAPI
   */
  data: RoleOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof RoleOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface RoleSearchInputAllowedFilters
 */
export interface RoleSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof RoleSearchInputAllowedFilters
   */
  name?: Array<string>;
}
/**
 *
 * @export
 * @interface RoleSearchInputDTO
 */
export interface RoleSearchInputDTO {
  /**
   *
   * @type {RoleSearchInputAllowedFilters}
   * @memberof RoleSearchInputDTO
   */
  filters?: RoleSearchInputAllowedFilters;
  /**
   *
   * @type {RoleSearchInputAllowedFilters}
   * @memberof RoleSearchInputDTO
   */
  search?: RoleSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof RoleSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof RoleSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof RoleSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof RoleSearchInputDTO
   */
  sortDirection?: RoleSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof RoleSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof RoleSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof RoleSearchInputDTO
   */
  extend?: Array<string>;
}

export const RoleSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type RoleSearchInputDTOSortDirectionEnum =
  (typeof RoleSearchInputDTOSortDirectionEnum)[keyof typeof RoleSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface RoleUpdateInputDTO
 */
export interface RoleUpdateInputDTO {
  /**
   *
   * @type {string}
   * @memberof RoleUpdateInputDTO
   */
  name?: string;
  /**
   *
   * @type {Array<PermissionInputDTO>}
   * @memberof RoleUpdateInputDTO
   */
  permissions?: Array<PermissionInputDTO>;
}
/**
 *
 * @export
 * @interface RustConnectionInfo
 */
export interface RustConnectionInfo {
  /**
   *
   * @type {string}
   * @memberof RustConnectionInfo
   */
  host: string;
  /**
   *
   * @type {number}
   * @memberof RustConnectionInfo
   */
  rconPort: number;
  /**
   *
   * @type {string}
   * @memberof RustConnectionInfo
   */
  rconPassword: string;
  /**
   *
   * @type {boolean}
   * @memberof RustConnectionInfo
   */
  useTls: boolean;
}
/**
 *
 * @export
 * @interface SdtdConnectionInfo
 */
export interface SdtdConnectionInfo {
  /**
   *
   * @type {string}
   * @memberof SdtdConnectionInfo
   */
  host: string;
  /**
   *
   * @type {string}
   * @memberof SdtdConnectionInfo
   */
  adminUser: string;
  /**
   *
   * @type {string}
   * @memberof SdtdConnectionInfo
   */
  adminToken: string;
  /**
   *
   * @type {boolean}
   * @memberof SdtdConnectionInfo
   */
  useTls: boolean;
  /**
   *
   * @type {boolean}
   * @memberof SdtdConnectionInfo
   */
  useCPM: boolean;
}
/**
 *
 * @export
 * @interface SearchRoleInputDTO
 */
export interface SearchRoleInputDTO {
  /**
   *
   * @type {string}
   * @memberof SearchRoleInputDTO
   */
  name: string;
}
/**
 *
 * @export
 * @interface SendMessageInputDTO
 */
export interface SendMessageInputDTO {
  /**
   *
   * @type {string}
   * @memberof SendMessageInputDTO
   */
  message: string;
}
/**
 *
 * @export
 * @interface ServiceRoleCreateInputDTO
 */
export interface ServiceRoleCreateInputDTO {
  /**
   *
   * @type {string}
   * @memberof ServiceRoleCreateInputDTO
   */
  name: string;
  /**
   *
   * @type {Array<PermissionInputDTO>}
   * @memberof ServiceRoleCreateInputDTO
   */
  permissions: Array<PermissionInputDTO>;
  /**
   *
   * @type {boolean}
   * @memberof ServiceRoleCreateInputDTO
   */
  system?: boolean;
}
/**
 *
 * @export
 * @interface Settings
 */
export interface Settings {
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  commandPrefix: string;
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  serverChatName: string;
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  economyEnabled: string;
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  currencyName: string;
  /**
   *
   * @type {string}
   * @memberof Settings
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof Settings
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof Settings
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface SettingsOutputArrayDTOAPI
 */
export interface SettingsOutputArrayDTOAPI {
  /**
   *
   * @type {Array<SettingsOutputDTO>}
   * @memberof SettingsOutputArrayDTOAPI
   */
  data: Array<SettingsOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof SettingsOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface SettingsOutputDTO
 */
export interface SettingsOutputDTO {
  /**
   *
   * @type {string}
   * @memberof SettingsOutputDTO
   */
  key: SettingsOutputDTOKeyEnum;
  /**
   *
   * @type {string}
   * @memberof SettingsOutputDTO
   */
  value: string;
  /**
   *
   * @type {string}
   * @memberof SettingsOutputDTO
   */
  type: SettingsOutputDTOTypeEnum;
}

export const SettingsOutputDTOKeyEnum = {
  CommandPrefix: 'commandPrefix',
  ServerChatName: 'serverChatName',
  EconomyEnabled: 'economyEnabled',
  CurrencyName: 'currencyName',
} as const;

export type SettingsOutputDTOKeyEnum = (typeof SettingsOutputDTOKeyEnum)[keyof typeof SettingsOutputDTOKeyEnum];
export const SettingsOutputDTOTypeEnum = {
  Override: 'override',
  Inherit: 'inherit',
  Global: 'global',
  Default: 'default',
} as const;

export type SettingsOutputDTOTypeEnum = (typeof SettingsOutputDTOTypeEnum)[keyof typeof SettingsOutputDTOTypeEnum];

/**
 *
 * @export
 * @interface SettingsOutputDTOAPI
 */
export interface SettingsOutputDTOAPI {
  /**
   *
   * @type {SettingsOutputDTO}
   * @memberof SettingsOutputDTOAPI
   */
  data: SettingsOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof SettingsOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface SettingsSetDTO
 */
export interface SettingsSetDTO {
  /**
   *
   * @type {string}
   * @memberof SettingsSetDTO
   */
  gameServerId?: string;
  /**
   *
   * @type {any}
   * @memberof SettingsSetDTO
   */
  value: any;
}
/**
 *
 * @export
 * @interface TakaroEventCommandDetails
 */
export interface TakaroEventCommandDetails {
  /**
   *
   * @type {string}
   * @memberof TakaroEventCommandDetails
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TakaroEventCommandDetails
   */
  name: string;
  /**
   *
   * @type {object}
   * @memberof TakaroEventCommandDetails
   */
  arguments: object;
}
/**
 *
 * @export
 * @interface TakaroEventCommandExecuted
 */
export interface TakaroEventCommandExecuted {
  /**
   *
   * @type {any}
   * @memberof TakaroEventCommandExecuted
   */
  data: any;
  /**
   *
   * @type {Array<TakaroEventFunctionResult>}
   * @memberof TakaroEventCommandExecuted
   */
  result: Array<TakaroEventFunctionResult>;
  /**
   *
   * @type {TakaroEventCommandDetails}
   * @memberof TakaroEventCommandExecuted
   */
  command?: TakaroEventCommandDetails;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventCommandExecuted
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventCronjobExecuted
 */
export interface TakaroEventCronjobExecuted {
  /**
   *
   * @type {any}
   * @memberof TakaroEventCronjobExecuted
   */
  data: any;
  /**
   *
   * @type {Array<TakaroEventFunctionResult>}
   * @memberof TakaroEventCronjobExecuted
   */
  result: Array<TakaroEventFunctionResult>;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventCronjobExecuted
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventCurrencyAdded
 */
export interface TakaroEventCurrencyAdded {
  /**
   *
   * @type {number}
   * @memberof TakaroEventCurrencyAdded
   */
  amount: number;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventCurrencyAdded
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventCurrencyDeducted
 */
export interface TakaroEventCurrencyDeducted {
  /**
   *
   * @type {number}
   * @memberof TakaroEventCurrencyDeducted
   */
  amount: number;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventCurrencyDeducted
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventFunctionLog
 */
export interface TakaroEventFunctionLog {
  /**
   *
   * @type {string}
   * @memberof TakaroEventFunctionLog
   */
  msg: string;
  /**
   *
   * @type {any}
   * @memberof TakaroEventFunctionLog
   */
  details?: any;
}
/**
 *
 * @export
 * @interface TakaroEventFunctionResult
 */
export interface TakaroEventFunctionResult {
  /**
   *
   * @type {Array<TakaroEventFunctionLog>}
   * @memberof TakaroEventFunctionResult
   */
  logs: Array<TakaroEventFunctionLog>;
  /**
   *
   * @type {boolean}
   * @memberof TakaroEventFunctionResult
   */
  success: boolean;
  /**
   *
   * @type {string}
   * @memberof TakaroEventFunctionResult
   */
  reason?: string;
  /**
   *
   * @type {number}
   * @memberof TakaroEventFunctionResult
   */
  tryAgainIn?: number;
}
/**
 *
 * @export
 * @interface TakaroEventHookExecuted
 */
export interface TakaroEventHookExecuted {
  /**
   *
   * @type {any}
   * @memberof TakaroEventHookExecuted
   */
  data: any;
  /**
   *
   * @type {Array<TakaroEventFunctionResult>}
   * @memberof TakaroEventHookExecuted
   */
  result: Array<TakaroEventFunctionResult>;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventHookExecuted
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventModuleCreated
 */
export interface TakaroEventModuleCreated {
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventModuleCreated
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventModuleDeleted
 */
export interface TakaroEventModuleDeleted {
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventModuleDeleted
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventModuleInstalled
 */
export interface TakaroEventModuleInstalled {
  /**
   *
   * @type {string}
   * @memberof TakaroEventModuleInstalled
   */
  userConfig: string;
  /**
   *
   * @type {string}
   * @memberof TakaroEventModuleInstalled
   */
  systemConfig: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventModuleInstalled
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventModuleUninstalled
 */
export interface TakaroEventModuleUninstalled {
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventModuleUninstalled
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventModuleUpdated
 */
export interface TakaroEventModuleUpdated {
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventModuleUpdated
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventPlayerNewIpDetected
 */
export interface TakaroEventPlayerNewIpDetected {
  /**
   *
   * @type {string}
   * @memberof TakaroEventPlayerNewIpDetected
   */
  country: string;
  /**
   *
   * @type {string}
   * @memberof TakaroEventPlayerNewIpDetected
   */
  city: string;
  /**
   *
   * @type {string}
   * @memberof TakaroEventPlayerNewIpDetected
   */
  longitude: string;
  /**
   *
   * @type {string}
   * @memberof TakaroEventPlayerNewIpDetected
   */
  latitude: string;
  /**
   *
   * @type {string}
   * @memberof TakaroEventPlayerNewIpDetected
   */
  ip: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventPlayerNewIpDetected
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventRoleAssigned
 */
export interface TakaroEventRoleAssigned {
  /**
   *
   * @type {TakaroEventRoleMeta}
   * @memberof TakaroEventRoleAssigned
   */
  role: TakaroEventRoleMeta;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventRoleAssigned
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventRoleCreated
 */
export interface TakaroEventRoleCreated {
  /**
   *
   * @type {TakaroEventRoleMeta}
   * @memberof TakaroEventRoleCreated
   */
  role: TakaroEventRoleMeta;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventRoleCreated
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventRoleDeleted
 */
export interface TakaroEventRoleDeleted {
  /**
   *
   * @type {TakaroEventRoleMeta}
   * @memberof TakaroEventRoleDeleted
   */
  role: TakaroEventRoleMeta;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventRoleDeleted
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventRoleMeta
 */
export interface TakaroEventRoleMeta {
  /**
   *
   * @type {string}
   * @memberof TakaroEventRoleMeta
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof TakaroEventRoleMeta
   */
  name: string;
}
/**
 *
 * @export
 * @interface TakaroEventRoleRemoved
 */
export interface TakaroEventRoleRemoved {
  /**
   *
   * @type {TakaroEventRoleMeta}
   * @memberof TakaroEventRoleRemoved
   */
  role: TakaroEventRoleMeta;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventRoleRemoved
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventRoleUpdated
 */
export interface TakaroEventRoleUpdated {
  /**
   *
   * @type {TakaroEventRoleMeta}
   * @memberof TakaroEventRoleUpdated
   */
  role: TakaroEventRoleMeta;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventRoleUpdated
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventServerStatusChanged
 */
export interface TakaroEventServerStatusChanged {
  /**
   *
   * @type {string}
   * @memberof TakaroEventServerStatusChanged
   */
  status: string;
  /**
   *
   * @type {any}
   * @memberof TakaroEventServerStatusChanged
   */
  details?: any;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventServerStatusChanged
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroEventSettingsSet
 */
export interface TakaroEventSettingsSet {
  /**
   *
   * @type {string}
   * @memberof TakaroEventSettingsSet
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof TakaroEventSettingsSet
   */
  value?: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroEventSettingsSet
   */
  timestamp: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroModelDTO
 */
export interface TakaroModelDTO {
  /**
   *
   * @type {string}
   * @memberof TakaroModelDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroModelDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof TakaroModelDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface TakaroTokenDTO
 */
export interface TakaroTokenDTO {
  /**
   *
   * @type {boolean}
   * @memberof TakaroTokenDTO
   */
  active: boolean;
  /**
   *
   * @type {string}
   * @memberof TakaroTokenDTO
   */
  clientId: string;
  /**
   *
   * @type {number}
   * @memberof TakaroTokenDTO
   */
  exp: number;
  /**
   *
   * @type {number}
   * @memberof TakaroTokenDTO
   */
  iat: number;
  /**
   *
   * @type {string}
   * @memberof TakaroTokenDTO
   */
  iss: string;
  /**
   *
   * @type {string}
   * @memberof TakaroTokenDTO
   */
  sub: string;
  /**
   *
   * @type {Array<string>}
   * @memberof TakaroTokenDTO
   */
  aud: Array<string>;
}
/**
 *
 * @export
 * @interface TeleportPlayerInputDTO
 */
export interface TeleportPlayerInputDTO {
  /**
   *
   * @type {number}
   * @memberof TeleportPlayerInputDTO
   */
  x: number;
  /**
   *
   * @type {number}
   * @memberof TeleportPlayerInputDTO
   */
  y: number;
  /**
   *
   * @type {number}
   * @memberof TeleportPlayerInputDTO
   */
  z: number;
}
/**
 *
 * @export
 * @interface TestReachabilityOutputDTO
 */
export interface TestReachabilityOutputDTO {
  /**
   *
   * @type {boolean}
   * @memberof TestReachabilityOutputDTO
   */
  connectable: boolean;
  /**
   *
   * @type {string}
   * @memberof TestReachabilityOutputDTO
   */
  reason?: string;
}
/**
 *
 * @export
 * @interface TokenInputDTO
 */
export interface TokenInputDTO {
  /**
   *
   * @type {string}
   * @memberof TokenInputDTO
   */
  domainId: string;
}
/**
 *
 * @export
 * @interface TokenOutputDTO
 */
export interface TokenOutputDTO {
  /**
   *
   * @type {string}
   * @memberof TokenOutputDTO
   */
  token: string;
}
/**
 *
 * @export
 * @interface TokenOutputDTOAPI
 */
export interface TokenOutputDTOAPI {
  /**
   *
   * @type {TokenOutputDTO}
   * @memberof TokenOutputDTOAPI
   */
  data: TokenOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof TokenOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface UserAssignmentOutputDTO
 */
export interface UserAssignmentOutputDTO {
  /**
   *
   * @type {string}
   * @memberof UserAssignmentOutputDTO
   */
  userId: string;
  /**
   *
   * @type {string}
   * @memberof UserAssignmentOutputDTO
   */
  roleId: string;
  /**
   *
   * @type {string}
   * @memberof UserAssignmentOutputDTO
   */
  gameServerId?: string;
  /**
   *
   * @type {RoleOutputDTO}
   * @memberof UserAssignmentOutputDTO
   */
  role: RoleOutputDTO;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof UserAssignmentOutputDTO
   */
  expiresAt?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof UserAssignmentOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof UserAssignmentOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof UserAssignmentOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface UserCreateInputDTO
 */
export interface UserCreateInputDTO {
  /**
   *
   * @type {string}
   * @memberof UserCreateInputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserCreateInputDTO
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserCreateInputDTO
   */
  password: string;
  /**
   *
   * @type {string}
   * @memberof UserCreateInputDTO
   */
  idpId?: string;
}
/**
 *
 * @export
 * @interface UserOutputArrayDTOAPI
 */
export interface UserOutputArrayDTOAPI {
  /**
   *
   * @type {Array<UserOutputWithRolesDTO>}
   * @memberof UserOutputArrayDTOAPI
   */
  data: Array<UserOutputWithRolesDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof UserOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface UserOutputDTO
 */
export interface UserOutputDTO {
  /**
   *
   * @type {string}
   * @memberof UserOutputDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserOutputDTO
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserOutputDTO
   */
  idpId: string;
  /**
   *
   * @type {string}
   * @memberof UserOutputDTO
   */
  discordId?: string;
  /**
   *
   * @type {string}
   * @memberof UserOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof UserOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof UserOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface UserOutputDTOAPI
 */
export interface UserOutputDTOAPI {
  /**
   *
   * @type {UserOutputWithRolesDTO}
   * @memberof UserOutputDTOAPI
   */
  data: UserOutputWithRolesDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof UserOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface UserOutputWithRolesDTO
 */
export interface UserOutputWithRolesDTO {
  /**
   *
   * @type {Array<UserAssignmentOutputDTO>}
   * @memberof UserOutputWithRolesDTO
   */
  roles: Array<UserAssignmentOutputDTO>;
  /**
   *
   * @type {string}
   * @memberof UserOutputWithRolesDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof UserOutputWithRolesDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof UserOutputWithRolesDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {string}
   * @memberof UserOutputWithRolesDTO
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UserOutputWithRolesDTO
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof UserOutputWithRolesDTO
   */
  idpId: string;
  /**
   *
   * @type {string}
   * @memberof UserOutputWithRolesDTO
   */
  discordId?: string;
}
/**
 *
 * @export
 * @interface UserRoleAssignChangeDTO
 */
export interface UserRoleAssignChangeDTO {
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof UserRoleAssignChangeDTO
   */
  expiresAt?: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface UserSearchInputAllowedFilters
 */
export interface UserSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof UserSearchInputAllowedFilters
   */
  name?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UserSearchInputAllowedFilters
   */
  idpId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof UserSearchInputAllowedFilters
   */
  discordId?: Array<string>;
}
/**
 *
 * @export
 * @interface UserSearchInputDTO
 */
export interface UserSearchInputDTO {
  /**
   *
   * @type {UserSearchInputAllowedFilters}
   * @memberof UserSearchInputDTO
   */
  filters?: UserSearchInputAllowedFilters;
  /**
   *
   * @type {UserSearchInputAllowedFilters}
   * @memberof UserSearchInputDTO
   */
  search?: UserSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof UserSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof UserSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof UserSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof UserSearchInputDTO
   */
  sortDirection?: UserSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof UserSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof UserSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof UserSearchInputDTO
   */
  extend?: Array<string>;
}

export const UserSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type UserSearchInputDTOSortDirectionEnum =
  (typeof UserSearchInputDTOSortDirectionEnum)[keyof typeof UserSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface UserUpdateAuthDTO
 */
export interface UserUpdateAuthDTO {
  /**
   *
   * @type {string}
   * @memberof UserUpdateAuthDTO
   */
  discordId?: string;
}
/**
 *
 * @export
 * @interface UserUpdateDTO
 */
export interface UserUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof UserUpdateDTO
   */
  name?: string;
}
/**
 *
 * @export
 * @interface VariableCreateDTO
 */
export interface VariableCreateDTO {
  /**
   *
   * @type {string}
   * @memberof VariableCreateDTO
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof VariableCreateDTO
   */
  value: string;
  /**
   *
   * @type {string}
   * @memberof VariableCreateDTO
   */
  gameServerId?: string;
  /**
   *
   * @type {string}
   * @memberof VariableCreateDTO
   */
  playerId?: string;
  /**
   *
   * @type {string}
   * @memberof VariableCreateDTO
   */
  moduleId?: string;
}
/**
 *
 * @export
 * @interface VariableOutputArrayDTOAPI
 */
export interface VariableOutputArrayDTOAPI {
  /**
   *
   * @type {Array<VariableOutputDTO>}
   * @memberof VariableOutputArrayDTOAPI
   */
  data: Array<VariableOutputDTO>;
  /**
   *
   * @type {MetadataOutput}
   * @memberof VariableOutputArrayDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface VariableOutputDTO
 */
export interface VariableOutputDTO {
  /**
   *
   * @type {string}
   * @memberof VariableOutputDTO
   */
  key: string;
  /**
   *
   * @type {string}
   * @memberof VariableOutputDTO
   */
  value: string;
  /**
   *
   * @type {string}
   * @memberof VariableOutputDTO
   */
  gameServerId?: string;
  /**
   *
   * @type {string}
   * @memberof VariableOutputDTO
   */
  playerId?: string;
  /**
   *
   * @type {string}
   * @memberof VariableOutputDTO
   */
  moduleId?: string;
  /**
   *
   * @type {GameServerOutputDTO}
   * @memberof VariableOutputDTO
   */
  gameServer?: GameServerOutputDTO;
  /**
   *
   * @type {ModuleOutputDTO}
   * @memberof VariableOutputDTO
   */
  module?: ModuleOutputDTO;
  /**
   *
   * @type {PlayerOutputDTO}
   * @memberof VariableOutputDTO
   */
  player?: PlayerOutputDTO;
  /**
   *
   * @type {string}
   * @memberof VariableOutputDTO
   */
  id: string;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof VariableOutputDTO
   */
  createdAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
  /**
   *
   * @type {NOTDOMAINSCOPEDTakaroModelDTOCreatedAt}
   * @memberof VariableOutputDTO
   */
  updatedAt: NOTDOMAINSCOPEDTakaroModelDTOCreatedAt;
}
/**
 *
 * @export
 * @interface VariableOutputDTOAPI
 */
export interface VariableOutputDTOAPI {
  /**
   *
   * @type {VariableOutputDTO}
   * @memberof VariableOutputDTOAPI
   */
  data: VariableOutputDTO;
  /**
   *
   * @type {MetadataOutput}
   * @memberof VariableOutputDTOAPI
   */
  meta: MetadataOutput;
}
/**
 *
 * @export
 * @interface VariableSearchInputAllowedFilters
 */
export interface VariableSearchInputAllowedFilters {
  /**
   *
   * @type {Array<string>}
   * @memberof VariableSearchInputAllowedFilters
   */
  id?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof VariableSearchInputAllowedFilters
   */
  key?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof VariableSearchInputAllowedFilters
   */
  gameServerId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof VariableSearchInputAllowedFilters
   */
  playerId?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof VariableSearchInputAllowedFilters
   */
  moduleId?: Array<string>;
}
/**
 *
 * @export
 * @interface VariableSearchInputDTO
 */
export interface VariableSearchInputDTO {
  /**
   *
   * @type {VariableSearchInputAllowedFilters}
   * @memberof VariableSearchInputDTO
   */
  filters?: VariableSearchInputAllowedFilters;
  /**
   *
   * @type {VariableSearchInputAllowedFilters}
   * @memberof VariableSearchInputDTO
   */
  search?: VariableSearchInputAllowedFilters;
  /**
   *
   * @type {number}
   * @memberof VariableSearchInputDTO
   */
  page?: number;
  /**
   *
   * @type {number}
   * @memberof VariableSearchInputDTO
   */
  limit?: number;
  /**
   *
   * @type {string}
   * @memberof VariableSearchInputDTO
   */
  sortBy?: string;
  /**
   *
   * @type {string}
   * @memberof VariableSearchInputDTO
   */
  sortDirection?: VariableSearchInputDTOSortDirectionEnum;
  /**
   *
   * @type {string}
   * @memberof VariableSearchInputDTO
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof VariableSearchInputDTO
   */
  endDate?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof VariableSearchInputDTO
   */
  extend?: Array<string>;
}

export const VariableSearchInputDTOSortDirectionEnum = {
  Asc: 'asc',
  Desc: 'desc',
} as const;

export type VariableSearchInputDTOSortDirectionEnum =
  (typeof VariableSearchInputDTOSortDirectionEnum)[keyof typeof VariableSearchInputDTOSortDirectionEnum];

/**
 *
 * @export
 * @interface VariableUpdateDTO
 */
export interface VariableUpdateDTO {
  /**
   *
   * @type {string}
   * @memberof VariableUpdateDTO
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof VariableUpdateDTO
   */
  value: string;
  /**
   *
   * @type {string}
   * @memberof VariableUpdateDTO
   */
  gameServerId?: string;
  /**
   *
   * @type {string}
   * @memberof VariableUpdateDTO
   */
  playerId?: string;
  /**
   *
   * @type {string}
   * @memberof VariableUpdateDTO
   */
  moduleId?: string;
}

/**
 * CommandApi - axios parameter creator
 * @export
 */
export const CommandApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {CommandCreateDTO} [commandCreateDTO] CommandCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerCreate: async (
      commandCreateDTO?: CommandCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/command`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(commandCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create argument
     * @param {CommandArgumentCreateDTO} [commandArgumentCreateDTO] CommandArgumentCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerCreateArgument: async (
      commandArgumentCreateDTO?: CommandArgumentCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/command/argument`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        commandArgumentCreateDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('commandControllerGetOne', 'id', id);
      const localVarPath = `/command/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('commandControllerRemove', 'id', id);
      const localVarPath = `/command/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove argument
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerRemoveArgument: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('commandControllerRemoveArgument', 'id', id);
      const localVarPath = `/command/argument/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {CommandSearchInputDTO} [commandSearchInputDTO] CommandSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerSearch: async (
      commandSearchInputDTO?: CommandSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/command/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(commandSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {string} id
     * @param {CommandTriggerDTO} [commandTriggerDTO] CommandTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerTrigger: async (
      id: string,
      commandTriggerDTO?: CommandTriggerDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('commandControllerTrigger', 'id', id);
      const localVarPath = `/command/{id}/trigger`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(commandTriggerDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {CommandUpdateDTO} [commandUpdateDTO] CommandUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerUpdate: async (
      id: string,
      commandUpdateDTO?: CommandUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('commandControllerUpdate', 'id', id);
      const localVarPath = `/command/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(commandUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update argument
     * @param {string} id
     * @param {CommandArgumentUpdateDTO} [commandArgumentUpdateDTO] CommandArgumentUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerUpdateArgument: async (
      id: string,
      commandArgumentUpdateDTO?: CommandArgumentUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('commandControllerUpdateArgument', 'id', id);
      const localVarPath = `/command/argument/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        commandArgumentUpdateDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CommandApi - functional programming interface
 * @export
 */
export const CommandApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CommandApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {CommandCreateDTO} [commandCreateDTO] CommandCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commandControllerCreate(
      commandCreateDTO?: CommandCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerCreate(commandCreateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommandApi.commandControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create argument
     * @param {CommandArgumentCreateDTO} [commandArgumentCreateDTO] CommandArgumentCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commandControllerCreateArgument(
      commandArgumentCreateDTO?: CommandArgumentCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandArgumentDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerCreateArgument(
        commandArgumentCreateDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommandApi.commandControllerCreateArgument']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commandControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommandApi.commandControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commandControllerRemove(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerRemove(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommandApi.commandControllerRemove']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove argument
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commandControllerRemoveArgument(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerRemoveArgument(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommandApi.commandControllerRemoveArgument']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {CommandSearchInputDTO} [commandSearchInputDTO] CommandSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commandControllerSearch(
      commandSearchInputDTO?: CommandSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerSearch(commandSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommandApi.commandControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {string} id
     * @param {CommandTriggerDTO} [commandTriggerDTO] CommandTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commandControllerTrigger(
      id: string,
      commandTriggerDTO?: CommandTriggerDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerTrigger(
        id,
        commandTriggerDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommandApi.commandControllerTrigger']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {CommandUpdateDTO} [commandUpdateDTO] CommandUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commandControllerUpdate(
      id: string,
      commandUpdateDTO?: CommandUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerUpdate(id, commandUpdateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommandApi.commandControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update argument
     * @param {string} id
     * @param {CommandArgumentUpdateDTO} [commandArgumentUpdateDTO] CommandArgumentUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commandControllerUpdateArgument(
      id: string,
      commandArgumentUpdateDTO?: CommandArgumentUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandArgumentDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commandControllerUpdateArgument(
        id,
        commandArgumentUpdateDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CommandApi.commandControllerUpdateArgument']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * CommandApi - factory interface
 * @export
 */
export const CommandApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CommandApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {CommandCreateDTO} [commandCreateDTO] CommandCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerCreate(commandCreateDTO?: CommandCreateDTO, options?: any): AxiosPromise<CommandOutputDTOAPI> {
      return localVarFp.commandControllerCreate(commandCreateDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create argument
     * @param {CommandArgumentCreateDTO} [commandArgumentCreateDTO] CommandArgumentCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerCreateArgument(
      commandArgumentCreateDTO?: CommandArgumentCreateDTO,
      options?: any
    ): AxiosPromise<CommandArgumentDTOAPI> {
      return localVarFp
        .commandControllerCreateArgument(commandArgumentCreateDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerGetOne(id: string, options?: any): AxiosPromise<CommandOutputDTOAPI> {
      return localVarFp.commandControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerRemove(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.commandControllerRemove(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove argument
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerRemoveArgument(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.commandControllerRemoveArgument(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {CommandSearchInputDTO} [commandSearchInputDTO] CommandSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerSearch(
      commandSearchInputDTO?: CommandSearchInputDTO,
      options?: any
    ): AxiosPromise<CommandOutputArrayDTOAPI> {
      return localVarFp
        .commandControllerSearch(commandSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {string} id
     * @param {CommandTriggerDTO} [commandTriggerDTO] CommandTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerTrigger(id: string, commandTriggerDTO?: CommandTriggerDTO, options?: any): AxiosPromise<void> {
      return localVarFp
        .commandControllerTrigger(id, commandTriggerDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {CommandUpdateDTO} [commandUpdateDTO] CommandUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerUpdate(
      id: string,
      commandUpdateDTO?: CommandUpdateDTO,
      options?: any
    ): AxiosPromise<CommandOutputDTOAPI> {
      return localVarFp
        .commandControllerUpdate(id, commandUpdateDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update argument
     * @param {string} id
     * @param {CommandArgumentUpdateDTO} [commandArgumentUpdateDTO] CommandArgumentUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commandControllerUpdateArgument(
      id: string,
      commandArgumentUpdateDTO?: CommandArgumentUpdateDTO,
      options?: any
    ): AxiosPromise<CommandArgumentDTOAPI> {
      return localVarFp
        .commandControllerUpdateArgument(id, commandArgumentUpdateDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CommandApi - object-oriented interface
 * @export
 * @class CommandApi
 * @extends {BaseAPI}
 */
export class CommandApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Create
   * @param {CommandCreateDTO} [commandCreateDTO] CommandCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommandApi
   */
  public commandControllerCreate(commandCreateDTO?: CommandCreateDTO, options?: RawAxiosRequestConfig) {
    return CommandApiFp(this.configuration)
      .commandControllerCreate(commandCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Create argument
   * @param {CommandArgumentCreateDTO} [commandArgumentCreateDTO] CommandArgumentCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommandApi
   */
  public commandControllerCreateArgument(
    commandArgumentCreateDTO?: CommandArgumentCreateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return CommandApiFp(this.configuration)
      .commandControllerCreateArgument(commandArgumentCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommandApi
   */
  public commandControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return CommandApiFp(this.configuration)
      .commandControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Remove
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommandApi
   */
  public commandControllerRemove(id: string, options?: RawAxiosRequestConfig) {
    return CommandApiFp(this.configuration)
      .commandControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Remove argument
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommandApi
   */
  public commandControllerRemoveArgument(id: string, options?: RawAxiosRequestConfig) {
    return CommandApiFp(this.configuration)
      .commandControllerRemoveArgument(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Search
   * @param {CommandSearchInputDTO} [commandSearchInputDTO] CommandSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommandApi
   */
  public commandControllerSearch(commandSearchInputDTO?: CommandSearchInputDTO, options?: RawAxiosRequestConfig) {
    return CommandApiFp(this.configuration)
      .commandControllerSearch(commandSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Trigger
   * @param {string} id
   * @param {CommandTriggerDTO} [commandTriggerDTO] CommandTriggerDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommandApi
   */
  public commandControllerTrigger(id: string, commandTriggerDTO?: CommandTriggerDTO, options?: RawAxiosRequestConfig) {
    return CommandApiFp(this.configuration)
      .commandControllerTrigger(id, commandTriggerDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Update
   * @param {string} id
   * @param {CommandUpdateDTO} [commandUpdateDTO] CommandUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommandApi
   */
  public commandControllerUpdate(id: string, commandUpdateDTO?: CommandUpdateDTO, options?: RawAxiosRequestConfig) {
    return CommandApiFp(this.configuration)
      .commandControllerUpdate(id, commandUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Update argument
   * @param {string} id
   * @param {CommandArgumentUpdateDTO} [commandArgumentUpdateDTO] CommandArgumentUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommandApi
   */
  public commandControllerUpdateArgument(
    id: string,
    commandArgumentUpdateDTO?: CommandArgumentUpdateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return CommandApiFp(this.configuration)
      .commandControllerUpdateArgument(id, commandArgumentUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CronJobApi - axios parameter creator
 * @export
 */
export const CronJobApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {CronJobCreateDTO} [cronJobCreateDTO] CronJobCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerCreate: async (
      cronJobCreateDTO?: CronJobCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/cronjob`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cronJobCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('cronJobControllerGetOne', 'id', id);
      const localVarPath = `/cronjob/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('cronJobControllerRemove', 'id', id);
      const localVarPath = `/cronjob/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {CronJobSearchInputDTO} [cronJobSearchInputDTO] CronJobSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerSearch: async (
      cronJobSearchInputDTO?: CronJobSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/cronjob/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cronJobSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {CronJobTriggerDTO} [cronJobTriggerDTO] CronJobTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerTrigger: async (
      cronJobTriggerDTO?: CronJobTriggerDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/cronjob/trigger`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cronJobTriggerDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {CronJobUpdateDTO} [cronJobUpdateDTO] CronJobUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerUpdate: async (
      id: string,
      cronJobUpdateDTO?: CronJobUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('cronJobControllerUpdate', 'id', id);
      const localVarPath = `/cronjob/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(cronJobUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CronJobApi - functional programming interface
 * @export
 */
export const CronJobApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CronJobApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {CronJobCreateDTO} [cronJobCreateDTO] CronJobCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cronJobControllerCreate(
      cronJobCreateDTO?: CronJobCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronJobOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerCreate(cronJobCreateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CronJobApi.cronJobControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cronJobControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronJobOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CronJobApi.cronJobControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cronJobControllerRemove(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerRemove(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CronJobApi.cronJobControllerRemove']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {CronJobSearchInputDTO} [cronJobSearchInputDTO] CronJobSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cronJobControllerSearch(
      cronJobSearchInputDTO?: CronJobSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronJobOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerSearch(cronJobSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CronJobApi.cronJobControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {CronJobTriggerDTO} [cronJobTriggerDTO] CronJobTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cronJobControllerTrigger(
      cronJobTriggerDTO?: CronJobTriggerDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerTrigger(cronJobTriggerDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CronJobApi.cronJobControllerTrigger']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {CronJobUpdateDTO} [cronJobUpdateDTO] CronJobUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cronJobControllerUpdate(
      id: string,
      cronJobUpdateDTO?: CronJobUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CronJobOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cronJobControllerUpdate(id, cronJobUpdateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['CronJobApi.cronJobControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * CronJobApi - factory interface
 * @export
 */
export const CronJobApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CronJobApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {CronJobCreateDTO} [cronJobCreateDTO] CronJobCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerCreate(cronJobCreateDTO?: CronJobCreateDTO, options?: any): AxiosPromise<CronJobOutputDTOAPI> {
      return localVarFp.cronJobControllerCreate(cronJobCreateDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerGetOne(id: string, options?: any): AxiosPromise<CronJobOutputDTOAPI> {
      return localVarFp.cronJobControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerRemove(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.cronJobControllerRemove(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {CronJobSearchInputDTO} [cronJobSearchInputDTO] CronJobSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerSearch(
      cronJobSearchInputDTO?: CronJobSearchInputDTO,
      options?: any
    ): AxiosPromise<CronJobOutputArrayDTOAPI> {
      return localVarFp
        .cronJobControllerSearch(cronJobSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {CronJobTriggerDTO} [cronJobTriggerDTO] CronJobTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerTrigger(cronJobTriggerDTO?: CronJobTriggerDTO, options?: any): AxiosPromise<void> {
      return localVarFp
        .cronJobControllerTrigger(cronJobTriggerDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {CronJobUpdateDTO} [cronJobUpdateDTO] CronJobUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cronJobControllerUpdate(
      id: string,
      cronJobUpdateDTO?: CronJobUpdateDTO,
      options?: any
    ): AxiosPromise<CronJobOutputDTOAPI> {
      return localVarFp
        .cronJobControllerUpdate(id, cronJobUpdateDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CronJobApi - object-oriented interface
 * @export
 * @class CronJobApi
 * @extends {BaseAPI}
 */
export class CronJobApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Create
   * @param {CronJobCreateDTO} [cronJobCreateDTO] CronJobCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CronJobApi
   */
  public cronJobControllerCreate(cronJobCreateDTO?: CronJobCreateDTO, options?: RawAxiosRequestConfig) {
    return CronJobApiFp(this.configuration)
      .cronJobControllerCreate(cronJobCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CronJobApi
   */
  public cronJobControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return CronJobApiFp(this.configuration)
      .cronJobControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Remove
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CronJobApi
   */
  public cronJobControllerRemove(id: string, options?: RawAxiosRequestConfig) {
    return CronJobApiFp(this.configuration)
      .cronJobControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Search
   * @param {CronJobSearchInputDTO} [cronJobSearchInputDTO] CronJobSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CronJobApi
   */
  public cronJobControllerSearch(cronJobSearchInputDTO?: CronJobSearchInputDTO, options?: RawAxiosRequestConfig) {
    return CronJobApiFp(this.configuration)
      .cronJobControllerSearch(cronJobSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Trigger
   * @param {CronJobTriggerDTO} [cronJobTriggerDTO] CronJobTriggerDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CronJobApi
   */
  public cronJobControllerTrigger(cronJobTriggerDTO?: CronJobTriggerDTO, options?: RawAxiosRequestConfig) {
    return CronJobApiFp(this.configuration)
      .cronJobControllerTrigger(cronJobTriggerDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Update
   * @param {string} id
   * @param {CronJobUpdateDTO} [cronJobUpdateDTO] CronJobUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CronJobApi
   */
  public cronJobControllerUpdate(id: string, cronJobUpdateDTO?: CronJobUpdateDTO, options?: RawAxiosRequestConfig) {
    return CronJobApiFp(this.configuration)
      .cronJobControllerUpdate(id, cronJobUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DiscordApi - axios parameter creator
 * @export
 */
export const DiscordApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    discordControllerGetInvite: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/discord/invite`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Search
     * @param {GuildSearchInputDTO} [guildSearchInputDTO] GuildSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    discordControllerSearch: async (
      guildSearchInputDTO?: GuildSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/discord/guilds/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(guildSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send message
     * @param {string} id
     * @param {SendMessageInputDTO} [sendMessageInputDTO] SendMessageInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    discordControllerSendMessage: async (
      id: string,
      sendMessageInputDTO?: SendMessageInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('discordControllerSendMessage', 'id', id);
      const localVarPath = `/discord/channels/{id}/message`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(sendMessageInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update guild
     * @param {string} id
     * @param {GuildApiUpdateDTO} [guildApiUpdateDTO] GuildApiUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    discordControllerUpdateGuild: async (
      id: string,
      guildApiUpdateDTO?: GuildApiUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('discordControllerUpdateGuild', 'id', id);
      const localVarPath = `/discord/guilds/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(guildApiUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DiscordApi - functional programming interface
 * @export
 */
export const DiscordApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DiscordApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async discordControllerGetInvite(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DiscordInviteOutputDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.discordControllerGetInvite(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DiscordApi.discordControllerGetInvite']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Search
     * @param {GuildSearchInputDTO} [guildSearchInputDTO] GuildSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async discordControllerSearch(
      guildSearchInputDTO?: GuildSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.discordControllerSearch(guildSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DiscordApi.discordControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Send message
     * @param {string} id
     * @param {SendMessageInputDTO} [sendMessageInputDTO] SendMessageInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async discordControllerSendMessage(
      id: string,
      sendMessageInputDTO?: SendMessageInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.discordControllerSendMessage(
        id,
        sendMessageInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DiscordApi.discordControllerSendMessage']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Update guild
     * @param {string} id
     * @param {GuildApiUpdateDTO} [guildApiUpdateDTO] GuildApiUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async discordControllerUpdateGuild(
      id: string,
      guildApiUpdateDTO?: GuildApiUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GuildOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.discordControllerUpdateGuild(
        id,
        guildApiUpdateDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DiscordApi.discordControllerUpdateGuild']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * DiscordApi - factory interface
 * @export
 */
export const DiscordApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DiscordApiFp(configuration);
  return {
    /**
     *
     * @summary Get invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    discordControllerGetInvite(options?: any): AxiosPromise<DiscordInviteOutputDTO> {
      return localVarFp.discordControllerGetInvite(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Search
     * @param {GuildSearchInputDTO} [guildSearchInputDTO] GuildSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    discordControllerSearch(
      guildSearchInputDTO?: GuildSearchInputDTO,
      options?: any
    ): AxiosPromise<GuildOutputArrayDTOAPI> {
      return localVarFp
        .discordControllerSearch(guildSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Send message
     * @param {string} id
     * @param {SendMessageInputDTO} [sendMessageInputDTO] SendMessageInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    discordControllerSendMessage(
      id: string,
      sendMessageInputDTO?: SendMessageInputDTO,
      options?: any
    ): AxiosPromise<APIOutput> {
      return localVarFp
        .discordControllerSendMessage(id, sendMessageInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update guild
     * @param {string} id
     * @param {GuildApiUpdateDTO} [guildApiUpdateDTO] GuildApiUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    discordControllerUpdateGuild(
      id: string,
      guildApiUpdateDTO?: GuildApiUpdateDTO,
      options?: any
    ): AxiosPromise<GuildOutputDTOAPI> {
      return localVarFp
        .discordControllerUpdateGuild(id, guildApiUpdateDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DiscordApi - object-oriented interface
 * @export
 * @class DiscordApi
 * @extends {BaseAPI}
 */
export class DiscordApi extends BaseAPI {
  /**
   *
   * @summary Get invite
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscordApi
   */
  public discordControllerGetInvite(options?: RawAxiosRequestConfig) {
    return DiscordApiFp(this.configuration)
      .discordControllerGetInvite(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Search
   * @param {GuildSearchInputDTO} [guildSearchInputDTO] GuildSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscordApi
   */
  public discordControllerSearch(guildSearchInputDTO?: GuildSearchInputDTO, options?: RawAxiosRequestConfig) {
    return DiscordApiFp(this.configuration)
      .discordControllerSearch(guildSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Send message
   * @param {string} id
   * @param {SendMessageInputDTO} [sendMessageInputDTO] SendMessageInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscordApi
   */
  public discordControllerSendMessage(
    id: string,
    sendMessageInputDTO?: SendMessageInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return DiscordApiFp(this.configuration)
      .discordControllerSendMessage(id, sendMessageInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update guild
   * @param {string} id
   * @param {GuildApiUpdateDTO} [guildApiUpdateDTO] GuildApiUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DiscordApi
   */
  public discordControllerUpdateGuild(
    id: string,
    guildApiUpdateDTO?: GuildApiUpdateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return DiscordApiFp(this.configuration)
      .discordControllerUpdateGuild(id, guildApiUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DomainApi - axios parameter creator
 * @export
 */
export const DomainApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create
     * @param {DomainCreateInputDTO} [domainCreateInputDTO] DomainCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerCreate: async (
      domainCreateInputDTO?: DomainCreateInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/domain`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication adminAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(domainCreateInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('domainControllerGetOne', 'id', id);
      const localVarPath = `/domain/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication adminAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get token
     * @param {TokenInputDTO} [tokenInputDTO] TokenInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerGetToken: async (
      tokenInputDTO?: TokenInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication adminAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(tokenInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('domainControllerRemove', 'id', id);
      const localVarPath = `/domain/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication adminAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Search
     * @param {DomainSearchInputDTO} [domainSearchInputDTO] DomainSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerSearch: async (
      domainSearchInputDTO?: DomainSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/domain/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication adminAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(domainSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update
     * @param {string} id
     * @param {DomainUpdateInputDTO} [domainUpdateInputDTO] DomainUpdateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerUpdate: async (
      id: string,
      domainUpdateInputDTO?: DomainUpdateInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('domainControllerUpdate', 'id', id);
      const localVarPath = `/domain/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication adminAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(domainUpdateInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DomainApi - functional programming interface
 * @export
 */
export const DomainApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DomainApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Create
     * @param {DomainCreateInputDTO} [domainCreateInputDTO] DomainCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async domainControllerCreate(
      domainCreateInputDTO?: DomainCreateInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainCreateOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerCreate(domainCreateInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DomainApi.domainControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async domainControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DomainApi.domainControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get token
     * @param {TokenInputDTO} [tokenInputDTO] TokenInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async domainControllerGetToken(
      tokenInputDTO?: TokenInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerGetToken(tokenInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DomainApi.domainControllerGetToken']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async domainControllerRemove(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerRemove(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DomainApi.domainControllerRemove']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Search
     * @param {DomainSearchInputDTO} [domainSearchInputDTO] DomainSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async domainControllerSearch(
      domainSearchInputDTO?: DomainSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerSearch(domainSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DomainApi.domainControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Update
     * @param {string} id
     * @param {DomainUpdateInputDTO} [domainUpdateInputDTO] DomainUpdateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async domainControllerUpdate(
      id: string,
      domainUpdateInputDTO?: DomainUpdateInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.domainControllerUpdate(
        id,
        domainUpdateInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['DomainApi.domainControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * DomainApi - factory interface
 * @export
 */
export const DomainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DomainApiFp(configuration);
  return {
    /**
     *
     * @summary Create
     * @param {DomainCreateInputDTO} [domainCreateInputDTO] DomainCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerCreate(
      domainCreateInputDTO?: DomainCreateInputDTO,
      options?: any
    ): AxiosPromise<DomainCreateOutputDTOAPI> {
      return localVarFp
        .domainControllerCreate(domainCreateInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerGetOne(id: string, options?: any): AxiosPromise<DomainOutputDTOAPI> {
      return localVarFp.domainControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get token
     * @param {TokenInputDTO} [tokenInputDTO] TokenInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerGetToken(tokenInputDTO?: TokenInputDTO, options?: any): AxiosPromise<TokenOutputDTOAPI> {
      return localVarFp.domainControllerGetToken(tokenInputDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerRemove(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.domainControllerRemove(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Search
     * @param {DomainSearchInputDTO} [domainSearchInputDTO] DomainSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerSearch(
      domainSearchInputDTO?: DomainSearchInputDTO,
      options?: any
    ): AxiosPromise<DomainOutputArrayDTOAPI> {
      return localVarFp
        .domainControllerSearch(domainSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update
     * @param {string} id
     * @param {DomainUpdateInputDTO} [domainUpdateInputDTO] DomainUpdateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    domainControllerUpdate(
      id: string,
      domainUpdateInputDTO?: DomainUpdateInputDTO,
      options?: any
    ): AxiosPromise<DomainOutputDTOAPI> {
      return localVarFp
        .domainControllerUpdate(id, domainUpdateInputDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DomainApi - object-oriented interface
 * @export
 * @class DomainApi
 * @extends {BaseAPI}
 */
export class DomainApi extends BaseAPI {
  /**
   *
   * @summary Create
   * @param {DomainCreateInputDTO} [domainCreateInputDTO] DomainCreateInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DomainApi
   */
  public domainControllerCreate(domainCreateInputDTO?: DomainCreateInputDTO, options?: RawAxiosRequestConfig) {
    return DomainApiFp(this.configuration)
      .domainControllerCreate(domainCreateInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DomainApi
   */
  public domainControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return DomainApiFp(this.configuration)
      .domainControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get token
   * @param {TokenInputDTO} [tokenInputDTO] TokenInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DomainApi
   */
  public domainControllerGetToken(tokenInputDTO?: TokenInputDTO, options?: RawAxiosRequestConfig) {
    return DomainApiFp(this.configuration)
      .domainControllerGetToken(tokenInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DomainApi
   */
  public domainControllerRemove(id: string, options?: RawAxiosRequestConfig) {
    return DomainApiFp(this.configuration)
      .domainControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Search
   * @param {DomainSearchInputDTO} [domainSearchInputDTO] DomainSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DomainApi
   */
  public domainControllerSearch(domainSearchInputDTO?: DomainSearchInputDTO, options?: RawAxiosRequestConfig) {
    return DomainApiFp(this.configuration)
      .domainControllerSearch(domainSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update
   * @param {string} id
   * @param {DomainUpdateInputDTO} [domainUpdateInputDTO] DomainUpdateInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DomainApi
   */
  public domainControllerUpdate(
    id: string,
    domainUpdateInputDTO?: DomainUpdateInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return DomainApiFp(this.configuration)
      .domainControllerUpdate(id, domainUpdateInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EventApi - axios parameter creator
 * @export
 */
export const EventApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_EVENTS`
     * @summary Create
     * @param {EventCreateDTO} [eventCreateDTO] EventCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventControllerCreate: async (
      eventCreateDTO?: EventCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/event`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(eventCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_EVENTS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('eventControllerGetOne', 'id', id);
      const localVarPath = `/event/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_EVENTS`
     * @summary Search
     * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventControllerSearch: async (
      eventSearchInputDTO?: EventSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/event/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(eventSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EventApi - functional programming interface
 * @export
 */
export const EventApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EventApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_EVENTS`
     * @summary Create
     * @param {EventCreateDTO} [eventCreateDTO] EventCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventControllerCreate(
      eventCreateDTO?: EventCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerCreate(eventCreateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['EventApi.eventControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_EVENTS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['EventApi.eventControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_EVENTS`
     * @summary Search
     * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async eventControllerSearch(
      eventSearchInputDTO?: EventSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.eventControllerSearch(eventSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['EventApi.eventControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * EventApi - factory interface
 * @export
 */
export const EventApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EventApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_EVENTS`
     * @summary Create
     * @param {EventCreateDTO} [eventCreateDTO] EventCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventControllerCreate(eventCreateDTO?: EventCreateDTO, options?: any): AxiosPromise<EventOutputDTO> {
      return localVarFp.eventControllerCreate(eventCreateDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_EVENTS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventControllerGetOne(id: string, options?: any): AxiosPromise<EventOutputDTO> {
      return localVarFp.eventControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_EVENTS`
     * @summary Search
     * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    eventControllerSearch(
      eventSearchInputDTO?: EventSearchInputDTO,
      options?: any
    ): AxiosPromise<EventOutputArrayDTOAPI> {
      return localVarFp.eventControllerSearch(eventSearchInputDTO, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * EventApi - object-oriented interface
 * @export
 * @class EventApi
 * @extends {BaseAPI}
 */
export class EventApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_EVENTS`
   * @summary Create
   * @param {EventCreateDTO} [eventCreateDTO] EventCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventApi
   */
  public eventControllerCreate(eventCreateDTO?: EventCreateDTO, options?: RawAxiosRequestConfig) {
    return EventApiFp(this.configuration)
      .eventControllerCreate(eventCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_EVENTS`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventApi
   */
  public eventControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return EventApiFp(this.configuration)
      .eventControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_EVENTS`
   * @summary Search
   * @param {EventSearchInputDTO} [eventSearchInputDTO] EventSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EventApi
   */
  public eventControllerSearch(eventSearchInputDTO?: EventSearchInputDTO, options?: RawAxiosRequestConfig) {
    return EventApiFp(this.configuration)
      .eventControllerSearch(eventSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ExternalAuthApi - axios parameter creator
 * @export
 */
export const ExternalAuthApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Auth discord
     * @param {string} redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalAuthControllerAuthDiscord: async (
      redirect: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'redirect' is not null or undefined
      assertParamExists('externalAuthControllerAuthDiscord', 'redirect', redirect);
      const localVarPath = `/auth/discord`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (redirect !== undefined) {
        localVarQueryParameter['redirect'] = redirect;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Auth discord return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalAuthControllerAuthDiscordReturn: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/auth/discord/return`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ExternalAuthApi - functional programming interface
 * @export
 */
export const ExternalAuthApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ExternalAuthApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Auth discord
     * @param {string} redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async externalAuthControllerAuthDiscord(
      redirect: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.externalAuthControllerAuthDiscord(redirect, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ExternalAuthApi.externalAuthControllerAuthDiscord']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Auth discord return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async externalAuthControllerAuthDiscordReturn(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.externalAuthControllerAuthDiscordReturn(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['ExternalAuthApi.externalAuthControllerAuthDiscordReturn']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ExternalAuthApi - factory interface
 * @export
 */
export const ExternalAuthApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ExternalAuthApiFp(configuration);
  return {
    /**
     *
     * @summary Auth discord
     * @param {string} redirect
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalAuthControllerAuthDiscord(redirect: string, options?: any): AxiosPromise<void> {
      return localVarFp
        .externalAuthControllerAuthDiscord(redirect, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Auth discord return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    externalAuthControllerAuthDiscordReturn(options?: any): AxiosPromise<void> {
      return localVarFp.externalAuthControllerAuthDiscordReturn(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ExternalAuthApi - object-oriented interface
 * @export
 * @class ExternalAuthApi
 * @extends {BaseAPI}
 */
export class ExternalAuthApi extends BaseAPI {
  /**
   *
   * @summary Auth discord
   * @param {string} redirect
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExternalAuthApi
   */
  public externalAuthControllerAuthDiscord(redirect: string, options?: RawAxiosRequestConfig) {
    return ExternalAuthApiFp(this.configuration)
      .externalAuthControllerAuthDiscord(redirect, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Auth discord return
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ExternalAuthApi
   */
  public externalAuthControllerAuthDiscordReturn(options?: RawAxiosRequestConfig) {
    return ExternalAuthApiFp(this.configuration)
      .externalAuthControllerAuthDiscordReturn(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FunctionApi - axios parameter creator
 * @export
 */
export const FunctionApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {FunctionCreateDTO} [functionCreateDTO] FunctionCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerCreate: async (
      functionCreateDTO?: FunctionCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/function`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(functionCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('functionControllerGetOne', 'id', id);
      const localVarPath = `/function/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('functionControllerRemove', 'id', id);
      const localVarPath = `/function/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {FunctionSearchInputDTO} [functionSearchInputDTO] FunctionSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerSearch: async (
      functionSearchInputDTO?: FunctionSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/function/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        functionSearchInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {FunctionUpdateDTO} [functionUpdateDTO] FunctionUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerUpdate: async (
      id: string,
      functionUpdateDTO?: FunctionUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('functionControllerUpdate', 'id', id);
      const localVarPath = `/function/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(functionUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FunctionApi - functional programming interface
 * @export
 */
export const FunctionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FunctionApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {FunctionCreateDTO} [functionCreateDTO] FunctionCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async functionControllerCreate(
      functionCreateDTO?: FunctionCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerCreate(functionCreateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['FunctionApi.functionControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async functionControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['FunctionApi.functionControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async functionControllerRemove(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerRemove(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['FunctionApi.functionControllerRemove']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {FunctionSearchInputDTO} [functionSearchInputDTO] FunctionSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async functionControllerSearch(
      functionSearchInputDTO?: FunctionSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerSearch(
        functionSearchInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['FunctionApi.functionControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {FunctionUpdateDTO} [functionUpdateDTO] FunctionUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async functionControllerUpdate(
      id: string,
      functionUpdateDTO?: FunctionUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.functionControllerUpdate(
        id,
        functionUpdateDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['FunctionApi.functionControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * FunctionApi - factory interface
 * @export
 */
export const FunctionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = FunctionApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {FunctionCreateDTO} [functionCreateDTO] FunctionCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerCreate(functionCreateDTO?: FunctionCreateDTO, options?: any): AxiosPromise<FunctionOutputDTOAPI> {
      return localVarFp
        .functionControllerCreate(functionCreateDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerGetOne(id: string, options?: any): AxiosPromise<FunctionOutputDTOAPI> {
      return localVarFp.functionControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerRemove(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.functionControllerRemove(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {FunctionSearchInputDTO} [functionSearchInputDTO] FunctionSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerSearch(
      functionSearchInputDTO?: FunctionSearchInputDTO,
      options?: any
    ): AxiosPromise<FunctionOutputArrayDTOAPI> {
      return localVarFp
        .functionControllerSearch(functionSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {FunctionUpdateDTO} [functionUpdateDTO] FunctionUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    functionControllerUpdate(
      id: string,
      functionUpdateDTO?: FunctionUpdateDTO,
      options?: any
    ): AxiosPromise<FunctionOutputDTOAPI> {
      return localVarFp
        .functionControllerUpdate(id, functionUpdateDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FunctionApi - object-oriented interface
 * @export
 * @class FunctionApi
 * @extends {BaseAPI}
 */
export class FunctionApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Create
   * @param {FunctionCreateDTO} [functionCreateDTO] FunctionCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionApi
   */
  public functionControllerCreate(functionCreateDTO?: FunctionCreateDTO, options?: RawAxiosRequestConfig) {
    return FunctionApiFp(this.configuration)
      .functionControllerCreate(functionCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionApi
   */
  public functionControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return FunctionApiFp(this.configuration)
      .functionControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Remove
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionApi
   */
  public functionControllerRemove(id: string, options?: RawAxiosRequestConfig) {
    return FunctionApiFp(this.configuration)
      .functionControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Search
   * @param {FunctionSearchInputDTO} [functionSearchInputDTO] FunctionSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionApi
   */
  public functionControllerSearch(functionSearchInputDTO?: FunctionSearchInputDTO, options?: RawAxiosRequestConfig) {
    return FunctionApiFp(this.configuration)
      .functionControllerSearch(functionSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Update
   * @param {string} id
   * @param {FunctionUpdateDTO} [functionUpdateDTO] FunctionUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionApi
   */
  public functionControllerUpdate(id: string, functionUpdateDTO?: FunctionUpdateDTO, options?: RawAxiosRequestConfig) {
    return FunctionApiFp(this.configuration)
      .functionControllerUpdate(id, functionUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * GameServerApi - axios parameter creator
 * @export
 */
export const GameServerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Ban a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Ban player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {BanPlayerInputDTO} [banPlayerInputDTO] BanPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerBanPlayer: async (
      gameServerId: string,
      playerId: string,
      banPlayerInputDTO?: BanPlayerInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('gameServerControllerBanPlayer', 'gameServerId', gameServerId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('gameServerControllerBanPlayer', 'playerId', playerId);
      const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/ban`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'playerId'}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(banPlayerInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a gameserver Required permissions: `MANAGE_GAMESERVERS`
     * @summary Create
     * @param {GameServerCreateDTO} [gameServerCreateDTO] GameServerCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerCreate: async (
      gameServerCreateDTO?: GameServerCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/gameserver`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gameServerCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Execute a raw command on a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Execute command
     * @param {string} id
     * @param {CommandExecuteInputDTO} [commandExecuteInputDTO] CommandExecuteInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerExecuteCommand: async (
      id: string,
      commandExecuteInputDTO?: CommandExecuteInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerExecuteCommand', 'id', id);
      const localVarPath = `/gameserver/{id}/command`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        commandExecuteInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch status of an import from CSMM Required permissions: `MANAGE_GAMESERVERS`
     * @summary Get import
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetImport: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerGetImport', 'id', id);
      const localVarPath = `/gameserver/import/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get all module installations for a gameserver Required permissions: `READ_GAMESERVERS`
     * @summary Get installed modules
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetInstalledModules: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerGetInstalledModules', 'id', id);
      const localVarPath = `/gameserver/{id}/modules`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a module installation by id Required permissions: `READ_GAMESERVERS`
     * @summary Get module installation
     * @param {string} gameServerId
     * @param {string} moduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetModuleInstallation: async (
      gameServerId: string,
      moduleId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('gameServerControllerGetModuleInstallation', 'gameServerId', gameServerId);
      // verify required parameter 'moduleId' is not null or undefined
      assertParamExists('gameServerControllerGetModuleInstallation', 'moduleId', moduleId);
      const localVarPath = `/gameserver/{gameServerId}/module/{moduleId}`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'moduleId'}}`, encodeURIComponent(String(moduleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch a gameserver by id Required permissions: `READ_GAMESERVERS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerGetOne', 'id', id);
      const localVarPath = `/gameserver/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch a list of players on a gameserver. Requires gameserver to be online and reachable. Required permissions: `READ_PLAYERS`
     * @summary Get players
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetPlayers: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerGetPlayers', 'id', id);
      const localVarPath = `/gameserver/{id}/players`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch gameserver types (7dtd, Rust, ...) Required permissions: `READ_GAMESERVERS`
     * @summary Get types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/gameserver/types`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Give an item to a player. Requires gameserver to be online and reachable. Depending on the underlying game implementation, it\'s possible that the item is dropped on the ground instead of placed directly in the player\'s inventory. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Give item
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {GiveItemInputDTO} [giveItemInputDTO] GiveItemInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGiveItem: async (
      gameServerId: string,
      playerId: string,
      giveItemInputDTO?: GiveItemInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('gameServerControllerGiveItem', 'gameServerId', gameServerId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('gameServerControllerGiveItem', 'playerId', playerId);
      const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/giveItem`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'playerId'}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(giveItemInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Import a gameserver from CSMM. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Import from csmm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerImportFromCSMM: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/gameserver/import`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Install a module on a gameserver. If the module is already installed, it will be updated. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Install module
     * @param {string} gameServerId
     * @param {string} moduleId
     * @param {ModuleInstallDTO} [moduleInstallDTO] ModuleInstallDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerInstallModule: async (
      gameServerId: string,
      moduleId: string,
      moduleInstallDTO?: ModuleInstallDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('gameServerControllerInstallModule', 'gameServerId', gameServerId);
      // verify required parameter 'moduleId' is not null or undefined
      assertParamExists('gameServerControllerInstallModule', 'moduleId', moduleId);
      const localVarPath = `/gameserver/{gameServerId}/modules/{moduleId}`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'moduleId'}}`, encodeURIComponent(String(moduleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(moduleInstallDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Kick a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Kick player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {KickPlayerInputDTO} [kickPlayerInputDTO] KickPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerKickPlayer: async (
      gameServerId: string,
      playerId: string,
      kickPlayerInputDTO?: KickPlayerInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('gameServerControllerKickPlayer', 'gameServerId', gameServerId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('gameServerControllerKickPlayer', 'playerId', playerId);
      const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/kick`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'playerId'}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(kickPlayerInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List bans for a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary List bans
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerListBans: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerListBans', 'id', id);
      const localVarPath = `/gameserver/{id}/bans`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a gameserver Required permissions: `MANAGE_GAMESERVERS`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerRemove', 'id', id);
      const localVarPath = `/gameserver/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch gameservers Required permissions: `READ_GAMESERVERS`
     * @summary Search
     * @param {GameServerSearchInputDTO} [gameServerSearchInputDTO] GameServerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerSearch: async (
      gameServerSearchInputDTO?: GameServerSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/gameserver/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        gameServerSearchInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Send a message in gameserver chat. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Send message
     * @param {string} id
     * @param {MessageSendInputDTO} [messageSendInputDTO] MessageSendInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerSendMessage: async (
      id: string,
      messageSendInputDTO?: MessageSendInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerSendMessage', 'id', id);
      const localVarPath = `/gameserver/{id}/message`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(messageSendInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Teleport a player to a location. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Teleport player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {TeleportPlayerInputDTO} [teleportPlayerInputDTO] TeleportPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerTeleportPlayer: async (
      gameServerId: string,
      playerId: string,
      teleportPlayerInputDTO?: TeleportPlayerInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('gameServerControllerTeleportPlayer', 'gameServerId', gameServerId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('gameServerControllerTeleportPlayer', 'playerId', playerId);
      const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/teleport`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'playerId'}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        teleportPlayerInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Test if Takaro can connect to a gameserver. Will do a thorough check and report details. Required permissions: `READ_GAMESERVERS`
     * @summary Test reachability
     * @param {GameServerTestReachabilityInputDTO} [gameServerTestReachabilityInputDTO] GameServerTestReachabilityInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerTestReachability: async (
      gameServerTestReachabilityInputDTO?: GameServerTestReachabilityInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/gameserver/reachability`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        gameServerTestReachabilityInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Test if Takaro can connect to a gameserver. Will do a thorough check and report details. Required permissions: `READ_GAMESERVERS`
     * @summary Test reachability for id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerTestReachabilityForId: async (
      id: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerTestReachabilityForId', 'id', id);
      const localVarPath = `/gameserver/{id}/reachability`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Unban a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Unban player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerUnbanPlayer: async (
      gameServerId: string,
      playerId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('gameServerControllerUnbanPlayer', 'gameServerId', gameServerId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('gameServerControllerUnbanPlayer', 'playerId', playerId);
      const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/unban`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'playerId'}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Uninstall a module from a gameserver. This will not delete the module from the database. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Uninstall module
     * @param {string} gameServerId
     * @param {string} moduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerUninstallModule: async (
      gameServerId: string,
      moduleId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('gameServerControllerUninstallModule', 'gameServerId', gameServerId);
      // verify required parameter 'moduleId' is not null or undefined
      assertParamExists('gameServerControllerUninstallModule', 'moduleId', moduleId);
      const localVarPath = `/gameserver/{gameServerId}/modules/{moduleId}`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'moduleId'}}`, encodeURIComponent(String(moduleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a gameserver Required permissions: `MANAGE_GAMESERVERS`
     * @summary Update
     * @param {string} id
     * @param {GameServerUpdateDTO} [gameServerUpdateDTO] GameServerUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerUpdate: async (
      id: string,
      gameServerUpdateDTO?: GameServerUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('gameServerControllerUpdate', 'id', id);
      const localVarPath = `/gameserver/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(gameServerUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * GameServerApi - functional programming interface
 * @export
 */
export const GameServerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = GameServerApiAxiosParamCreator(configuration);
  return {
    /**
     * Ban a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Ban player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {BanPlayerInputDTO} [banPlayerInputDTO] BanPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerBanPlayer(
      gameServerId: string,
      playerId: string,
      banPlayerInputDTO?: BanPlayerInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerBanPlayer(
        gameServerId,
        playerId,
        banPlayerInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerBanPlayer']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Create a gameserver Required permissions: `MANAGE_GAMESERVERS`
     * @summary Create
     * @param {GameServerCreateDTO} [gameServerCreateDTO] GameServerCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerCreate(
      gameServerCreateDTO?: GameServerCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerCreate(
        gameServerCreateDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Execute a raw command on a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Execute command
     * @param {string} id
     * @param {CommandExecuteInputDTO} [commandExecuteInputDTO] CommandExecuteInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerExecuteCommand(
      id: string,
      commandExecuteInputDTO?: CommandExecuteInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CommandExecuteDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerExecuteCommand(
        id,
        commandExecuteInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerExecuteCommand']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetch status of an import from CSMM Required permissions: `MANAGE_GAMESERVERS`
     * @summary Get import
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerGetImport(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetImport(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerGetImport']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Get all module installations for a gameserver Required permissions: `READ_GAMESERVERS`
     * @summary Get installed modules
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerGetInstalledModules(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleInstallationOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetInstalledModules(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['GameServerApi.gameServerControllerGetInstalledModules']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Get a module installation by id Required permissions: `READ_GAMESERVERS`
     * @summary Get module installation
     * @param {string} gameServerId
     * @param {string} moduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerGetModuleInstallation(
      gameServerId: string,
      moduleId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleInstallationOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetModuleInstallation(
        gameServerId,
        moduleId,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['GameServerApi.gameServerControllerGetModuleInstallation']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetch a gameserver by id Required permissions: `READ_GAMESERVERS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetch a list of players on a gameserver. Requires gameserver to be online and reachable. Required permissions: `READ_PLAYERS`
     * @summary Get players
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerGetPlayers(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetPlayers(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerGetPlayers']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetch gameserver types (7dtd, Rust, ...) Required permissions: `READ_GAMESERVERS`
     * @summary Get types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerGetTypes(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerTypesOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGetTypes(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerGetTypes']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Give an item to a player. Requires gameserver to be online and reachable. Depending on the underlying game implementation, it\'s possible that the item is dropped on the ground instead of placed directly in the player\'s inventory. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Give item
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {GiveItemInputDTO} [giveItemInputDTO] GiveItemInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerGiveItem(
      gameServerId: string,
      playerId: string,
      giveItemInputDTO?: GiveItemInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerGiveItem(
        gameServerId,
        playerId,
        giveItemInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerGiveItem']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Import a gameserver from CSMM. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Import from csmm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerImportFromCSMM(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerImportFromCSMM(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerImportFromCSMM']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Install a module on a gameserver. If the module is already installed, it will be updated. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Install module
     * @param {string} gameServerId
     * @param {string} moduleId
     * @param {ModuleInstallDTO} [moduleInstallDTO] ModuleInstallDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerInstallModule(
      gameServerId: string,
      moduleId: string,
      moduleInstallDTO?: ModuleInstallDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleInstallationOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerInstallModule(
        gameServerId,
        moduleId,
        moduleInstallDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerInstallModule']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Kick a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Kick player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {KickPlayerInputDTO} [kickPlayerInputDTO] KickPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerKickPlayer(
      gameServerId: string,
      playerId: string,
      kickPlayerInputDTO?: KickPlayerInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerKickPlayer(
        gameServerId,
        playerId,
        kickPlayerInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerKickPlayer']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * List bans for a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary List bans
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerListBans(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BanPlayerOutputDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerListBans(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerListBans']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Delete a gameserver Required permissions: `MANAGE_GAMESERVERS`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerRemove(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerRemove(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerRemove']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Fetch gameservers Required permissions: `READ_GAMESERVERS`
     * @summary Search
     * @param {GameServerSearchInputDTO} [gameServerSearchInputDTO] GameServerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerSearch(
      gameServerSearchInputDTO?: GameServerSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerSearch(
        gameServerSearchInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Send a message in gameserver chat. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Send message
     * @param {string} id
     * @param {MessageSendInputDTO} [messageSendInputDTO] MessageSendInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerSendMessage(
      id: string,
      messageSendInputDTO?: MessageSendInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerSendMessage(
        id,
        messageSendInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerSendMessage']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Teleport a player to a location. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Teleport player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {TeleportPlayerInputDTO} [teleportPlayerInputDTO] TeleportPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerTeleportPlayer(
      gameServerId: string,
      playerId: string,
      teleportPlayerInputDTO?: TeleportPlayerInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerTeleportPlayer(
        gameServerId,
        playerId,
        teleportPlayerInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerTeleportPlayer']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Test if Takaro can connect to a gameserver. Will do a thorough check and report details. Required permissions: `READ_GAMESERVERS`
     * @summary Test reachability
     * @param {GameServerTestReachabilityInputDTO} [gameServerTestReachabilityInputDTO] GameServerTestReachabilityInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerTestReachability(
      gameServerTestReachabilityInputDTO?: GameServerTestReachabilityInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerTestReachabilityDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerTestReachability(
        gameServerTestReachabilityInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerTestReachability']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Test if Takaro can connect to a gameserver. Will do a thorough check and report details. Required permissions: `READ_GAMESERVERS`
     * @summary Test reachability for id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerTestReachabilityForId(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerTestReachabilityDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerTestReachabilityForId(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['GameServerApi.gameServerControllerTestReachabilityForId']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Unban a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Unban player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerUnbanPlayer(
      gameServerId: string,
      playerId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerUnbanPlayer(
        gameServerId,
        playerId,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerUnbanPlayer']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Uninstall a module from a gameserver. This will not delete the module from the database. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Uninstall module
     * @param {string} gameServerId
     * @param {string} moduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerUninstallModule(
      gameServerId: string,
      moduleId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleInstallationOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerUninstallModule(
        gameServerId,
        moduleId,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerUninstallModule']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Update a gameserver Required permissions: `MANAGE_GAMESERVERS`
     * @summary Update
     * @param {string} id
     * @param {GameServerUpdateDTO} [gameServerUpdateDTO] GameServerUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async gameServerControllerUpdate(
      id: string,
      gameServerUpdateDTO?: GameServerUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GameServerOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.gameServerControllerUpdate(
        id,
        gameServerUpdateDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['GameServerApi.gameServerControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * GameServerApi - factory interface
 * @export
 */
export const GameServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = GameServerApiFp(configuration);
  return {
    /**
     * Ban a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Ban player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {BanPlayerInputDTO} [banPlayerInputDTO] BanPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerBanPlayer(
      gameServerId: string,
      playerId: string,
      banPlayerInputDTO?: BanPlayerInputDTO,
      options?: any
    ): AxiosPromise<APIOutput> {
      return localVarFp
        .gameServerControllerBanPlayer(gameServerId, playerId, banPlayerInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a gameserver Required permissions: `MANAGE_GAMESERVERS`
     * @summary Create
     * @param {GameServerCreateDTO} [gameServerCreateDTO] GameServerCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerCreate(
      gameServerCreateDTO?: GameServerCreateDTO,
      options?: any
    ): AxiosPromise<GameServerOutputDTOAPI> {
      return localVarFp
        .gameServerControllerCreate(gameServerCreateDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Execute a raw command on a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Execute command
     * @param {string} id
     * @param {CommandExecuteInputDTO} [commandExecuteInputDTO] CommandExecuteInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerExecuteCommand(
      id: string,
      commandExecuteInputDTO?: CommandExecuteInputDTO,
      options?: any
    ): AxiosPromise<CommandExecuteDTOAPI> {
      return localVarFp
        .gameServerControllerExecuteCommand(id, commandExecuteInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch status of an import from CSMM Required permissions: `MANAGE_GAMESERVERS`
     * @summary Get import
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetImport(id: string, options?: any): AxiosPromise<ImportOutputDTOAPI> {
      return localVarFp.gameServerControllerGetImport(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Get all module installations for a gameserver Required permissions: `READ_GAMESERVERS`
     * @summary Get installed modules
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetInstalledModules(
      id: string,
      options?: any
    ): AxiosPromise<ModuleInstallationOutputArrayDTOAPI> {
      return localVarFp
        .gameServerControllerGetInstalledModules(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a module installation by id Required permissions: `READ_GAMESERVERS`
     * @summary Get module installation
     * @param {string} gameServerId
     * @param {string} moduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetModuleInstallation(
      gameServerId: string,
      moduleId: string,
      options?: any
    ): AxiosPromise<ModuleInstallationOutputDTOAPI> {
      return localVarFp
        .gameServerControllerGetModuleInstallation(gameServerId, moduleId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch a gameserver by id Required permissions: `READ_GAMESERVERS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetOne(id: string, options?: any): AxiosPromise<GameServerOutputDTOAPI> {
      return localVarFp.gameServerControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Fetch a list of players on a gameserver. Requires gameserver to be online and reachable. Required permissions: `READ_PLAYERS`
     * @summary Get players
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetPlayers(id: string, options?: any): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
      return localVarFp.gameServerControllerGetPlayers(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Fetch gameserver types (7dtd, Rust, ...) Required permissions: `READ_GAMESERVERS`
     * @summary Get types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGetTypes(options?: any): AxiosPromise<GameServerTypesOutputDTOAPI> {
      return localVarFp.gameServerControllerGetTypes(options).then((request) => request(axios, basePath));
    },
    /**
     * Give an item to a player. Requires gameserver to be online and reachable. Depending on the underlying game implementation, it\'s possible that the item is dropped on the ground instead of placed directly in the player\'s inventory. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Give item
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {GiveItemInputDTO} [giveItemInputDTO] GiveItemInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerGiveItem(
      gameServerId: string,
      playerId: string,
      giveItemInputDTO?: GiveItemInputDTO,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .gameServerControllerGiveItem(gameServerId, playerId, giveItemInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Import a gameserver from CSMM. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Import from csmm
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerImportFromCSMM(options?: any): AxiosPromise<ImportOutputDTOAPI> {
      return localVarFp.gameServerControllerImportFromCSMM(options).then((request) => request(axios, basePath));
    },
    /**
     * Install a module on a gameserver. If the module is already installed, it will be updated. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Install module
     * @param {string} gameServerId
     * @param {string} moduleId
     * @param {ModuleInstallDTO} [moduleInstallDTO] ModuleInstallDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerInstallModule(
      gameServerId: string,
      moduleId: string,
      moduleInstallDTO?: ModuleInstallDTO,
      options?: any
    ): AxiosPromise<ModuleInstallationOutputDTOAPI> {
      return localVarFp
        .gameServerControllerInstallModule(gameServerId, moduleId, moduleInstallDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Kick a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Kick player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {KickPlayerInputDTO} [kickPlayerInputDTO] KickPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerKickPlayer(
      gameServerId: string,
      playerId: string,
      kickPlayerInputDTO?: KickPlayerInputDTO,
      options?: any
    ): AxiosPromise<APIOutput> {
      return localVarFp
        .gameServerControllerKickPlayer(gameServerId, playerId, kickPlayerInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List bans for a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary List bans
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerListBans(id: string, options?: any): AxiosPromise<BanPlayerOutputDTO> {
      return localVarFp.gameServerControllerListBans(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Delete a gameserver Required permissions: `MANAGE_GAMESERVERS`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerRemove(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.gameServerControllerRemove(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Fetch gameservers Required permissions: `READ_GAMESERVERS`
     * @summary Search
     * @param {GameServerSearchInputDTO} [gameServerSearchInputDTO] GameServerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerSearch(
      gameServerSearchInputDTO?: GameServerSearchInputDTO,
      options?: any
    ): AxiosPromise<GameServerOutputArrayDTOAPI> {
      return localVarFp
        .gameServerControllerSearch(gameServerSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Send a message in gameserver chat. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Send message
     * @param {string} id
     * @param {MessageSendInputDTO} [messageSendInputDTO] MessageSendInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerSendMessage(
      id: string,
      messageSendInputDTO?: MessageSendInputDTO,
      options?: any
    ): AxiosPromise<APIOutput> {
      return localVarFp
        .gameServerControllerSendMessage(id, messageSendInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Teleport a player to a location. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Teleport player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {TeleportPlayerInputDTO} [teleportPlayerInputDTO] TeleportPlayerInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerTeleportPlayer(
      gameServerId: string,
      playerId: string,
      teleportPlayerInputDTO?: TeleportPlayerInputDTO,
      options?: any
    ): AxiosPromise<APIOutput> {
      return localVarFp
        .gameServerControllerTeleportPlayer(gameServerId, playerId, teleportPlayerInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Test if Takaro can connect to a gameserver. Will do a thorough check and report details. Required permissions: `READ_GAMESERVERS`
     * @summary Test reachability
     * @param {GameServerTestReachabilityInputDTO} [gameServerTestReachabilityInputDTO] GameServerTestReachabilityInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerTestReachability(
      gameServerTestReachabilityInputDTO?: GameServerTestReachabilityInputDTO,
      options?: any
    ): AxiosPromise<GameServerTestReachabilityDTOAPI> {
      return localVarFp
        .gameServerControllerTestReachability(gameServerTestReachabilityInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Test if Takaro can connect to a gameserver. Will do a thorough check and report details. Required permissions: `READ_GAMESERVERS`
     * @summary Test reachability for id
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerTestReachabilityForId(
      id: string,
      options?: any
    ): AxiosPromise<GameServerTestReachabilityDTOAPI> {
      return localVarFp
        .gameServerControllerTestReachabilityForId(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unban a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Unban player
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerUnbanPlayer(gameServerId: string, playerId: string, options?: any): AxiosPromise<APIOutput> {
      return localVarFp
        .gameServerControllerUnbanPlayer(gameServerId, playerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Uninstall a module from a gameserver. This will not delete the module from the database. Required permissions: `MANAGE_GAMESERVERS`
     * @summary Uninstall module
     * @param {string} gameServerId
     * @param {string} moduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerUninstallModule(
      gameServerId: string,
      moduleId: string,
      options?: any
    ): AxiosPromise<ModuleInstallationOutputDTOAPI> {
      return localVarFp
        .gameServerControllerUninstallModule(gameServerId, moduleId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a gameserver Required permissions: `MANAGE_GAMESERVERS`
     * @summary Update
     * @param {string} id
     * @param {GameServerUpdateDTO} [gameServerUpdateDTO] GameServerUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gameServerControllerUpdate(
      id: string,
      gameServerUpdateDTO?: GameServerUpdateDTO,
      options?: any
    ): AxiosPromise<GameServerOutputDTOAPI> {
      return localVarFp
        .gameServerControllerUpdate(id, gameServerUpdateDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * GameServerApi - object-oriented interface
 * @export
 * @class GameServerApi
 * @extends {BaseAPI}
 */
export class GameServerApi extends BaseAPI {
  /**
   * Ban a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Ban player
   * @param {string} gameServerId
   * @param {string} playerId
   * @param {BanPlayerInputDTO} [banPlayerInputDTO] BanPlayerInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerBanPlayer(
    gameServerId: string,
    playerId: string,
    banPlayerInputDTO?: BanPlayerInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerBanPlayer(gameServerId, playerId, banPlayerInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a gameserver Required permissions: `MANAGE_GAMESERVERS`
   * @summary Create
   * @param {GameServerCreateDTO} [gameServerCreateDTO] GameServerCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerCreate(gameServerCreateDTO?: GameServerCreateDTO, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerCreate(gameServerCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Execute a raw command on a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Execute command
   * @param {string} id
   * @param {CommandExecuteInputDTO} [commandExecuteInputDTO] CommandExecuteInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerExecuteCommand(
    id: string,
    commandExecuteInputDTO?: CommandExecuteInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerExecuteCommand(id, commandExecuteInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch status of an import from CSMM Required permissions: `MANAGE_GAMESERVERS`
   * @summary Get import
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerGetImport(id: string, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerGetImport(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get all module installations for a gameserver Required permissions: `READ_GAMESERVERS`
   * @summary Get installed modules
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerGetInstalledModules(id: string, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerGetInstalledModules(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a module installation by id Required permissions: `READ_GAMESERVERS`
   * @summary Get module installation
   * @param {string} gameServerId
   * @param {string} moduleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerGetModuleInstallation(
    gameServerId: string,
    moduleId: string,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerGetModuleInstallation(gameServerId, moduleId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch a gameserver by id Required permissions: `READ_GAMESERVERS`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch a list of players on a gameserver. Requires gameserver to be online and reachable. Required permissions: `READ_PLAYERS`
   * @summary Get players
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerGetPlayers(id: string, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerGetPlayers(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch gameserver types (7dtd, Rust, ...) Required permissions: `READ_GAMESERVERS`
   * @summary Get types
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerGetTypes(options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerGetTypes(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Give an item to a player. Requires gameserver to be online and reachable. Depending on the underlying game implementation, it\'s possible that the item is dropped on the ground instead of placed directly in the player\'s inventory. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Give item
   * @param {string} gameServerId
   * @param {string} playerId
   * @param {GiveItemInputDTO} [giveItemInputDTO] GiveItemInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerGiveItem(
    gameServerId: string,
    playerId: string,
    giveItemInputDTO?: GiveItemInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerGiveItem(gameServerId, playerId, giveItemInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Import a gameserver from CSMM. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Import from csmm
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerImportFromCSMM(options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerImportFromCSMM(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Install a module on a gameserver. If the module is already installed, it will be updated. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Install module
   * @param {string} gameServerId
   * @param {string} moduleId
   * @param {ModuleInstallDTO} [moduleInstallDTO] ModuleInstallDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerInstallModule(
    gameServerId: string,
    moduleId: string,
    moduleInstallDTO?: ModuleInstallDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerInstallModule(gameServerId, moduleId, moduleInstallDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Kick a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Kick player
   * @param {string} gameServerId
   * @param {string} playerId
   * @param {KickPlayerInputDTO} [kickPlayerInputDTO] KickPlayerInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerKickPlayer(
    gameServerId: string,
    playerId: string,
    kickPlayerInputDTO?: KickPlayerInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerKickPlayer(gameServerId, playerId, kickPlayerInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List bans for a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
   * @summary List bans
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerListBans(id: string, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerListBans(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a gameserver Required permissions: `MANAGE_GAMESERVERS`
   * @summary Remove
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerRemove(id: string, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Fetch gameservers Required permissions: `READ_GAMESERVERS`
   * @summary Search
   * @param {GameServerSearchInputDTO} [gameServerSearchInputDTO] GameServerSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerSearch(
    gameServerSearchInputDTO?: GameServerSearchInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerSearch(gameServerSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Send a message in gameserver chat. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Send message
   * @param {string} id
   * @param {MessageSendInputDTO} [messageSendInputDTO] MessageSendInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerSendMessage(
    id: string,
    messageSendInputDTO?: MessageSendInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerSendMessage(id, messageSendInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Teleport a player to a location. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Teleport player
   * @param {string} gameServerId
   * @param {string} playerId
   * @param {TeleportPlayerInputDTO} [teleportPlayerInputDTO] TeleportPlayerInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerTeleportPlayer(
    gameServerId: string,
    playerId: string,
    teleportPlayerInputDTO?: TeleportPlayerInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerTeleportPlayer(gameServerId, playerId, teleportPlayerInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Test if Takaro can connect to a gameserver. Will do a thorough check and report details. Required permissions: `READ_GAMESERVERS`
   * @summary Test reachability
   * @param {GameServerTestReachabilityInputDTO} [gameServerTestReachabilityInputDTO] GameServerTestReachabilityInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerTestReachability(
    gameServerTestReachabilityInputDTO?: GameServerTestReachabilityInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerTestReachability(gameServerTestReachabilityInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Test if Takaro can connect to a gameserver. Will do a thorough check and report details. Required permissions: `READ_GAMESERVERS`
   * @summary Test reachability for id
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerTestReachabilityForId(id: string, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerTestReachabilityForId(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Unban a player from a gameserver. Requires gameserver to be online and reachable. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Unban player
   * @param {string} gameServerId
   * @param {string} playerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerUnbanPlayer(gameServerId: string, playerId: string, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerUnbanPlayer(gameServerId, playerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Uninstall a module from a gameserver. This will not delete the module from the database. Required permissions: `MANAGE_GAMESERVERS`
   * @summary Uninstall module
   * @param {string} gameServerId
   * @param {string} moduleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerUninstallModule(gameServerId: string, moduleId: string, options?: RawAxiosRequestConfig) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerUninstallModule(gameServerId, moduleId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a gameserver Required permissions: `MANAGE_GAMESERVERS`
   * @summary Update
   * @param {string} id
   * @param {GameServerUpdateDTO} [gameServerUpdateDTO] GameServerUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof GameServerApi
   */
  public gameServerControllerUpdate(
    id: string,
    gameServerUpdateDTO?: GameServerUpdateDTO,
    options?: RawAxiosRequestConfig
  ) {
    return GameServerApiFp(this.configuration)
      .gameServerControllerUpdate(id, gameServerUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * HookApi - axios parameter creator
 * @export
 */
export const HookApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {HookCreateDTO} [hookCreateDTO] HookCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerCreate: async (
      hookCreateDTO?: HookCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/hook`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hookCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('hookControllerGetOne', 'id', id);
      const localVarPath = `/hook/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('hookControllerRemove', 'id', id);
      const localVarPath = `/hook/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {HookSearchInputDTO} [hookSearchInputDTO] HookSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerSearch: async (
      hookSearchInputDTO?: HookSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/hook/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hookSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Trigger a hook. This is used for testing purposes, the event will not actually be created but the hook-logic will be executed.      You can pass any data you want, but it must validate against the corresponding event metadata. Eg to trigger the `chat-message` event, you must pass an object with a `message` property Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {HookTriggerDTO} [hookTriggerDTO] HookTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerTrigger: async (
      hookTriggerDTO?: HookTriggerDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/hook/trigger`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hookTriggerDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {HookUpdateDTO} [hookUpdateDTO] HookUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerUpdate: async (
      id: string,
      hookUpdateDTO?: HookUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('hookControllerUpdate', 'id', id);
      const localVarPath = `/hook/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(hookUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * HookApi - functional programming interface
 * @export
 */
export const HookApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = HookApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {HookCreateDTO} [hookCreateDTO] HookCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hookControllerCreate(
      hookCreateDTO?: HookCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerCreate(hookCreateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['HookApi.hookControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hookControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['HookApi.hookControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hookControllerRemove(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerRemove(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['HookApi.hookControllerRemove']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {HookSearchInputDTO} [hookSearchInputDTO] HookSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hookControllerSearch(
      hookSearchInputDTO?: HookSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerSearch(hookSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['HookApi.hookControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     * Trigger a hook. This is used for testing purposes, the event will not actually be created but the hook-logic will be executed.      You can pass any data you want, but it must validate against the corresponding event metadata. Eg to trigger the `chat-message` event, you must pass an object with a `message` property Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {HookTriggerDTO} [hookTriggerDTO] HookTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hookControllerTrigger(
      hookTriggerDTO?: HookTriggerDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerTrigger(hookTriggerDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['HookApi.hookControllerTrigger']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {HookUpdateDTO} [hookUpdateDTO] HookUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async hookControllerUpdate(
      id: string,
      hookUpdateDTO?: HookUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HookOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.hookControllerUpdate(id, hookUpdateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['HookApi.hookControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * HookApi - factory interface
 * @export
 */
export const HookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = HookApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {HookCreateDTO} [hookCreateDTO] HookCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerCreate(hookCreateDTO?: HookCreateDTO, options?: any): AxiosPromise<HookOutputDTOAPI> {
      return localVarFp.hookControllerCreate(hookCreateDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerGetOne(id: string, options?: any): AxiosPromise<HookOutputDTOAPI> {
      return localVarFp.hookControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerRemove(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.hookControllerRemove(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {HookSearchInputDTO} [hookSearchInputDTO] HookSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerSearch(hookSearchInputDTO?: HookSearchInputDTO, options?: any): AxiosPromise<HookOutputArrayDTOAPI> {
      return localVarFp.hookControllerSearch(hookSearchInputDTO, options).then((request) => request(axios, basePath));
    },
    /**
     * Trigger a hook. This is used for testing purposes, the event will not actually be created but the hook-logic will be executed.      You can pass any data you want, but it must validate against the corresponding event metadata. Eg to trigger the `chat-message` event, you must pass an object with a `message` property Required permissions: `MANAGE_MODULES`
     * @summary Trigger
     * @param {HookTriggerDTO} [hookTriggerDTO] HookTriggerDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerTrigger(hookTriggerDTO?: HookTriggerDTO, options?: any): AxiosPromise<void> {
      return localVarFp.hookControllerTrigger(hookTriggerDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {HookUpdateDTO} [hookUpdateDTO] HookUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    hookControllerUpdate(id: string, hookUpdateDTO?: HookUpdateDTO, options?: any): AxiosPromise<HookOutputDTOAPI> {
      return localVarFp.hookControllerUpdate(id, hookUpdateDTO, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * HookApi - object-oriented interface
 * @export
 * @class HookApi
 * @extends {BaseAPI}
 */
export class HookApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Create
   * @param {HookCreateDTO} [hookCreateDTO] HookCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HookApi
   */
  public hookControllerCreate(hookCreateDTO?: HookCreateDTO, options?: RawAxiosRequestConfig) {
    return HookApiFp(this.configuration)
      .hookControllerCreate(hookCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HookApi
   */
  public hookControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return HookApiFp(this.configuration)
      .hookControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Remove
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HookApi
   */
  public hookControllerRemove(id: string, options?: RawAxiosRequestConfig) {
    return HookApiFp(this.configuration)
      .hookControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Search
   * @param {HookSearchInputDTO} [hookSearchInputDTO] HookSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HookApi
   */
  public hookControllerSearch(hookSearchInputDTO?: HookSearchInputDTO, options?: RawAxiosRequestConfig) {
    return HookApiFp(this.configuration)
      .hookControllerSearch(hookSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Trigger a hook. This is used for testing purposes, the event will not actually be created but the hook-logic will be executed.      You can pass any data you want, but it must validate against the corresponding event metadata. Eg to trigger the `chat-message` event, you must pass an object with a `message` property Required permissions: `MANAGE_MODULES`
   * @summary Trigger
   * @param {HookTriggerDTO} [hookTriggerDTO] HookTriggerDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HookApi
   */
  public hookControllerTrigger(hookTriggerDTO?: HookTriggerDTO, options?: RawAxiosRequestConfig) {
    return HookApiFp(this.configuration)
      .hookControllerTrigger(hookTriggerDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Update
   * @param {string} id
   * @param {HookUpdateDTO} [hookUpdateDTO] HookUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof HookApi
   */
  public hookControllerUpdate(id: string, hookUpdateDTO?: HookUpdateDTO, options?: RawAxiosRequestConfig) {
    return HookApiFp(this.configuration)
      .hookControllerUpdate(id, hookUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_ITEMS`
     * @summary Create
     * @param {ItemCreateDTO} [itemCreateDTO] ItemCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerCreate: async (
      itemCreateDTO?: ItemCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(itemCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_ITEMS`
     * @summary Delete
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('itemControllerDelete', 'id', id);
      const localVarPath = `/items/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_ITEMS`
     * @summary Find one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('itemControllerFindOne', 'id', id);
      const localVarPath = `/items/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_ITEMS`
     * @summary Search
     * @param {ItemSearchInputDTO} [itemSearchInputDTO] ItemSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerSearch: async (
      itemSearchInputDTO?: ItemSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/items/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(itemSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_ITEMS`
     * @summary Update
     * @param {string} id
     * @param {ItemUpdateDTO} [itemUpdateDTO] ItemUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerUpdate: async (
      id: string,
      itemUpdateDTO?: ItemUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('itemControllerUpdate', 'id', id);
      const localVarPath = `/items/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(itemUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_ITEMS`
     * @summary Create
     * @param {ItemCreateDTO} [itemCreateDTO] ItemCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async itemControllerCreate(
      itemCreateDTO?: ItemCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerCreate(itemCreateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ItemApi.itemControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_ITEMS`
     * @summary Delete
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async itemControllerDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerDelete(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ItemApi.itemControllerDelete']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_ITEMS`
     * @summary Find one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async itemControllerFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerFindOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ItemApi.itemControllerFindOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_ITEMS`
     * @summary Search
     * @param {ItemSearchInputDTO} [itemSearchInputDTO] ItemSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async itemControllerSearch(
      itemSearchInputDTO?: ItemSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerSearch(itemSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ItemApi.itemControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_ITEMS`
     * @summary Update
     * @param {string} id
     * @param {ItemUpdateDTO} [itemUpdateDTO] ItemUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async itemControllerUpdate(
      id: string,
      itemUpdateDTO?: ItemUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.itemControllerUpdate(id, itemUpdateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ItemApi.itemControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ItemApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_ITEMS`
     * @summary Create
     * @param {ItemCreateDTO} [itemCreateDTO] ItemCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerCreate(itemCreateDTO?: ItemCreateDTO, options?: any): AxiosPromise<ItemOutputDTOAPI> {
      return localVarFp.itemControllerCreate(itemCreateDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_ITEMS`
     * @summary Delete
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerDelete(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.itemControllerDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_ITEMS`
     * @summary Find one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerFindOne(id: string, options?: any): AxiosPromise<ItemOutputDTOAPI> {
      return localVarFp.itemControllerFindOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_ITEMS`
     * @summary Search
     * @param {ItemSearchInputDTO} [itemSearchInputDTO] ItemSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerSearch(itemSearchInputDTO?: ItemSearchInputDTO, options?: any): AxiosPromise<ItemOutputArrayDTOAPI> {
      return localVarFp.itemControllerSearch(itemSearchInputDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_ITEMS`
     * @summary Update
     * @param {string} id
     * @param {ItemUpdateDTO} [itemUpdateDTO] ItemUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    itemControllerUpdate(id: string, itemUpdateDTO?: ItemUpdateDTO, options?: any): AxiosPromise<ItemOutputDTOAPI> {
      return localVarFp.itemControllerUpdate(id, itemUpdateDTO, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_ITEMS`
   * @summary Create
   * @param {ItemCreateDTO} [itemCreateDTO] ItemCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemApi
   */
  public itemControllerCreate(itemCreateDTO?: ItemCreateDTO, options?: RawAxiosRequestConfig) {
    return ItemApiFp(this.configuration)
      .itemControllerCreate(itemCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_ITEMS`
   * @summary Delete
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemApi
   */
  public itemControllerDelete(id: string, options?: RawAxiosRequestConfig) {
    return ItemApiFp(this.configuration)
      .itemControllerDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_ITEMS`
   * @summary Find one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemApi
   */
  public itemControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
    return ItemApiFp(this.configuration)
      .itemControllerFindOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_ITEMS`
   * @summary Search
   * @param {ItemSearchInputDTO} [itemSearchInputDTO] ItemSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemApi
   */
  public itemControllerSearch(itemSearchInputDTO?: ItemSearchInputDTO, options?: RawAxiosRequestConfig) {
    return ItemApiFp(this.configuration)
      .itemControllerSearch(itemSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_ITEMS`
   * @summary Update
   * @param {string} id
   * @param {ItemUpdateDTO} [itemUpdateDTO] ItemUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ItemApi
   */
  public itemControllerUpdate(id: string, itemUpdateDTO?: ItemUpdateDTO, options?: RawAxiosRequestConfig) {
    return ItemApiFp(this.configuration)
      .itemControllerUpdate(id, itemUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MetaApi - axios parameter creator
 * @export
 */
export const MetaApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetHealth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/healthz`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetMetrics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/metrics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get open api
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetOpenApi: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/openapi.json`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get open api html
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetOpenApiHtml: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api.html`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get readiness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetReadiness: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/readyz`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MetaApi - functional programming interface
 * @export
 */
export const MetaApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = MetaApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Get health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaGetHealth(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthOutputDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetHealth(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['MetaApi.metaGetHealth']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaGetMetrics(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetMetrics(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['MetaApi.metaGetMetrics']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get open api
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaGetOpenApi(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetOpenApi(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['MetaApi.metaGetOpenApi']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get open api html
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaGetOpenApiHtml(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetOpenApiHtml(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['MetaApi.metaGetOpenApiHtml']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get readiness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async metaGetReadiness(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthOutputDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.metaGetReadiness(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['MetaApi.metaGetReadiness']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * MetaApi - factory interface
 * @export
 */
export const MetaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = MetaApiFp(configuration);
  return {
    /**
     *
     * @summary Get health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetHealth(options?: any): AxiosPromise<HealthOutputDTO> {
      return localVarFp.metaGetHealth(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get metrics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetMetrics(options?: any): AxiosPromise<void> {
      return localVarFp.metaGetMetrics(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get open api
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetOpenApi(options?: any): AxiosPromise<void> {
      return localVarFp.metaGetOpenApi(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get open api html
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetOpenApiHtml(options?: any): AxiosPromise<void> {
      return localVarFp.metaGetOpenApiHtml(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get readiness
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metaGetReadiness(options?: any): AxiosPromise<HealthOutputDTO> {
      return localVarFp.metaGetReadiness(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * MetaApi - object-oriented interface
 * @export
 * @class MetaApi
 * @extends {BaseAPI}
 */
export class MetaApi extends BaseAPI {
  /**
   *
   * @summary Get health
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaGetHealth(options?: RawAxiosRequestConfig) {
    return MetaApiFp(this.configuration)
      .metaGetHealth(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get metrics
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaGetMetrics(options?: RawAxiosRequestConfig) {
    return MetaApiFp(this.configuration)
      .metaGetMetrics(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get open api
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaGetOpenApi(options?: RawAxiosRequestConfig) {
    return MetaApiFp(this.configuration)
      .metaGetOpenApi(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get open api html
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaGetOpenApiHtml(options?: RawAxiosRequestConfig) {
    return MetaApiFp(this.configuration)
      .metaGetOpenApiHtml(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get readiness
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MetaApi
   */
  public metaGetReadiness(options?: RawAxiosRequestConfig) {
    return MetaApiFp(this.configuration)
      .metaGetReadiness(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ModuleApi - axios parameter creator
 * @export
 */
export const ModuleApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {ModuleCreateDTO} [moduleCreateDTO] ModuleCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerCreate: async (
      moduleCreateDTO?: ModuleCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/module`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(moduleCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('moduleControllerGetOne', 'id', id);
      const localVarPath = `/module/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('moduleControllerRemove', 'id', id);
      const localVarPath = `/module/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {ModuleSearchInputDTO} [moduleSearchInputDTO] ModuleSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerSearch: async (
      moduleSearchInputDTO?: ModuleSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/module/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(moduleSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {ModuleUpdateDTO} [moduleUpdateDTO] ModuleUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerUpdate: async (
      id: string,
      moduleUpdateDTO?: ModuleUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('moduleControllerUpdate', 'id', id);
      const localVarPath = `/module/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(moduleUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ModuleApi - functional programming interface
 * @export
 */
export const ModuleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ModuleApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {ModuleCreateDTO} [moduleCreateDTO] ModuleCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moduleControllerCreate(
      moduleCreateDTO?: ModuleCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerCreate(moduleCreateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ModuleApi.moduleControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moduleControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ModuleApi.moduleControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moduleControllerRemove(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerRemove(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ModuleApi.moduleControllerRemove']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {ModuleSearchInputDTO} [moduleSearchInputDTO] ModuleSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moduleControllerSearch(
      moduleSearchInputDTO?: ModuleSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerSearch(moduleSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ModuleApi.moduleControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {ModuleUpdateDTO} [moduleUpdateDTO] ModuleUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async moduleControllerUpdate(
      id: string,
      moduleUpdateDTO?: ModuleUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.moduleControllerUpdate(id, moduleUpdateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['ModuleApi.moduleControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * ModuleApi - factory interface
 * @export
 */
export const ModuleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = ModuleApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Create
     * @param {ModuleCreateDTO} [moduleCreateDTO] ModuleCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerCreate(moduleCreateDTO?: ModuleCreateDTO, options?: any): AxiosPromise<ModuleOutputDTOAPI> {
      return localVarFp.moduleControllerCreate(moduleCreateDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerGetOne(id: string, options?: any): AxiosPromise<ModuleOutputDTOAPI> {
      return localVarFp.moduleControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerRemove(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.moduleControllerRemove(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_MODULES`
     * @summary Search
     * @param {ModuleSearchInputDTO} [moduleSearchInputDTO] ModuleSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerSearch(
      moduleSearchInputDTO?: ModuleSearchInputDTO,
      options?: any
    ): AxiosPromise<ModuleOutputArrayDTOAPI> {
      return localVarFp
        .moduleControllerSearch(moduleSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_MODULES`
     * @summary Update
     * @param {string} id
     * @param {ModuleUpdateDTO} [moduleUpdateDTO] ModuleUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    moduleControllerUpdate(
      id: string,
      moduleUpdateDTO?: ModuleUpdateDTO,
      options?: any
    ): AxiosPromise<ModuleOutputDTOAPI> {
      return localVarFp
        .moduleControllerUpdate(id, moduleUpdateDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ModuleApi - object-oriented interface
 * @export
 * @class ModuleApi
 * @extends {BaseAPI}
 */
export class ModuleApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Create
   * @param {ModuleCreateDTO} [moduleCreateDTO] ModuleCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModuleApi
   */
  public moduleControllerCreate(moduleCreateDTO?: ModuleCreateDTO, options?: RawAxiosRequestConfig) {
    return ModuleApiFp(this.configuration)
      .moduleControllerCreate(moduleCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModuleApi
   */
  public moduleControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return ModuleApiFp(this.configuration)
      .moduleControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Remove
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModuleApi
   */
  public moduleControllerRemove(id: string, options?: RawAxiosRequestConfig) {
    return ModuleApiFp(this.configuration)
      .moduleControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_MODULES`
   * @summary Search
   * @param {ModuleSearchInputDTO} [moduleSearchInputDTO] ModuleSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModuleApi
   */
  public moduleControllerSearch(moduleSearchInputDTO?: ModuleSearchInputDTO, options?: RawAxiosRequestConfig) {
    return ModuleApiFp(this.configuration)
      .moduleControllerSearch(moduleSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_MODULES`
   * @summary Update
   * @param {string} id
   * @param {ModuleUpdateDTO} [moduleUpdateDTO] ModuleUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ModuleApi
   */
  public moduleControllerUpdate(id: string, moduleUpdateDTO?: ModuleUpdateDTO, options?: RawAxiosRequestConfig) {
    return ModuleApiFp(this.configuration)
      .moduleControllerUpdate(id, moduleUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PlayerApi - axios parameter creator
 * @export
 */
export const PlayerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
     * @summary Assign role
     * @param {string} id
     * @param {string} roleId
     * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerControllerAssignRole: async (
      id: string,
      roleId: string,
      playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('playerControllerAssignRole', 'id', id);
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists('playerControllerAssignRole', 'roleId', roleId);
      const localVarPath = `/player/{id}/role/{roleId}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'roleId'}}`, encodeURIComponent(String(roleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerRoleAssignChangeDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('playerControllerGetOne', 'id', id);
      const localVarPath = `/player/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
     * @summary Remove role
     * @param {string} id
     * @param {string} roleId
     * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerControllerRemoveRole: async (
      id: string,
      roleId: string,
      playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('playerControllerRemoveRole', 'id', id);
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists('playerControllerRemoveRole', 'roleId', roleId);
      const localVarPath = `/player/{id}/role/{roleId}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'roleId'}}`, encodeURIComponent(String(roleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerRoleAssignChangeDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Search
     * @param {PlayerSearchInputDTO} [playerSearchInputDTO] PlayerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerControllerSearch: async (
      playerSearchInputDTO?: PlayerSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/player/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(playerSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlayerApi - functional programming interface
 * @export
 */
export const PlayerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PlayerApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
     * @summary Assign role
     * @param {string} id
     * @param {string} roleId
     * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerControllerAssignRole(
      id: string,
      roleId: string,
      playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerControllerAssignRole(
        id,
        roleId,
        playerRoleAssignChangeDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['PlayerApi.playerControllerAssignRole']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOutputWithRolesDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['PlayerApi.playerControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
     * @summary Remove role
     * @param {string} id
     * @param {string} roleId
     * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerControllerRemoveRole(
      id: string,
      roleId: string,
      playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerControllerRemoveRole(
        id,
        roleId,
        playerRoleAssignChangeDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['PlayerApi.playerControllerRemoveRole']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Search
     * @param {PlayerSearchInputDTO} [playerSearchInputDTO] PlayerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerControllerSearch(
      playerSearchInputDTO?: PlayerSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerControllerSearch(playerSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['PlayerApi.playerControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * PlayerApi - factory interface
 * @export
 */
export const PlayerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = PlayerApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
     * @summary Assign role
     * @param {string} id
     * @param {string} roleId
     * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerControllerAssignRole(
      id: string,
      roleId: string,
      playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO,
      options?: any
    ): AxiosPromise<APIOutput> {
      return localVarFp
        .playerControllerAssignRole(id, roleId, playerRoleAssignChangeDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerControllerGetOne(id: string, options?: any): AxiosPromise<PlayerOutputWithRolesDTOAPI> {
      return localVarFp.playerControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
     * @summary Remove role
     * @param {string} id
     * @param {string} roleId
     * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerControllerRemoveRole(
      id: string,
      roleId: string,
      playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO,
      options?: any
    ): AxiosPromise<APIOutput> {
      return localVarFp
        .playerControllerRemoveRole(id, roleId, playerRoleAssignChangeDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Search
     * @param {PlayerSearchInputDTO} [playerSearchInputDTO] PlayerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerControllerSearch(
      playerSearchInputDTO?: PlayerSearchInputDTO,
      options?: any
    ): AxiosPromise<PlayerOutputArrayDTOAPI> {
      return localVarFp
        .playerControllerSearch(playerSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PlayerApi - object-oriented interface
 * @export
 * @class PlayerApi
 * @extends {BaseAPI}
 */
export class PlayerApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
   * @summary Assign role
   * @param {string} id
   * @param {string} roleId
   * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerApi
   */
  public playerControllerAssignRole(
    id: string,
    roleId: string,
    playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO,
    options?: RawAxiosRequestConfig
  ) {
    return PlayerApiFp(this.configuration)
      .playerControllerAssignRole(id, roleId, playerRoleAssignChangeDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_PLAYERS`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerApi
   */
  public playerControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return PlayerApiFp(this.configuration)
      .playerControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_PLAYERS`, `MANAGE_ROLES`
   * @summary Remove role
   * @param {string} id
   * @param {string} roleId
   * @param {PlayerRoleAssignChangeDTO} [playerRoleAssignChangeDTO] PlayerRoleAssignChangeDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerApi
   */
  public playerControllerRemoveRole(
    id: string,
    roleId: string,
    playerRoleAssignChangeDTO?: PlayerRoleAssignChangeDTO,
    options?: RawAxiosRequestConfig
  ) {
    return PlayerApiFp(this.configuration)
      .playerControllerRemoveRole(id, roleId, playerRoleAssignChangeDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_PLAYERS`
   * @summary Search
   * @param {PlayerSearchInputDTO} [playerSearchInputDTO] PlayerSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerApi
   */
  public playerControllerSearch(playerSearchInputDTO?: PlayerSearchInputDTO, options?: RawAxiosRequestConfig) {
    return PlayerApiFp(this.configuration)
      .playerControllerSearch(playerSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PlayerOnGameServerApi - axios parameter creator
 * @export
 */
export const PlayerOnGameServerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Add currency
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerAddCurrency: async (
      gameServerId: string,
      playerId: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('playerOnGameServerControllerAddCurrency', 'gameServerId', gameServerId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('playerOnGameServerControllerAddCurrency', 'playerId', playerId);
      const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/add-currency`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'playerId'}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerOnGameServerSetCurrencyInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Deduct currency
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerDeductCurrency: async (
      gameServerId: string,
      playerId: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('playerOnGameServerControllerDeductCurrency', 'gameServerId', gameServerId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('playerOnGameServerControllerDeductCurrency', 'playerId', playerId);
      const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/deduct-currency`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'playerId'}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerOnGameServerSetCurrencyInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Get one
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerGetOne: async (
      gameServerId: string,
      playerId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('playerOnGameServerControllerGetOne', 'gameServerId', gameServerId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('playerOnGameServerControllerGetOne', 'playerId', playerId);
      const localVarPath = `/gameserver/{gameServerId}/player/{playerId}`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'playerId'}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Search
     * @param {PlayerOnGameServerSearchInputDTO} [playerOnGameServerSearchInputDTO] PlayerOnGameServerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerSearch: async (
      playerOnGameServerSearchInputDTO?: PlayerOnGameServerSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/gameserver/player/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerOnGameServerSearchInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Set currency
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerSetCurrency: async (
      gameServerId: string,
      playerId: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('playerOnGameServerControllerSetCurrency', 'gameServerId', gameServerId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists('playerOnGameServerControllerSetCurrency', 'playerId', playerId);
      const localVarPath = `/gameserver/{gameServerId}/player/{playerId}/currency`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'playerId'}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerOnGameServerSetCurrencyInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Transact between players
     * @param {string} gameServerId
     * @param {string} sender
     * @param {string} receiver
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerTransactBetweenPlayers: async (
      gameServerId: string,
      sender: string,
      receiver: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'gameServerId' is not null or undefined
      assertParamExists('playerOnGameServerControllerTransactBetweenPlayers', 'gameServerId', gameServerId);
      // verify required parameter 'sender' is not null or undefined
      assertParamExists('playerOnGameServerControllerTransactBetweenPlayers', 'sender', sender);
      // verify required parameter 'receiver' is not null or undefined
      assertParamExists('playerOnGameServerControllerTransactBetweenPlayers', 'receiver', receiver);
      const localVarPath = `/gameserver/{gameServerId}/player/{sender}/{receiver}/transfer`
        .replace(`{${'gameServerId'}}`, encodeURIComponent(String(gameServerId)))
        .replace(`{${'sender'}}`, encodeURIComponent(String(sender)))
        .replace(`{${'receiver'}}`, encodeURIComponent(String(receiver)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerOnGameServerSetCurrencyInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PlayerOnGameServerApi - functional programming interface
 * @export
 */
export const PlayerOnGameServerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PlayerOnGameServerApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Add currency
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerOnGameServerControllerAddCurrency(
      gameServerId: string,
      playerId: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerAddCurrency(
        gameServerId,
        playerId,
        playerOnGameServerSetCurrencyInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerAddCurrency']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Deduct currency
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerOnGameServerControllerDeductCurrency(
      gameServerId: string,
      playerId: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerDeductCurrency(
        gameServerId,
        playerId,
        playerOnGameServerSetCurrencyInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerDeductCurrency']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Get one
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerOnGameServerControllerGetOne(
      gameServerId: string,
      playerId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerGetOne(
        gameServerId,
        playerId,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Search
     * @param {PlayerOnGameServerSearchInputDTO} [playerOnGameServerSearchInputDTO] PlayerOnGameServerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerOnGameServerControllerSearch(
      playerOnGameServerSearchInputDTO?: PlayerOnGameServerSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerSearch(
        playerOnGameServerSearchInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Set currency
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerOnGameServerControllerSetCurrency(
      gameServerId: string,
      playerId: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerSetCurrency(
        gameServerId,
        playerId,
        playerOnGameServerSetCurrencyInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerSetCurrency']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Transact between players
     * @param {string} gameServerId
     * @param {string} sender
     * @param {string} receiver
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async playerOnGameServerControllerTransactBetweenPlayers(
      gameServerId: string,
      sender: string,
      receiver: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlayerOnGameserverOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.playerOnGameServerControllerTransactBetweenPlayers(
        gameServerId,
        sender,
        receiver,
        playerOnGameServerSetCurrencyInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath =
        operationServerMap['PlayerOnGameServerApi.playerOnGameServerControllerTransactBetweenPlayers']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * PlayerOnGameServerApi - factory interface
 * @export
 */
export const PlayerOnGameServerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PlayerOnGameServerApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Add currency
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerAddCurrency(
      gameServerId: string,
      playerId: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options?: any
    ): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
      return localVarFp
        .playerOnGameServerControllerAddCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Deduct currency
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerDeductCurrency(
      gameServerId: string,
      playerId: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options?: any
    ): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
      return localVarFp
        .playerOnGameServerControllerDeductCurrency(
          gameServerId,
          playerId,
          playerOnGameServerSetCurrencyInputDTO,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Get one
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerGetOne(
      gameServerId: string,
      playerId: string,
      options?: any
    ): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
      return localVarFp
        .playerOnGameServerControllerGetOne(gameServerId, playerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_PLAYERS`
     * @summary Search
     * @param {PlayerOnGameServerSearchInputDTO} [playerOnGameServerSearchInputDTO] PlayerOnGameServerSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerSearch(
      playerOnGameServerSearchInputDTO?: PlayerOnGameServerSearchInputDTO,
      options?: any
    ): AxiosPromise<PlayerOnGameserverOutputArrayDTOAPI> {
      return localVarFp
        .playerOnGameServerControllerSearch(playerOnGameServerSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Set currency
     * @param {string} gameServerId
     * @param {string} playerId
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerSetCurrency(
      gameServerId: string,
      playerId: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options?: any
    ): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
      return localVarFp
        .playerOnGameServerControllerSetCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_PLAYERS`
     * @summary Transact between players
     * @param {string} gameServerId
     * @param {string} sender
     * @param {string} receiver
     * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    playerOnGameServerControllerTransactBetweenPlayers(
      gameServerId: string,
      sender: string,
      receiver: string,
      playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
      options?: any
    ): AxiosPromise<PlayerOnGameserverOutputDTOAPI> {
      return localVarFp
        .playerOnGameServerControllerTransactBetweenPlayers(
          gameServerId,
          sender,
          receiver,
          playerOnGameServerSetCurrencyInputDTO,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PlayerOnGameServerApi - object-oriented interface
 * @export
 * @class PlayerOnGameServerApi
 * @extends {BaseAPI}
 */
export class PlayerOnGameServerApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_PLAYERS`
   * @summary Add currency
   * @param {string} gameServerId
   * @param {string} playerId
   * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerOnGameServerApi
   */
  public playerOnGameServerControllerAddCurrency(
    gameServerId: string,
    playerId: string,
    playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return PlayerOnGameServerApiFp(this.configuration)
      .playerOnGameServerControllerAddCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_PLAYERS`
   * @summary Deduct currency
   * @param {string} gameServerId
   * @param {string} playerId
   * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerOnGameServerApi
   */
  public playerOnGameServerControllerDeductCurrency(
    gameServerId: string,
    playerId: string,
    playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return PlayerOnGameServerApiFp(this.configuration)
      .playerOnGameServerControllerDeductCurrency(
        gameServerId,
        playerId,
        playerOnGameServerSetCurrencyInputDTO,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_PLAYERS`
   * @summary Get one
   * @param {string} gameServerId
   * @param {string} playerId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerOnGameServerApi
   */
  public playerOnGameServerControllerGetOne(gameServerId: string, playerId: string, options?: RawAxiosRequestConfig) {
    return PlayerOnGameServerApiFp(this.configuration)
      .playerOnGameServerControllerGetOne(gameServerId, playerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_PLAYERS`
   * @summary Search
   * @param {PlayerOnGameServerSearchInputDTO} [playerOnGameServerSearchInputDTO] PlayerOnGameServerSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerOnGameServerApi
   */
  public playerOnGameServerControllerSearch(
    playerOnGameServerSearchInputDTO?: PlayerOnGameServerSearchInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return PlayerOnGameServerApiFp(this.configuration)
      .playerOnGameServerControllerSearch(playerOnGameServerSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_PLAYERS`
   * @summary Set currency
   * @param {string} gameServerId
   * @param {string} playerId
   * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerOnGameServerApi
   */
  public playerOnGameServerControllerSetCurrency(
    gameServerId: string,
    playerId: string,
    playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return PlayerOnGameServerApiFp(this.configuration)
      .playerOnGameServerControllerSetCurrency(gameServerId, playerId, playerOnGameServerSetCurrencyInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_PLAYERS`
   * @summary Transact between players
   * @param {string} gameServerId
   * @param {string} sender
   * @param {string} receiver
   * @param {PlayerOnGameServerSetCurrencyInputDTO} [playerOnGameServerSetCurrencyInputDTO] PlayerOnGameServerSetCurrencyInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PlayerOnGameServerApi
   */
  public playerOnGameServerControllerTransactBetweenPlayers(
    gameServerId: string,
    sender: string,
    receiver: string,
    playerOnGameServerSetCurrencyInputDTO?: PlayerOnGameServerSetCurrencyInputDTO,
    options?: RawAxiosRequestConfig
  ) {
    return PlayerOnGameServerApiFp(this.configuration)
      .playerOnGameServerControllerTransactBetweenPlayers(
        gameServerId,
        sender,
        receiver,
        playerOnGameServerSetCurrencyInputDTO,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * RoleApi - axios parameter creator
 * @export
 */
export const RoleApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_ROLES`
     * @summary Create
     * @param {RoleCreateInputDTO} [roleCreateInputDTO] RoleCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerCreate: async (
      roleCreateInputDTO?: RoleCreateInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(roleCreateInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_ROLES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('roleControllerGetOne', 'id', id);
      const localVarPath = `/role/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerGetPermissions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/permissions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_ROLES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('roleControllerRemove', 'id', id);
      const localVarPath = `/role/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_ROLES`
     * @summary Search
     * @param {RoleSearchInputDTO} [roleSearchInputDTO] RoleSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerSearch: async (
      roleSearchInputDTO?: RoleSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/role/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(roleSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_ROLES`
     * @summary Update
     * @param {string} id
     * @param {RoleUpdateInputDTO} [roleUpdateInputDTO] RoleUpdateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerUpdate: async (
      id: string,
      roleUpdateInputDTO?: RoleUpdateInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('roleControllerUpdate', 'id', id);
      const localVarPath = `/role/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(roleUpdateInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RoleApi - functional programming interface
 * @export
 */
export const RoleApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = RoleApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_ROLES`
     * @summary Create
     * @param {RoleCreateInputDTO} [roleCreateInputDTO] RoleCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async roleControllerCreate(
      roleCreateInputDTO?: RoleCreateInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerCreate(roleCreateInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['RoleApi.roleControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_ROLES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async roleControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['RoleApi.roleControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Get permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async roleControllerGetPermissions(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PermissionOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerGetPermissions(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['RoleApi.roleControllerGetPermissions']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_ROLES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async roleControllerRemove(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerRemove(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['RoleApi.roleControllerRemove']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_ROLES`
     * @summary Search
     * @param {RoleSearchInputDTO} [roleSearchInputDTO] RoleSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async roleControllerSearch(
      roleSearchInputDTO?: RoleSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerSearch(roleSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['RoleApi.roleControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_ROLES`
     * @summary Update
     * @param {string} id
     * @param {RoleUpdateInputDTO} [roleUpdateInputDTO] RoleUpdateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async roleControllerUpdate(
      id: string,
      roleUpdateInputDTO?: RoleUpdateInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.roleControllerUpdate(id, roleUpdateInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['RoleApi.roleControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * RoleApi - factory interface
 * @export
 */
export const RoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = RoleApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_ROLES`
     * @summary Create
     * @param {RoleCreateInputDTO} [roleCreateInputDTO] RoleCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerCreate(roleCreateInputDTO?: RoleCreateInputDTO, options?: any): AxiosPromise<RoleOutputDTOAPI> {
      return localVarFp.roleControllerCreate(roleCreateInputDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_ROLES`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerGetOne(id: string, options?: any): AxiosPromise<RoleOutputDTOAPI> {
      return localVarFp.roleControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerGetPermissions(options?: any): AxiosPromise<PermissionOutputDTOAPI> {
      return localVarFp.roleControllerGetPermissions(options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_ROLES`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerRemove(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.roleControllerRemove(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_ROLES`
     * @summary Search
     * @param {RoleSearchInputDTO} [roleSearchInputDTO] RoleSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerSearch(roleSearchInputDTO?: RoleSearchInputDTO, options?: any): AxiosPromise<RoleOutputArrayDTOAPI> {
      return localVarFp.roleControllerSearch(roleSearchInputDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_ROLES`
     * @summary Update
     * @param {string} id
     * @param {RoleUpdateInputDTO} [roleUpdateInputDTO] RoleUpdateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    roleControllerUpdate(
      id: string,
      roleUpdateInputDTO?: RoleUpdateInputDTO,
      options?: any
    ): AxiosPromise<RoleOutputDTOAPI> {
      return localVarFp
        .roleControllerUpdate(id, roleUpdateInputDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * RoleApi - object-oriented interface
 * @export
 * @class RoleApi
 * @extends {BaseAPI}
 */
export class RoleApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_ROLES`
   * @summary Create
   * @param {RoleCreateInputDTO} [roleCreateInputDTO] RoleCreateInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleApi
   */
  public roleControllerCreate(roleCreateInputDTO?: RoleCreateInputDTO, options?: RawAxiosRequestConfig) {
    return RoleApiFp(this.configuration)
      .roleControllerCreate(roleCreateInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_ROLES`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleApi
   */
  public roleControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return RoleApiFp(this.configuration)
      .roleControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get permissions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleApi
   */
  public roleControllerGetPermissions(options?: RawAxiosRequestConfig) {
    return RoleApiFp(this.configuration)
      .roleControllerGetPermissions(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_ROLES`
   * @summary Remove
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleApi
   */
  public roleControllerRemove(id: string, options?: RawAxiosRequestConfig) {
    return RoleApiFp(this.configuration)
      .roleControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_ROLES`
   * @summary Search
   * @param {RoleSearchInputDTO} [roleSearchInputDTO] RoleSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleApi
   */
  public roleControllerSearch(roleSearchInputDTO?: RoleSearchInputDTO, options?: RawAxiosRequestConfig) {
    return RoleApiFp(this.configuration)
      .roleControllerSearch(roleSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_ROLES`
   * @summary Update
   * @param {string} id
   * @param {RoleUpdateInputDTO} [roleUpdateInputDTO] RoleUpdateInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoleApi
   */
  public roleControllerUpdate(id: string, roleUpdateInputDTO?: RoleUpdateInputDTO, options?: RawAxiosRequestConfig) {
    return RoleApiFp(this.configuration)
      .roleControllerUpdate(id, roleUpdateInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_SETTINGS`
     * @summary Delete
     * @param {string} key
     * @param {string} [gameServerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsControllerDelete: async (
      key: string,
      gameServerId?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists('settingsControllerDelete', 'key', key);
      const localVarPath = `/settings/{key}`.replace(`{${'key'}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      if (gameServerId !== undefined) {
        localVarQueryParameter['gameServerId'] = gameServerId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_SETTINGS`
     * @summary Get
     * @param {Array<SettingsControllerGetKeysEnum>} [keys]
     * @param {string} [gameServerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsControllerGet: async (
      keys?: Array<SettingsControllerGetKeysEnum>,
      gameServerId?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      if (keys) {
        localVarQueryParameter['keys'] = keys;
      }

      if (gameServerId !== undefined) {
        localVarQueryParameter['gameServerId'] = gameServerId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_SETTINGS`
     * @summary Get one
     * @param {string} key
     * @param {string} [gameServerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsControllerGetOne: async (
      key: string,
      gameServerId?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists('settingsControllerGetOne', 'key', key);
      const localVarPath = `/settings/{key}`.replace(`{${'key'}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      if (gameServerId !== undefined) {
        localVarQueryParameter['gameServerId'] = gameServerId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_SETTINGS`
     * @summary Set
     * @param {string} key
     * @param {SettingsSetDTO} [settingsSetDTO] SettingsSetDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsControllerSet: async (
      key: string,
      settingsSetDTO?: SettingsSetDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists('settingsControllerSet', 'key', key);
      const localVarPath = `/settings/{key}`.replace(`{${'key'}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(settingsSetDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_SETTINGS`
     * @summary Delete
     * @param {string} key
     * @param {string} [gameServerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async settingsControllerDelete(
      key: string,
      gameServerId?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerDelete(key, gameServerId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SettingsApi.settingsControllerDelete']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_SETTINGS`
     * @summary Get
     * @param {Array<SettingsControllerGetKeysEnum>} [keys]
     * @param {string} [gameServerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async settingsControllerGet(
      keys?: Array<SettingsControllerGetKeysEnum>,
      gameServerId?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGet(keys, gameServerId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SettingsApi.settingsControllerGet']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_SETTINGS`
     * @summary Get one
     * @param {string} key
     * @param {string} [gameServerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async settingsControllerGetOne(
      key: string,
      gameServerId?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetOne(key, gameServerId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SettingsApi.settingsControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_SETTINGS`
     * @summary Set
     * @param {string} key
     * @param {SettingsSetDTO} [settingsSetDTO] SettingsSetDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async settingsControllerSet(
      key: string,
      settingsSetDTO?: SettingsSetDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SettingsOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerSet(key, settingsSetDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['SettingsApi.settingsControllerSet']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = SettingsApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_SETTINGS`
     * @summary Delete
     * @param {string} key
     * @param {string} [gameServerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsControllerDelete(
      key: string,
      gameServerId?: string,
      options?: any
    ): AxiosPromise<SettingsOutputArrayDTOAPI> {
      return localVarFp
        .settingsControllerDelete(key, gameServerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_SETTINGS`
     * @summary Get
     * @param {Array<SettingsControllerGetKeysEnum>} [keys]
     * @param {string} [gameServerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsControllerGet(
      keys?: Array<SettingsControllerGetKeysEnum>,
      gameServerId?: string,
      options?: any
    ): AxiosPromise<SettingsOutputArrayDTOAPI> {
      return localVarFp.settingsControllerGet(keys, gameServerId, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_SETTINGS`
     * @summary Get one
     * @param {string} key
     * @param {string} [gameServerId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsControllerGetOne(key: string, gameServerId?: string, options?: any): AxiosPromise<SettingsOutputDTOAPI> {
      return localVarFp
        .settingsControllerGetOne(key, gameServerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_SETTINGS`
     * @summary Set
     * @param {string} key
     * @param {SettingsSetDTO} [settingsSetDTO] SettingsSetDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    settingsControllerSet(
      key: string,
      settingsSetDTO?: SettingsSetDTO,
      options?: any
    ): AxiosPromise<SettingsOutputDTOAPI> {
      return localVarFp.settingsControllerSet(key, settingsSetDTO, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_SETTINGS`
   * @summary Delete
   * @param {string} key
   * @param {string} [gameServerId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public settingsControllerDelete(key: string, gameServerId?: string, options?: RawAxiosRequestConfig) {
    return SettingsApiFp(this.configuration)
      .settingsControllerDelete(key, gameServerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_SETTINGS`
   * @summary Get
   * @param {Array<SettingsControllerGetKeysEnum>} [keys]
   * @param {string} [gameServerId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public settingsControllerGet(
    keys?: Array<SettingsControllerGetKeysEnum>,
    gameServerId?: string,
    options?: RawAxiosRequestConfig
  ) {
    return SettingsApiFp(this.configuration)
      .settingsControllerGet(keys, gameServerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_SETTINGS`
   * @summary Get one
   * @param {string} key
   * @param {string} [gameServerId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public settingsControllerGetOne(key: string, gameServerId?: string, options?: RawAxiosRequestConfig) {
    return SettingsApiFp(this.configuration)
      .settingsControllerGetOne(key, gameServerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_SETTINGS`
   * @summary Set
   * @param {string} key
   * @param {SettingsSetDTO} [settingsSetDTO] SettingsSetDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SettingsApi
   */
  public settingsControllerSet(key: string, settingsSetDTO?: SettingsSetDTO, options?: RawAxiosRequestConfig) {
    return SettingsApiFp(this.configuration)
      .settingsControllerSet(key, settingsSetDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const SettingsControllerGetKeysEnum = {
  CommandPrefix: 'commandPrefix',
  ServerChatName: 'serverChatName',
  EconomyEnabled: 'economyEnabled',
  CurrencyName: 'currencyName',
} as const;
export type SettingsControllerGetKeysEnum =
  (typeof SettingsControllerGetKeysEnum)[keyof typeof SettingsControllerGetKeysEnum];

/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
     * @summary Assign role
     * @param {string} id
     * @param {string} roleId
     * @param {UserRoleAssignChangeDTO} [userRoleAssignChangeDTO] UserRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerAssignRole: async (
      id: string,
      roleId: string,
      userRoleAssignChangeDTO?: UserRoleAssignChangeDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerAssignRole', 'id', id);
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists('userControllerAssignRole', 'roleId', roleId);
      const localVarPath = `/user/{id}/role/{roleId}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'roleId'}}`, encodeURIComponent(String(roleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        userRoleAssignChangeDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Create
     * @param {UserCreateInputDTO} [userCreateInputDTO] UserCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerCreate: async (
      userCreateInputDTO?: UserCreateInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userCreateInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_USERS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerGetOne', 'id', id);
      const localVarPath = `/user/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Invite
     * @param {InviteCreateDTO} [inviteCreateDTO] InviteCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerInvite: async (
      inviteCreateDTO?: InviteCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/invite`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(inviteCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Login
     * @param {LoginDTO} [loginDTO] LoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerLogin: async (loginDTO?: LoginDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/login`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(loginDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerLogout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerMe: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/me`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemove: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerRemove', 'id', id);
      const localVarPath = `/user/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
     * @summary Remove role
     * @param {string} id
     * @param {string} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveRole: async (
      id: string,
      roleId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerRemoveRole', 'id', id);
      // verify required parameter 'roleId' is not null or undefined
      assertParamExists('userControllerRemoveRole', 'roleId', roleId);
      const localVarPath = `/user/{id}/role/{roleId}`
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'roleId'}}`, encodeURIComponent(String(roleId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_USERS`
     * @summary Search
     * @param {UserSearchInputDTO} [userSearchInputDTO] UserSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerSearch: async (
      userSearchInputDTO?: UserSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/user/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userSearchInputDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Update
     * @param {string} id
     * @param {UserUpdateDTO} [userUpdateDTO] UserUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdate: async (
      id: string,
      userUpdateDTO?: UserUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('userControllerUpdate', 'id', id);
      const localVarPath = `/user/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(userUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
     * @summary Assign role
     * @param {string} id
     * @param {string} roleId
     * @param {UserRoleAssignChangeDTO} [userRoleAssignChangeDTO] UserRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerAssignRole(
      id: string,
      roleId: string,
      userRoleAssignChangeDTO?: UserRoleAssignChangeDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerAssignRole(
        id,
        roleId,
        userRoleAssignChangeDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerAssignRole']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Create
     * @param {UserCreateInputDTO} [userCreateInputDTO] UserCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerCreate(
      userCreateInputDTO?: UserCreateInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerCreate(userCreateInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_USERS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerGetOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerGetOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerGetOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Invite
     * @param {InviteCreateDTO} [inviteCreateDTO] InviteCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerInvite(
      inviteCreateDTO?: InviteCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerInvite(inviteCreateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerInvite']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Login
     * @param {LoginDTO} [loginDTO] LoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerLogin(
      loginDTO?: LoginDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerLogin(loginDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerLogin']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerLogout(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerLogout(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerLogout']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerMe(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerMe(options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerMe']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerRemove(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemove(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerRemove']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
     * @summary Remove role
     * @param {string} id
     * @param {string} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerRemoveRole(
      id: string,
      roleId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIOutput>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerRemoveRole(id, roleId, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerRemoveRole']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_USERS`
     * @summary Search
     * @param {UserSearchInputDTO} [userSearchInputDTO] UserSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerSearch(
      userSearchInputDTO?: UserSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerSearch(userSearchInputDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Update
     * @param {string} id
     * @param {UserUpdateDTO} [userUpdateDTO] UserUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async userControllerUpdate(
      id: string,
      userUpdateDTO?: UserUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerUpdate(id, userUpdateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['UserApi.userControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = UserApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
     * @summary Assign role
     * @param {string} id
     * @param {string} roleId
     * @param {UserRoleAssignChangeDTO} [userRoleAssignChangeDTO] UserRoleAssignChangeDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerAssignRole(
      id: string,
      roleId: string,
      userRoleAssignChangeDTO?: UserRoleAssignChangeDTO,
      options?: any
    ): AxiosPromise<APIOutput> {
      return localVarFp
        .userControllerAssignRole(id, roleId, userRoleAssignChangeDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Create
     * @param {UserCreateInputDTO} [userCreateInputDTO] UserCreateInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerCreate(userCreateInputDTO?: UserCreateInputDTO, options?: any): AxiosPromise<UserOutputDTOAPI> {
      return localVarFp.userControllerCreate(userCreateInputDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_USERS`
     * @summary Get one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerGetOne(id: string, options?: any): AxiosPromise<UserOutputDTOAPI> {
      return localVarFp.userControllerGetOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Invite
     * @param {InviteCreateDTO} [inviteCreateDTO] InviteCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerInvite(inviteCreateDTO?: InviteCreateDTO, options?: any): AxiosPromise<UserOutputDTOAPI> {
      return localVarFp.userControllerInvite(inviteCreateDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Login
     * @param {LoginDTO} [loginDTO] LoginDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerLogin(loginDTO?: LoginDTO, options?: any): AxiosPromise<LoginOutputDTOAPI> {
      return localVarFp.userControllerLogin(loginDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerLogout(options?: any): AxiosPromise<APIOutput> {
      return localVarFp.userControllerLogout(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerMe(options?: any): AxiosPromise<UserOutputDTOAPI> {
      return localVarFp.userControllerMe(options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Remove
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemove(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.userControllerRemove(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
     * @summary Remove role
     * @param {string} id
     * @param {string} roleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerRemoveRole(id: string, roleId: string, options?: any): AxiosPromise<APIOutput> {
      return localVarFp.userControllerRemoveRole(id, roleId, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_USERS`
     * @summary Search
     * @param {UserSearchInputDTO} [userSearchInputDTO] UserSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerSearch(userSearchInputDTO?: UserSearchInputDTO, options?: any): AxiosPromise<UserOutputArrayDTOAPI> {
      return localVarFp.userControllerSearch(userSearchInputDTO, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_USERS`
     * @summary Update
     * @param {string} id
     * @param {UserUpdateDTO} [userUpdateDTO] UserUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    userControllerUpdate(id: string, userUpdateDTO?: UserUpdateDTO, options?: any): AxiosPromise<UserOutputDTOAPI> {
      return localVarFp.userControllerUpdate(id, userUpdateDTO, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
   * @summary Assign role
   * @param {string} id
   * @param {string} roleId
   * @param {UserRoleAssignChangeDTO} [userRoleAssignChangeDTO] UserRoleAssignChangeDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerAssignRole(
    id: string,
    roleId: string,
    userRoleAssignChangeDTO?: UserRoleAssignChangeDTO,
    options?: RawAxiosRequestConfig
  ) {
    return UserApiFp(this.configuration)
      .userControllerAssignRole(id, roleId, userRoleAssignChangeDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_USERS`
   * @summary Create
   * @param {UserCreateInputDTO} [userCreateInputDTO] UserCreateInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerCreate(userCreateInputDTO?: UserCreateInputDTO, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerCreate(userCreateInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_USERS`
   * @summary Get one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerGetOne(id: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerGetOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_USERS`
   * @summary Invite
   * @param {InviteCreateDTO} [inviteCreateDTO] InviteCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerInvite(inviteCreateDTO?: InviteCreateDTO, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerInvite(inviteCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Login
   * @param {LoginDTO} [loginDTO] LoginDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerLogin(loginDTO?: LoginDTO, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerLogin(loginDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Logout
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerLogout(options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerLogout(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Me
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerMe(options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerMe(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_USERS`
   * @summary Remove
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerRemove(id: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerRemove(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_USERS`, `MANAGE_ROLES`
   * @summary Remove role
   * @param {string} id
   * @param {string} roleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerRemoveRole(id: string, roleId: string, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerRemoveRole(id, roleId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_USERS`
   * @summary Search
   * @param {UserSearchInputDTO} [userSearchInputDTO] UserSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerSearch(userSearchInputDTO?: UserSearchInputDTO, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerSearch(userSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_USERS`
   * @summary Update
   * @param {string} id
   * @param {UserUpdateDTO} [userUpdateDTO] UserUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserApi
   */
  public userControllerUpdate(id: string, userUpdateDTO?: UserUpdateDTO, options?: RawAxiosRequestConfig) {
    return UserApiFp(this.configuration)
      .userControllerUpdate(id, userUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * VariableApi - axios parameter creator
 * @export
 */
export const VariableApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *  Required permissions: `MANAGE_VARIABLES`
     * @summary Create
     * @param {VariableCreateDTO} [variableCreateDTO] VariableCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerCreate: async (
      variableCreateDTO?: VariableCreateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/variables`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(variableCreateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_VARIABLES`
     * @summary Delete
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('variableControllerDelete', 'id', id);
      const localVarPath = `/variables/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_VARIABLES`
     * @summary Find one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerFindOne: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('variableControllerFindOne', 'id', id);
      const localVarPath = `/variables/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `READ_VARIABLES`
     * @summary Search
     * @param {VariableSearchInputDTO} [variableSearchInputDTO] VariableSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerSearch: async (
      variableSearchInputDTO?: VariableSearchInputDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/variables/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(
        variableSearchInputDTO,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *  Required permissions: `MANAGE_VARIABLES`
     * @summary Update
     * @param {string} id
     * @param {VariableUpdateDTO} [variableUpdateDTO] VariableUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerUpdate: async (
      id: string,
      variableUpdateDTO?: VariableUpdateDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('variableControllerUpdate', 'id', id);
      const localVarPath = `/variables/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication domainAuth required

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(variableUpdateDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VariableApi - functional programming interface
 * @export
 */
export const VariableApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VariableApiAxiosParamCreator(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_VARIABLES`
     * @summary Create
     * @param {VariableCreateDTO} [variableCreateDTO] VariableCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async variableControllerCreate(
      variableCreateDTO?: VariableCreateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerCreate(variableCreateDTO, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['VariableApi.variableControllerCreate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_VARIABLES`
     * @summary Delete
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async variableControllerDelete(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdUuidDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerDelete(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['VariableApi.variableControllerDelete']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_VARIABLES`
     * @summary Find one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async variableControllerFindOne(
      id: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerFindOne(id, options);
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['VariableApi.variableControllerFindOne']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `READ_VARIABLES`
     * @summary Search
     * @param {VariableSearchInputDTO} [variableSearchInputDTO] VariableSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async variableControllerSearch(
      variableSearchInputDTO?: VariableSearchInputDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableOutputArrayDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerSearch(
        variableSearchInputDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['VariableApi.variableControllerSearch']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
    /**
     *  Required permissions: `MANAGE_VARIABLES`
     * @summary Update
     * @param {string} id
     * @param {VariableUpdateDTO} [variableUpdateDTO] VariableUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async variableControllerUpdate(
      id: string,
      variableUpdateDTO?: VariableUpdateDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VariableOutputDTOAPI>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.variableControllerUpdate(
        id,
        variableUpdateDTO,
        options
      );
      const index = configuration?.serverIndex ?? 0;
      const operationBasePath = operationServerMap['VariableApi.variableControllerUpdate']?.[index]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, operationBasePath || basePath);
    },
  };
};

/**
 * VariableApi - factory interface
 * @export
 */
export const VariableApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = VariableApiFp(configuration);
  return {
    /**
     *  Required permissions: `MANAGE_VARIABLES`
     * @summary Create
     * @param {VariableCreateDTO} [variableCreateDTO] VariableCreateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerCreate(variableCreateDTO?: VariableCreateDTO, options?: any): AxiosPromise<VariableOutputDTOAPI> {
      return localVarFp
        .variableControllerCreate(variableCreateDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_VARIABLES`
     * @summary Delete
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerDelete(id: string, options?: any): AxiosPromise<IdUuidDTOAPI> {
      return localVarFp.variableControllerDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_VARIABLES`
     * @summary Find one
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerFindOne(id: string, options?: any): AxiosPromise<VariableOutputDTOAPI> {
      return localVarFp.variableControllerFindOne(id, options).then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `READ_VARIABLES`
     * @summary Search
     * @param {VariableSearchInputDTO} [variableSearchInputDTO] VariableSearchInputDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerSearch(
      variableSearchInputDTO?: VariableSearchInputDTO,
      options?: any
    ): AxiosPromise<VariableOutputArrayDTOAPI> {
      return localVarFp
        .variableControllerSearch(variableSearchInputDTO, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *  Required permissions: `MANAGE_VARIABLES`
     * @summary Update
     * @param {string} id
     * @param {VariableUpdateDTO} [variableUpdateDTO] VariableUpdateDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    variableControllerUpdate(
      id: string,
      variableUpdateDTO?: VariableUpdateDTO,
      options?: any
    ): AxiosPromise<VariableOutputDTOAPI> {
      return localVarFp
        .variableControllerUpdate(id, variableUpdateDTO, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VariableApi - object-oriented interface
 * @export
 * @class VariableApi
 * @extends {BaseAPI}
 */
export class VariableApi extends BaseAPI {
  /**
   *  Required permissions: `MANAGE_VARIABLES`
   * @summary Create
   * @param {VariableCreateDTO} [variableCreateDTO] VariableCreateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VariableApi
   */
  public variableControllerCreate(variableCreateDTO?: VariableCreateDTO, options?: RawAxiosRequestConfig) {
    return VariableApiFp(this.configuration)
      .variableControllerCreate(variableCreateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_VARIABLES`
   * @summary Delete
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VariableApi
   */
  public variableControllerDelete(id: string, options?: RawAxiosRequestConfig) {
    return VariableApiFp(this.configuration)
      .variableControllerDelete(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_VARIABLES`
   * @summary Find one
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VariableApi
   */
  public variableControllerFindOne(id: string, options?: RawAxiosRequestConfig) {
    return VariableApiFp(this.configuration)
      .variableControllerFindOne(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `READ_VARIABLES`
   * @summary Search
   * @param {VariableSearchInputDTO} [variableSearchInputDTO] VariableSearchInputDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VariableApi
   */
  public variableControllerSearch(variableSearchInputDTO?: VariableSearchInputDTO, options?: RawAxiosRequestConfig) {
    return VariableApiFp(this.configuration)
      .variableControllerSearch(variableSearchInputDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *  Required permissions: `MANAGE_VARIABLES`
   * @summary Update
   * @param {string} id
   * @param {VariableUpdateDTO} [variableUpdateDTO] VariableUpdateDTO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VariableApi
   */
  public variableControllerUpdate(id: string, variableUpdateDTO?: VariableUpdateDTO, options?: RawAxiosRequestConfig) {
    return VariableApiFp(this.configuration)
      .variableControllerUpdate(id, variableUpdateDTO, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
