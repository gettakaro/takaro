{"file://node_modules/axios/package.json":"{\"name\":\"axios\",\"types\":\"./index.d.ts\"}","file://node_modules/axios/index.d.ts":"// TypeScript Version: 4.7\ntype AxiosHeaderValue = AxiosHeaders | string | string[] | number | boolean | null;\n\ninterface RawAxiosHeaders {\n  [key: string]: AxiosHeaderValue;\n}\n\ntype MethodsHeaders = Partial<{\n  [Key in Method as Lowercase<Key>]: AxiosHeaders;\n} & {common: AxiosHeaders}>;\n\ntype AxiosHeaderMatcher = string | RegExp | ((this: AxiosHeaders, value: string, name: string) => boolean);\n\ntype AxiosHeaderParser = (this: AxiosHeaders, value: AxiosHeaderValue, header: string) => any;\n\nclass AxiosHeaders {\n  constructor(\n      headers?: RawAxiosHeaders | AxiosHeaders | string\n  );\n\n  [key: string]: any;\n\n  set(headerName?: string, value?: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;\n  set(headers?: RawAxiosHeaders | AxiosHeaders | string, rewrite?: boolean): AxiosHeaders;\n\n  get(headerName: string, parser: RegExp): RegExpExecArray | null;\n  get(headerName: string, matcher?: true | AxiosHeaderParser): AxiosHeaderValue;\n\n  has(header: string, matcher?: AxiosHeaderMatcher): boolean;\n\n  delete(header: string | string[], matcher?: AxiosHeaderMatcher): boolean;\n\n  clear(matcher?: AxiosHeaderMatcher): boolean;\n\n  normalize(format: boolean): AxiosHeaders;\n\n  concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;\n\n  toJSON(asStrings?: boolean): RawAxiosHeaders;\n\n  static from(thing?: AxiosHeaders | RawAxiosHeaders | string): AxiosHeaders;\n\n  static accessor(header: string | string[]): AxiosHeaders;\n\n  static concat(...targets: Array<AxiosHeaders | RawAxiosHeaders | string | undefined | null>): AxiosHeaders;\n\n  setContentType(value: ContentType, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;\n  getContentType(parser?: RegExp): RegExpExecArray | null;\n  getContentType(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;\n  hasContentType(matcher?: AxiosHeaderMatcher): boolean;\n\n  setContentLength(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;\n  getContentLength(parser?: RegExp): RegExpExecArray | null;\n  getContentLength(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;\n  hasContentLength(matcher?: AxiosHeaderMatcher): boolean;\n\n  setAccept(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;\n  getAccept(parser?: RegExp): RegExpExecArray | null;\n  getAccept(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;\n  hasAccept(matcher?: AxiosHeaderMatcher): boolean;\n\n  setUserAgent(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;\n  getUserAgent(parser?: RegExp): RegExpExecArray | null;\n  getUserAgent(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;\n  hasUserAgent(matcher?: AxiosHeaderMatcher): boolean;\n\n  setContentEncoding(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;\n  getContentEncoding(parser?: RegExp): RegExpExecArray | null;\n  getContentEncoding(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;\n  hasContentEncoding(matcher?: AxiosHeaderMatcher): boolean;\n\n  setAuthorization(value: AxiosHeaderValue, rewrite?: boolean | AxiosHeaderMatcher): AxiosHeaders;\n  getAuthorization(parser?: RegExp): RegExpExecArray | null;\n  getAuthorization(matcher?: AxiosHeaderMatcher): AxiosHeaderValue;\n  hasAuthorization(matcher?: AxiosHeaderMatcher): boolean;\n\n  [Symbol.iterator](): IterableIterator<[string, AxiosHeaderValue]>;\n}\n\ntype CommonRequestHeadersList = 'Accept' | 'Content-Length' | 'User-Agent' | 'Content-Encoding' | 'Authorization';\n\ntype ContentType = AxiosHeaderValue | 'text/html' | 'text/plain' | 'multipart/form-data' | 'application/json' | 'application/x-www-form-urlencoded' | 'application/octet-stream';\n\ntype RawAxiosRequestHeaders = Partial<RawAxiosHeaders & {\n  [Key in CommonRequestHeadersList]: AxiosHeaderValue;\n} & {\n  'Content-Type': ContentType\n}>;\n\ntype AxiosRequestHeaders = RawAxiosRequestHeaders & AxiosHeaders;\n\ntype CommonResponseHeadersList = 'Server' | 'Content-Type' | 'Content-Length' | 'Cache-Control'| 'Content-Encoding';\n\ntype RawCommonResponseHeaders = {\n  [Key in CommonResponseHeadersList]: AxiosHeaderValue;\n} & {\n  \"set-cookie\": string[];\n};\n\ntype RawAxiosResponseHeaders = Partial<RawAxiosHeaders & RawCommonResponseHeaders>;\n\ntype AxiosResponseHeaders = RawAxiosResponseHeaders & AxiosHeaders;\n\ninterface AxiosRequestTransformer {\n  (this: InternalAxiosRequestConfig, data: any, headers: AxiosRequestHeaders): any;\n}\n\ninterface AxiosResponseTransformer {\n  (this: InternalAxiosRequestConfig, data: any, headers: AxiosResponseHeaders, status?: number): any;\n}\n\ninterface AxiosAdapter {\n  (config: InternalAxiosRequestConfig): AxiosPromise;\n}\n\ninterface AxiosBasicCredentials {\n  username: string;\n  password: string;\n}\n\ninterface AxiosProxyConfig {\n  host: string;\n  port: number;\n  auth?: AxiosBasicCredentials;\n  protocol?: string;\n}\n\nenum HttpStatusCode {\n  Continue = 100,\n  SwitchingProtocols = 101,\n  Processing = 102,\n  EarlyHints = 103,\n  Ok = 200,\n  Created = 201,\n  Accepted = 202,\n  NonAuthoritativeInformation = 203,\n  NoContent = 204,\n  ResetContent = 205,\n  PartialContent = 206,\n  MultiStatus = 207,\n  AlreadyReported = 208,\n  ImUsed = 226,\n  MultipleChoices = 300,\n  MovedPermanently = 301,\n  Found = 302,\n  SeeOther = 303,\n  NotModified = 304,\n  UseProxy = 305,\n  Unused = 306,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n  BadRequest = 400,\n  Unauthorized = 401,\n  PaymentRequired = 402,\n  Forbidden = 403,\n  NotFound = 404,\n  MethodNotAllowed = 405,\n  NotAcceptable = 406,\n  ProxyAuthenticationRequired = 407,\n  RequestTimeout = 408,\n  Conflict = 409,\n  Gone = 410,\n  LengthRequired = 411,\n  PreconditionFailed = 412,\n  PayloadTooLarge = 413,\n  UriTooLong = 414,\n  UnsupportedMediaType = 415,\n  RangeNotSatisfiable = 416,\n  ExpectationFailed = 417,\n  ImATeapot = 418,\n  MisdirectedRequest = 421,\n  UnprocessableEntity = 422,\n  Locked = 423,\n  FailedDependency = 424,\n  TooEarly = 425,\n  UpgradeRequired = 426,\n  PreconditionRequired = 428,\n  TooManyRequests = 429,\n  RequestHeaderFieldsTooLarge = 431,\n  UnavailableForLegalReasons = 451,\n  InternalServerError = 500,\n  NotImplemented = 501,\n  BadGateway = 502,\n  ServiceUnavailable = 503,\n  GatewayTimeout = 504,\n  HttpVersionNotSupported = 505,\n  VariantAlsoNegotiates = 506,\n  InsufficientStorage = 507,\n  LoopDetected = 508,\n  NotExtended = 510,\n  NetworkAuthenticationRequired = 511,\n}\n\ntype Method =\n    | 'get' | 'GET'\n    | 'delete' | 'DELETE'\n    | 'head' | 'HEAD'\n    | 'options' | 'OPTIONS'\n    | 'post' | 'POST'\n    | 'put' | 'PUT'\n    | 'patch' | 'PATCH'\n    | 'purge' | 'PURGE'\n    | 'link' | 'LINK'\n    | 'unlink' | 'UNLINK';\n\ntype ResponseType =\n    | 'arraybuffer'\n    | 'blob'\n    | 'document'\n    | 'json'\n    | 'text'\n    | 'stream'\n    | 'formdata';\n\ntype responseEncoding =\n    | 'ascii' | 'ASCII'\n    | 'ansi' | 'ANSI'\n    | 'binary' | 'BINARY'\n    | 'base64' | 'BASE64'\n    | 'base64url' | 'BASE64URL'\n    | 'hex' | 'HEX'\n    | 'latin1' | 'LATIN1'\n    | 'ucs-2' | 'UCS-2'\n    | 'ucs2' | 'UCS2'\n    | 'utf-8' | 'UTF-8'\n    | 'utf8' | 'UTF8'\n    | 'utf16le' | 'UTF16LE';\n\ninterface TransitionalOptions {\n  silentJSONParsing?: boolean;\n  forcedJSONParsing?: boolean;\n  clarifyTimeoutError?: boolean;\n}\n\ninterface GenericAbortSignal {\n  readonly aborted: boolean;\n  onabort?: ((...args: any) => any) | null;\n  addEventListener?: (...args: any) => any;\n  removeEventListener?: (...args: any) => any;\n}\n\ninterface FormDataVisitorHelpers {\n  defaultVisitor: SerializerVisitor;\n  convertValue: (value: any) => any;\n  isVisitable: (value: any) => boolean;\n}\n\ninterface SerializerVisitor {\n  (\n      this: GenericFormData,\n      value: any,\n      key: string | number,\n      path: null | Array<string | number>,\n      helpers: FormDataVisitorHelpers\n  ): boolean;\n}\n\ninterface SerializerOptions {\n  visitor?: SerializerVisitor;\n  dots?: boolean;\n  metaTokens?: boolean;\n  indexes?: boolean | null;\n}\n\n// tslint:disable-next-line\ninterface FormSerializerOptions extends SerializerOptions {\n}\n\ninterface ParamEncoder {\n  (value: any, defaultEncoder: (value: any) => any): any;\n}\n\ninterface CustomParamsSerializer {\n  (params: Record<string, any>, options?: ParamsSerializerOptions): string;\n}\n\ninterface ParamsSerializerOptions extends SerializerOptions {\n  encode?: ParamEncoder;\n  serialize?: CustomParamsSerializer;\n}\n\ntype MaxUploadRate = number;\n\ntype MaxDownloadRate = number;\n\ntype BrowserProgressEvent = any;\n\ninterface AxiosProgressEvent {\n  loaded: number;\n  total?: number;\n  progress?: number;\n  bytes: number;\n  rate?: number;\n  estimated?: number;\n  upload?: boolean;\n  download?: boolean;\n  event?: BrowserProgressEvent;\n  lengthComputable: boolean;\n}\n\ntype Milliseconds = number;\n\ntype AxiosAdapterName = 'fetch' | 'xhr' | 'http' | string;\n\ntype AxiosAdapterConfig = AxiosAdapter | AxiosAdapterName;\n\ntype AddressFamily = 4 | 6 | undefined;\n\ninterface LookupAddressEntry {\n  address: string;\n  family?: AddressFamily;\n}\n\ntype LookupAddress = string | LookupAddressEntry;\n\ninterface AxiosRequestConfig<D = any> {\n  url?: string;\n  method?: Method | string;\n  baseURL?: string;\n  transformRequest?: AxiosRequestTransformer | AxiosRequestTransformer[];\n  transformResponse?: AxiosResponseTransformer | AxiosResponseTransformer[];\n  headers?: (RawAxiosRequestHeaders & MethodsHeaders) | AxiosHeaders;\n  params?: any;\n  paramsSerializer?: ParamsSerializerOptions | CustomParamsSerializer;\n  data?: D;\n  timeout?: Milliseconds;\n  timeoutErrorMessage?: string;\n  withCredentials?: boolean;\n  adapter?: AxiosAdapterConfig | AxiosAdapterConfig[];\n  auth?: AxiosBasicCredentials;\n  responseType?: ResponseType;\n  responseEncoding?: responseEncoding | string;\n  xsrfCookieName?: string;\n  xsrfHeaderName?: string;\n  onUploadProgress?: (progressEvent: AxiosProgressEvent) => void;\n  onDownloadProgress?: (progressEvent: AxiosProgressEvent) => void;\n  maxContentLength?: number;\n  validateStatus?: ((status: number) => boolean) | null;\n  maxBodyLength?: number;\n  maxRedirects?: number;\n  maxRate?: number | [MaxUploadRate, MaxDownloadRate];\n  beforeRedirect?: (options: Record<string, any>, responseDetails: {headers: Record<string, string>, statusCode: HttpStatusCode}) => void;\n  socketPath?: string | null;\n  transport?: any;\n  httpAgent?: any;\n  httpsAgent?: any;\n  proxy?: AxiosProxyConfig | false;\n  cancelToken?: CancelToken;\n  decompress?: boolean;\n  transitional?: TransitionalOptions;\n  signal?: GenericAbortSignal;\n  insecureHTTPParser?: boolean;\n  env?: {\n    FormData?: new (...args: any[]) => object;\n  };\n  formSerializer?: FormSerializerOptions;\n  family?: AddressFamily;\n  lookup?: ((hostname: string, options: object, cb: (err: Error | null, address: LookupAddress | LookupAddress[], family?: AddressFamily) => void) => void) |\n      ((hostname: string, options: object) => Promise<[address: LookupAddressEntry | LookupAddressEntry[], family?: AddressFamily] | LookupAddress>);\n  withXSRFToken?: boolean | ((config: InternalAxiosRequestConfig) => boolean | undefined);\n  fetchOptions?: Record<string, any>;\n}\n\n// Alias\ntype RawAxiosRequestConfig<D = any> = AxiosRequestConfig<D>;\n\ninterface InternalAxiosRequestConfig<D = any> extends AxiosRequestConfig<D> {\n  headers: AxiosRequestHeaders;\n}\n\ninterface HeadersDefaults {\n  common: RawAxiosRequestHeaders;\n  delete: RawAxiosRequestHeaders;\n  get: RawAxiosRequestHeaders;\n  head: RawAxiosRequestHeaders;\n  post: RawAxiosRequestHeaders;\n  put: RawAxiosRequestHeaders;\n  patch: RawAxiosRequestHeaders;\n  options?: RawAxiosRequestHeaders;\n  purge?: RawAxiosRequestHeaders;\n  link?: RawAxiosRequestHeaders;\n  unlink?: RawAxiosRequestHeaders;\n}\n\ninterface AxiosDefaults<D = any> extends Omit<AxiosRequestConfig<D>, 'headers'> {\n  headers: HeadersDefaults;\n}\n\ninterface CreateAxiosDefaults<D = any> extends Omit<AxiosRequestConfig<D>, 'headers'> {\n  headers?: RawAxiosRequestHeaders | AxiosHeaders | Partial<HeadersDefaults>;\n}\n\ninterface AxiosResponse<T = any, D = any> {\n  data: T;\n  status: number;\n  statusText: string;\n  headers: RawAxiosResponseHeaders | AxiosResponseHeaders;\n  config: InternalAxiosRequestConfig<D>;\n  request?: any;\n}\n\nclass AxiosError<T = unknown, D = any> extends Error {\n  constructor(\n      message?: string,\n      code?: string,\n      config?: InternalAxiosRequestConfig<D>,\n      request?: any,\n      response?: AxiosResponse<T, D>\n  );\n\n  config?: InternalAxiosRequestConfig<D>;\n  code?: string;\n  request?: any;\n  response?: AxiosResponse<T, D>;\n  isAxiosError: boolean;\n  status?: number;\n  toJSON: () => object;\n  cause?: Error;\n  static from<T = unknown, D = any>(\n    error: Error | unknown,\n    code?: string,\n    config?: InternalAxiosRequestConfig<D>,\n    request?: any,\n    response?: AxiosResponse<T, D>,\n    customProps?: object,\n): AxiosError<T, D>;\n  static readonly ERR_FR_TOO_MANY_REDIRECTS = \"ERR_FR_TOO_MANY_REDIRECTS\";\n  static readonly ERR_BAD_OPTION_VALUE = \"ERR_BAD_OPTION_VALUE\";\n  static readonly ERR_BAD_OPTION = \"ERR_BAD_OPTION\";\n  static readonly ERR_NETWORK = \"ERR_NETWORK\";\n  static readonly ERR_DEPRECATED = \"ERR_DEPRECATED\";\n  static readonly ERR_BAD_RESPONSE = \"ERR_BAD_RESPONSE\";\n  static readonly ERR_BAD_REQUEST = \"ERR_BAD_REQUEST\";\n  static readonly ERR_NOT_SUPPORT = \"ERR_NOT_SUPPORT\";\n  static readonly ERR_INVALID_URL = \"ERR_INVALID_URL\";\n  static readonly ERR_CANCELED = \"ERR_CANCELED\";\n  static readonly ECONNABORTED = \"ECONNABORTED\";\n  static readonly ETIMEDOUT = \"ETIMEDOUT\";\n}\n\nclass CanceledError<T> extends AxiosError<T> {\n}\n\ntype AxiosPromise<T = any> = Promise<AxiosResponse<T>>;\n\ninterface CancelStatic {\n  new (message?: string): Cancel;\n}\n\ninterface Cancel {\n  message: string | undefined;\n}\n\ninterface Canceler {\n  (message?: string, config?: AxiosRequestConfig, request?: any): void;\n}\n\ninterface CancelTokenStatic {\n  new (executor: (cancel: Canceler) => void): CancelToken;\n  source(): CancelTokenSource;\n}\n\ninterface CancelToken {\n  promise: Promise<Cancel>;\n  reason?: Cancel;\n  throwIfRequested(): void;\n}\n\ninterface CancelTokenSource {\n  token: CancelToken;\n  cancel: Canceler;\n}\n\ninterface AxiosInterceptorOptions {\n  synchronous?: boolean;\n  runWhen?: (config: InternalAxiosRequestConfig) => boolean;\n}\n\ninterface AxiosInterceptorManager<V> {\n  use(onFulfilled?: ((value: V) => V | Promise<V>) | null, onRejected?: ((error: any) => any) | null, options?: AxiosInterceptorOptions): number;\n  eject(id: number): void;\n  clear(): void;\n}\n\nclass Axios {\n  constructor(config?: AxiosRequestConfig);\n  defaults: AxiosDefaults;\n  interceptors: {\n    request: AxiosInterceptorManager<InternalAxiosRequestConfig>;\n    response: AxiosInterceptorManager<AxiosResponse>;\n  };\n  getUri(config?: AxiosRequestConfig): string;\n  request<T = any, R = AxiosResponse<T>, D = any>(config: AxiosRequestConfig<D>): Promise<R>;\n  get<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;\n  delete<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;\n  head<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;\n  options<T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;\n  post<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;\n  put<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;\n  patch<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;\n  postForm<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;\n  putForm<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;\n  patchForm<T = any, R = AxiosResponse<T>, D = any>(url: string, data?: D, config?: AxiosRequestConfig<D>): Promise<R>;\n}\n\ninterface AxiosInstance extends Axios {\n  <T = any, R = AxiosResponse<T>, D = any>(config: AxiosRequestConfig<D>): Promise<R>;\n  <T = any, R = AxiosResponse<T>, D = any>(url: string, config?: AxiosRequestConfig<D>): Promise<R>;\n\n  defaults: Omit<AxiosDefaults, 'headers'> & {\n    headers: HeadersDefaults & {\n      [key: string]: AxiosHeaderValue\n    }\n  };\n}\n\ninterface GenericFormData {\n  append(name: string, value: any, options?: any): any;\n}\n\ninterface GenericHTMLFormElement {\n  name: string;\n  method: string;\n  submit(): void;\n}\n\nfunction getAdapter(adapters: AxiosAdapterConfig | AxiosAdapterConfig[] | undefined): AxiosAdapter;\n\nfunction toFormData(sourceObj: object, targetFormData?: GenericFormData, options?: FormSerializerOptions): GenericFormData;\n\nfunction formToJSON(form: GenericFormData|GenericHTMLFormElement): object;\n\nfunction isAxiosError<T = any, D = any>(payload: any): payload is AxiosError<T, D>;\n\nfunction spread<T, R>(callback: (...args: T[]) => R): (array: T[]) => R;\n\nfunction isCancel(value: any): value is Cancel;\n\nfunction all<T>(values: Array<T | Promise<T>>): Promise<T[]>;\n\ninterface AxiosStatic extends AxiosInstance {\n  create(config?: CreateAxiosDefaults): AxiosInstance;\n  Cancel: CancelStatic;\n  CancelToken: CancelTokenStatic;\n  Axios: typeof Axios;\n  AxiosError: typeof AxiosError;\n  HttpStatusCode: typeof HttpStatusCode;\n  readonly VERSION: string;\n  isCancel: typeof isCancel;\n  all: typeof all;\n  spread: typeof spread;\n  isAxiosError: typeof isAxiosError;\n  toFormData: typeof toFormData;\n  formToJSON: typeof formToJSON;\n  getAdapter: typeof getAdapter;\n  CanceledError: typeof CanceledError;\n  AxiosHeaders: typeof AxiosHeaders;\n}\n\ndeclare const axios: AxiosStatic;\n\ndefault axios;\n","file://node_modules/form-data/package.json":"{\"name\":\"form-data\",\"types\":\"./index.d.ts\"}","file://node_modules/form-data/index.d.ts":"// Definitions by: Carlos Ballesteros Velasco <https://github.com/soywiz>\n//                 Leon Yu <https://github.com/leonyu>\n//                 BendingBender <https://github.com/BendingBender>\n//                 Maple Miao <https://github.com/mapleeit>\n\n/// <reference types=\"node\" />\n\n= FormData;\n\n// Extracted because @types/node doesn't export interfaces.\ninterface ReadableOptions {\n  highWaterMark?: number;\n  encoding?: string;\n  objectMode?: boolean;\n  read?(this: stream.Readable, size: number): void;\n  destroy?(this: stream.Readable, error: Error | null, callback: (error: Error | null) => void): void;\n  autoDestroy?: boolean;\n}\n\ninterface Options extends ReadableOptions {\n  writable?: boolean;\n  readable?: boolean;\n  dataSize?: number;\n  maxDataSize?: number;\n  pauseStreams?: boolean;\n}\n\ndeclare class FormData extends stream.Readable {\n  constructor(options?: Options);\n  append(key: string, value: any, options?: FormData.AppendOptions | string): void;\n  getHeaders(userHeaders?: FormData.Headers): FormData.Headers;\n  submit(\n    params: string | FormData.SubmitOptions,\n    callback?: (error: Error | null, response: http.IncomingMessage) => void\n  ): http.ClientRequest;\n  getBuffer(): Buffer;\n  setBoundary(boundary: string): void;\n  getBoundary(): string;\n  getLength(callback: (err: Error | null, length: number) => void): void;\n  getLengthSync(): number;\n  hasKnownLength(): boolean;\n}\n\ndeclare namespace FormData {\n  interface Headers {\n    [key: string]: any;\n  }\n\n  interface AppendOptions {\n    header?: string | Headers;\n    knownLength?: number;\n    filename?: string;\n    filepath?: string;\n    contentType?: string;\n  }\n\n  interface SubmitOptions extends http.RequestOptions {\n    protocol?: 'https:' | 'http:';\n  }\n}\n","file://node_modules/@takaro/helpers/package.json":"{\"name\":\"@takaro/helpers\",\"types\":\"dist/main.d.ts\"}","file://node_modules/@takaro/helpers/dist/TakaroUserError.d.ts":"declare class TakaroUserError extends Error {\n    constructor(message: string);\n}\n","file://node_modules/@takaro/helpers/dist/checkPermission.d.ts":"declare function checkPermission(player: PlayerOnGameserverOutputWithRolesDTO, permission: string): any;\n","file://node_modules/@takaro/helpers/dist/config.d.ts":"declare const config: any;\n","file://node_modules/@takaro/helpers/dist/getData.d.ts":"declare function getData(): any;\n","file://node_modules/@takaro/helpers/dist/getTakaro.d.ts":"/// <reference types=\"node\" resolution-mode=\"require\"/>\ndeclare function getTakaro(data: Record<string, any>, logger?: Pick<Console, 'log' | 'debug' | 'error' | 'warn' | 'info'>): {\n    takaro: Client;\n    data: Record<string, any>;\n};\n","file://node_modules/@takaro/helpers/dist/main.d.ts":"{ getTakaro } from './getTakaro.js';\n{ checkPermission } from './checkPermission.js';\n{ nextCronJobRun } from './nextCronJobRun.js';\n{ TakaroUserError } from './TakaroUserError.js';\n* as _ from 'lodash-es';\n* as axios from 'axios';\n","file://node_modules/@takaro/helpers/dist/nextCronJobRun.d.ts":"declare const nextCronJobRun: (cron: string) => Date | null;\n","file://node_modules/croner/package.json":"{\"name\":\"croner\",\"types\":\"./types/croner.d.ts\"}","file://node_modules/croner/./types/croner.d.ts":"type TimePoint = {\n    /**\n     * - 1970--\n     */\n    y: number;\n    /**\n     * - 1-12\n     */\n    m: number;\n    /**\n     * - 1-31\n     */\n    d: number;\n    /**\n     * - 0-24\n     */\n    h: number;\n    /**\n     * - 0-60 Minute\n     */\n    i: number;\n    /**\n     * - 0-60\n     */\n    s: number;\n    /**\n     * - Time zone in IANA database format 'Europe/Stockholm'\n     */\n    tz: string;\n};\ntype CatchCallbackFn = (e: unknown, job: Cron) => any;\ntype ProtectCallbackFn = (job: Cron) => any;\n/**\n * - Cron scheduler options\n */\ntype CronOptions = {\n    /**\n     * - Name of a job\n     */\n    name?: string;\n    /**\n     * - Job is paused\n     */\n    paused?: boolean;\n    /**\n     * - Job is about to be killed or killed\n     */\n    kill?: boolean;\n    /**\n     * - Continue exection even if a unhandled error is thrown by triggered function\n     * - If set to a function, execute function on catching the error.\n     */\n    catch?: boolean | CatchCallbackFn;\n    /**\n     * - Abort job instantly if nothing else keeps the event loop running.\n     */\n    unref?: boolean;\n    /**\n     * - Maximum nuber of executions\n     */\n    maxRuns?: number;\n    /**\n     * - Minimum interval between executions, in seconds\n     */\n    interval?: number;\n    /**\n     * - Skip current run if job is already running\n     */\n    protect?: boolean | ProtectCallbackFn;\n    /**\n     * - When to start running\n     */\n    startAt?: string | Date;\n    /**\n     * - When to stop running\n     */\n    stopAt?: string | Date;\n    /**\n     * - Time zone in Europe/Stockholm format\n     */\n    timezone?: string;\n    /**\n     * - Offset from UTC in minutes\n     */\n    utcOffset?: number;\n    /**\n     * - Combine day-of-month and day-of-week using true = OR, false = AND. Default is true = OR.\n     */\n    legacyMode?: boolean;\n    /**\n     * - Used to pass any object to scheduled function\n     */\n    context?: unknown;\n};\n/**\n * Name for each part of the cron pattern\n */\ntype CronPatternPart = (\"second\" | \"minute\" | \"hour\" | \"day\" | \"month\" | \"dayOfWeek\");\n/**\n * Offset, 0 or -1.\n *\n * 0 offset is used for seconds,minutes and hours as they start on 1.\n * -1 on days and months, as they start on 0\n */\ntype CronIndexOffset = number;\n/**\n * Cron entrypoint\n *\n * @constructor\n * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string\n * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern\n * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern\n * @returns {Cron}\n */\nfunction Cron(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function): Cron;\nclass Cron {\n    /**\n     * Cron entrypoint\n     *\n     * @constructor\n     * @param {string|Date} pattern - Input pattern, input date, or input ISO 8601 time string\n     * @param {CronOptions|Function} [fnOrOptions1] - Options or function to be run each iteration of pattern\n     * @param {CronOptions|Function} [fnOrOptions2] - Options or function to be run each iteration of pattern\n     * @returns {Cron}\n     */\n    constructor(pattern: string | Date, fnOrOptions1?: CronOptions | Function, fnOrOptions2?: CronOptions | Function);\n    /**\n     * @public\n     * @type {string|undefined} */\n    public name: string | undefined;\n    /**\n     * @public\n     * @type {CronOptions} */\n    public options: CronOptions;\n    /**\n     * Encapsulate all internal states in an object.\n     * Duplicate all options that can change to internal states, for example maxRuns and paused.\n     * @private\n     */\n    private _states;\n    fn: Function | CronOptions;\n    /**\n     * Find next runtime, based on supplied date. Strips milliseconds.\n     *\n     * @param {CronDate|Date|string} [prev] - Date to start from\n     * @returns {Date | null} - Next run time\n     */\n    nextRun(prev?: CronDate | Date | string): Date | null;\n    /**\n     * Find next n runs, based on supplied date. Strips milliseconds.\n     *\n     * @param {number} n - Number of runs to enumerate\n     * @param {Date|string} [previous] - Date to start from\n     * @returns {Date[]} - Next n run times\n     */\n    nextRuns(n: number, previous?: Date | string): Date[];\n    /**\n     * Return the original pattern, if there was one\n     *\n     * @returns {string|undefined} - Original pattern\n     */\n    getPattern(): string | undefined;\n    /**\n     * Indicates whether or not the cron job is scheduled and running, e.g. awaiting next trigger\n     * @public\n     *\n     * @returns {boolean} - Running or not\n     */\n    public isRunning(): boolean;\n    /**\n     * Indicates whether or not the cron job is permanently stopped\n     * @public\n     *\n     * @returns {boolean} - Running or not\n     */\n    public isStopped(): boolean;\n    /**\n     * Indicates whether or not the cron job is currently working\n     * @public\n     *\n     * @returns {boolean} - Running or not\n     */\n    public isBusy(): boolean;\n    /**\n     * Return current/previous run start time\n     * @public\n     *\n     * @returns {Date | null} - Previous run time\n     */\n    public currentRun(): Date | null;\n    /**\n     * Return previous run start time\n     * @public\n     *\n     * @returns {Date | null} - Previous run time\n     */\n    public previousRun(): Date | null;\n    /**\n     * Returns number of milliseconds to next run\n     * @public\n     *\n     * @param {CronDate|Date|string} [prev] - Starting date, defaults to now - minimum interval\n     * @returns {number | null}\n     */\n    public msToNext(prev?: CronDate | Date | string): number | null;\n    /**\n     * Stop execution\n     *\n     * Running this will forcefully stop the job, and prevent furter exection. `.resume()` will not work after stopping.\n     * It will also be removed from the scheduledJobs array if it were named.\n     *\n     * @public\n     */\n    public stop(): void;\n    /**\n     * Pause execution\n     * @public\n     *\n     * @returns {boolean} - Wether pause was successful\n     */\n    public pause(): boolean;\n    /**\n     * Resume execution\n     * @public\n     *\n     * @returns {boolean} - Wether resume was successful\n     */\n    public resume(): boolean;\n    /**\n     * Schedule a new job\n     * @public\n     *\n     * @param {Function} func - Function to be run each iteration of pattern\n     * @returns {Cron}\n     */\n    public schedule(func: Function): Cron;\n    private _trigger;\n    /**\n     * Trigger a run manually\n     * @public\n     */\n    public trigger(): Promise<void>;\n    private _checkTrigger;\n    private _next;\n    private _calculatePreviousRun;\n}\nnamespace Cron {\n    export { Cron };\n    export { scheduledJobs };\n}\n/**\n * An array containing all named cron jobs.\n *\n * @constant\n * @type {Cron[]}\n */\nconst scheduledJobs: Cron[];\n/**\n * Converts date to CronDate\n * @constructor\n *\n * @param {CronDate|Date|string} [d] - Input date, if using string representation ISO 8001 (2015-11-24T19:40:00) local timezone is expected\n * @param {string|number} [tz] - String representation of target timezone in Europe/Stockholm format, or a number representing offset in minutes.\n*/\ndeclare function CronDate(d?: CronDate | Date | string, tz?: string | number): void;\ndeclare class CronDate {\n    /**\n     * Converts date to CronDate\n     * @constructor\n     *\n     * @param {CronDate|Date|string} [d] - Input date, if using string representation ISO 8001 (2015-11-24T19:40:00) local timezone is expected\n     * @param {string|number} [tz] - String representation of target timezone in Europe/Stockholm format, or a number representing offset in minutes.\n    */\n    constructor(d?: CronDate | Date | string, tz?: string | number);\n    /**\n     * TimeZone\n     * @type {string|number|undefined}\n     */\n    tz: string | number | undefined;\n    private isNthWeekdayOfMonth;\n    private fromDate;\n    ms: number;\n    second: number;\n    minute: number;\n    hour: number;\n    day: number;\n    month: number;\n    year: number;\n    private fromCronDate;\n    private apply;\n    private fromString;\n    private findNext;\n    private recurse;\n    /**\n     * Increment to next run time\n     * @public\n     *\n     * @param {string} pattern - The pattern used to increment current state\n     * @param {CronOptions} options - Cron options used for incrementing\n     * @param {boolean} [hasPreviousRun] - If this run should adhere to minimum interval\n     * @return {CronDate|null} - Returns itthis for chaining, or null if increment wasnt possible\n     */\n    public increment(pattern: string, options: CronOptions, hasPreviousRun?: boolean): CronDate | null;\n    /**\n     * Convert current state back to a javascript Date()\n     * @public\n     *\n     * @param {boolean} internal - If this is an internal call\n     * @returns {Date}\n     */\n    public getDate(internal: boolean): Date;\n    /**\n     * Convert current state back to a javascript Date() and return UTC milliseconds\n     * @public\n     *\n     * @returns {Date}\n     */\n    public getTime(): Date;\n}\n{ Cron as default };\n","file://node_modules/@takaro/queues/package.json":"{\"name\":\"@takaro/queues\",\"types\":\"dist/main.d.ts\"}","file://node_modules/@takaro/queues/dist/QueueService.d.ts":"declare class QueuesService {\n    private static instance;\n    static getInstance(): QueuesService;\n    disconnect(): Promise<void>;\n    private queuesMap;\n    get queues(): {\n        commands: {\n            queue: TakaroQueue<ICommandJobData>;\n        };\n        cronjobs: {\n            queue: TakaroQueue<import(\"./dataDefinitions.js\").IJobData>;\n        };\n        hooks: {\n            queue: TakaroQueue<IHookJobData>;\n        };\n        events: {\n            queue: TakaroQueue<IEventQueueData>;\n        };\n        connector: {\n            queue: TakaroQueue<IConnectorQueueData>;\n        };\n        itemsSync: {\n            queue: TakaroQueue<IGameServerQueueData>;\n        };\n        playerSync: {\n            queue: TakaroQueue<IGameServerQueueData>;\n        };\n        steamSync: {\n            queue: TakaroQueue<IGameServerQueueData>;\n        };\n        csmmImport: {\n            queue: TakaroQueue<ICSMMImportData>;\n        };\n        kpi: {\n            queue: TakaroQueue<Record<string, unknown>>;\n        };\n        system: {\n            queue: TakaroQueue<Record<string, unknown>>;\n        };\n    };\n}\ndeclare const queueService: QueuesService;\n{};\n","file://node_modules/@takaro/queues/dist/TakaroQueue.d.ts":"declare class TakaroQueue<T extends Record<string, unknown>> {\n    name: string;\n    bullQueue: Queue<T>;\n    constructor(name: string);\n    /**\n     * Generating a job ID like this effectively de-duplicates all jobs with the same data.\n     * @see https://docs.bullmq.io/guide/jobs/job-ids\n     * @param data\n     * @returns\n     */\n    private getJobId;\n    add(data: T, extra?: JobsOptions): Promise<import(\"bullmq\").Job<T, any, string>>;\n    getRepeatableJobs(): Promise<import(\"bullmq\").RepeatableJob[]>;\n    removeRepeatableByKey(id: string): Promise<boolean>;\n}\n","file://node_modules/@takaro/queues/dist/TakaroWorker.d.ts":"declare abstract class TakaroWorker<T> {\n    log: import(\"winston\").Logger;\n    bullWorker: Worker<T, unknown>;\n    constructor(name: string, concurrency: number | undefined, fn: Processor<T, unknown>, extraBullOpts?: WorkerOptions);\n}\n","file://node_modules/@takaro/queues/dist/bullboard.d.ts":"declare function getBullBoard(): any;\n","file://node_modules/@takaro/queues/dist/config.d.ts":"interface IQueuesConfig extends IBaseConfig {\n    queues: {\n        commands: {\n            name: string;\n            concurrency: number;\n        };\n        cronjobs: {\n            name: string;\n            concurrency: number;\n        };\n        hooks: {\n            name: string;\n            concurrency: number;\n        };\n        events: {\n            name: string;\n            concurrency: number;\n        };\n        connector: {\n            name: string;\n        };\n        itemsSync: {\n            name: string;\n            interval: number;\n        };\n        steamSync: {\n            name: string;\n            interval: number;\n        };\n        playerSync: {\n            name: string;\n            interval: number;\n            concurrency: number;\n        };\n        kpi: {\n            name: string;\n            interval: number;\n            concurrency: number;\n        };\n        csmmImport: {\n            name: string;\n        };\n        system: {\n            name: string;\n        };\n    };\n    redis: {\n        host: string;\n        port: number;\n        username: string;\n        password: string;\n    };\n}\ndeclare const queuesConfigSchema: {\n    redis: {\n        host: {\n            doc: string;\n            format: StringConstructor;\n            default: string;\n            env: string;\n        };\n        port: {\n            doc: string;\n            format: NumberConstructor;\n            default: number;\n            env: string;\n        };\n        username: {\n            doc: string;\n            format: StringConstructor;\n            default: string;\n            env: string;\n        };\n        password: {\n            doc: string;\n            format: StringConstructor;\n            default: string;\n            env: string;\n        };\n    };\n    queues: {\n        commands: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n            concurrency: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n        };\n        cronjobs: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n            concurrency: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n        };\n        hooks: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n            concurrency: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n        };\n        events: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n            concurrency: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n        };\n        connector: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n        };\n        itemsSync: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n            interval: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n        };\n        steamSync: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n            interval: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n        };\n        playerSync: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n            interval: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n            concurrency: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n        };\n        kpi: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n            interval: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n            concurrency: {\n                doc: string;\n                format: NumberConstructor;\n                default: number;\n                env: string;\n            };\n        };\n        csmmImport: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n        };\n        system: {\n            name: {\n                doc: string;\n                format: StringConstructor;\n                default: string;\n                env: string;\n            };\n        };\n    };\n};\ndeclare const config: Config<IQueuesConfig>;\n","file://node_modules/@takaro/queues/dist/dataDefinitions.d.ts":"interface IParsedCommand {\n    command: string;\n    arguments: Record<string, string | number | boolean | PlayerOnGameserverOutputWithRolesDTO>;\n    [key: string]: string | Record<string, string | number | boolean | PlayerOnGameserverOutputWithRolesDTO>;\n}\ninterface IBaseJobData {\n    [key: string]: unknown;\n    domainId: string;\n}\ninterface IJobData extends IBaseJobData {\n    functionId: string;\n    /**\n     * The id of the item that triggered this job (cronjobId, commandId or hookId)\n     */\n    itemId: string;\n    /**\n     * The id of the gameserver that triggered this job\n     */\n    gameServerId: string;\n    /**\n     * The module installation object, including the configs\n     */\n    module: ModuleInstallationOutputDTO;\n}\ninterface IHookJobData extends IJobData {\n    eventData: EventPayload;\n    player?: PlayerOutputWithRolesDTO;\n    pog?: PlayerOnGameserverOutputWithRolesDTO;\n}\ninterface ICommandJobData extends IJobData {\n    player: PlayerOutputWithRolesDTO;\n    pog: PlayerOnGameserverOutputWithRolesDTO;\n    arguments: IParsedCommand['arguments'];\n    chatMessage: EventChatMessage;\n    trigger: string;\n}\ntype ICronJobData = IJobData;\ndeclare function isCommandData(data: IJobData): data is ICommandJobData;\ndeclare function isHookData(data: IJobData): data is IHookJobData;\ndeclare function isCronData(data: IJobData): data is ICronJobData;\ninterface IEventQueueData extends IBaseJobData {\n    type: ValueOf<typeof GameEvents>;\n    gameServerId: string;\n    event: ValueOf<(typeof GameEventsMapping)[ValueOf<typeof GameEvents>]>;\n}\ninterface IConnectorQueueData extends IBaseJobData {\n    gameServerId: string;\n    operation: 'create' | 'update' | 'delete';\n}\ninterface IGameServerQueueData extends IBaseJobData {\n    gameServerId?: string;\n}\ninterface ICSMMImportData extends IBaseJobData {\n    csmmExport: Record<string, unknown>;\n}\n","file://node_modules/@takaro/queues/dist/main.d.ts":"{ queueService } from './QueueService.js';\n{ queuesConfigSchema, IQueuesConfig } from './config.js';\n* from './dataDefinitions.js';\n{ TakaroQueue } from './TakaroQueue.js';\n{ TakaroWorker } from './TakaroWorker.js';\n{ getBullBoard } from './bullboard.js';\n","file://node_modules/@takaro/queues/dist/util/redisConnectionOptions.d.ts":"declare function getRedisConnectionOptions(): {\n    host: string;\n    port: number;\n    username: string;\n    password: string;\n};\n","file://node_modules/chalk/package.json":"{\"name\":\"chalk\",\"types\":\"types/index.d.ts\"}","file://node_modules/chalk/types/index.d.ts":"// Type definitions for Chalk\n// Definitions by: Thomas Sauer <https://github.com/t-sauer>\n\nconst enum Level {\n\tNone = 0,\n\tBasic = 1,\n\tAnsi256 = 2,\n\tTrueColor = 3\n}\n\ninterface ChalkOptions {\n\tenabled?: boolean;\n\tlevel?: Level;\n}\n\ninterface ChalkConstructor {\n\tnew (options?: ChalkOptions): Chalk;\n\t(options?: ChalkOptions): Chalk;\n}\n\ninterface ColorSupport {\n\tlevel: Level;\n\thasBasic: boolean;\n\thas256: boolean;\n\thas16m: boolean;\n}\n\ninterface Chalk {\n\t(...text: string[]): string;\n\t(text: TemplateStringsArray, ...placeholders: string[]): string;\n\tconstructor: ChalkConstructor;\n\tenabled: boolean;\n\tlevel: Level;\n\trgb(r: number, g: number, b: number): this;\n\thsl(h: number, s: number, l: number): this;\n\thsv(h: number, s: number, v: number): this;\n\thwb(h: number, w: number, b: number): this;\n\tbgHex(color: string): this;\n\tbgKeyword(color: string): this;\n\tbgRgb(r: number, g: number, b: number): this;\n\tbgHsl(h: number, s: number, l: number): this;\n\tbgHsv(h: number, s: number, v: number): this;\n\tbgHwb(h: number, w: number, b: number): this;\n\thex(color: string): this;\n\tkeyword(color: string): this;\n\n\treadonly reset: this;\n\treadonly bold: this;\n\treadonly dim: this;\n\treadonly italic: this;\n\treadonly underline: this;\n\treadonly inverse: this;\n\treadonly hidden: this;\n\treadonly strikethrough: this;\n\n\treadonly visible: this;\n\n\treadonly black: this;\n\treadonly red: this;\n\treadonly green: this;\n\treadonly yellow: this;\n\treadonly blue: this;\n\treadonly magenta: this;\n\treadonly cyan: this;\n\treadonly white: this;\n\treadonly gray: this;\n\treadonly grey: this;\n\treadonly blackBright: this;\n\treadonly redBright: this;\n\treadonly greenBright: this;\n\treadonly yellowBright: this;\n\treadonly blueBright: this;\n\treadonly magentaBright: this;\n\treadonly cyanBright: this;\n\treadonly whiteBright: this;\n\n\treadonly bgBlack: this;\n\treadonly bgRed: this;\n\treadonly bgGreen: this;\n\treadonly bgYellow: this;\n\treadonly bgBlue: this;\n\treadonly bgMagenta: this;\n\treadonly bgCyan: this;\n\treadonly bgWhite: this;\n\treadonly bgBlackBright: this;\n\treadonly bgRedBright: this;\n\treadonly bgGreenBright: this;\n\treadonly bgYellowBright: this;\n\treadonly bgBlueBright: this;\n\treadonly bgMagentaBright: this;\n\treadonly bgCyanBright: this;\n\treadonly bgWhiteBright: this;\n}\n\ndeclare const chalk: Chalk & { supportsColor: ColorSupport };\n\ndefault chalk\n","file://node_modules/filelist/package.json":"{\"name\":\"filelist\",\"types\":\"index.d.ts\"}","file://node_modules/filelist/index.d.ts":"// IncludeOptions definitions copied from minimatch (https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/minimatch/index.d.ts)\ninterface IncludeOptions {\n  /**\n   * Dump a ton of stuff to stderr.\n   *\n   * @default false\n   */\n  debug?: boolean;\n\n  /**\n   * Do not expand {a,b} and {1..3} brace sets.\n   *\n   * @default false\n   */\n  nobrace?: boolean;\n\n  /**\n   * Disable ** matching against multiple folder names.\n   *\n   * @default false\n   */\n  noglobstar?: boolean;\n\n  /**\n   * Allow patterns to match filenames starting with a period,\n   * even if the pattern does not explicitly have a period in that spot.\n   *\n   * @default false\n   */\n  dot?: boolean;\n\n  /**\n   * Disable \"extglob\" style patterns like +(a|b).\n   *\n   * @default false\n   */\n  noext?: boolean;\n\n  /**\n   * Perform a case-insensitive match.\n   *\n   * @default false\n   */\n  nocase?: boolean;\n\n  /**\n   * When a match is not found by minimatch.match,\n   * return a list containing the pattern itself if this option is set.\n   * Otherwise, an empty list is returned if there are no matches.\n   *\n   * @default false\n   */\n  nonull?: boolean;\n\n  /**\n   * If set, then patterns without slashes will be matched against\n   * the basename of the path if it contains slashes.\n   *\n   * @default false\n   */\n  matchBase?: boolean;\n\n  /**\n   * Suppress the behavior of treating #\n   * at the start of a pattern as a comment.\n   *\n   * @default false\n   */\n  nocomment?: boolean;\n\n  /**\n   * Suppress the behavior of treating a leading ! character as negation.\n   *\n   * @default false\n   */\n  nonegate?: boolean;\n\n  /**\n   * Returns from negate expressions the same as if they were not negated.\n   * (Ie, true on a hit, false on a miss.)\n   *\n   * @default false\n   */\n  flipNegate?: boolean;\n}\n\nclass FileList {\n  static clone(): FileList\n  static verbose: boolean\n}\n\ninterface FileList extends Omit<Array<string>, \"length\"> {\n  pendingAdd: string[]\n  pending: boolean\n  excludes: {\n    pats: RegExp[],\n    funcs: Function[],\n    regex: null | RegExp\n  }\n  items: string[]\n  toArray(): string[]\n  include(...items: string[]): this\n  include(...items: (IncludeOptions | string)[]): this\n  exclude(...items: string[]): this\n  shouldExclude(item: string): boolean\n  resolve(): this\n  clearInclusions(): this\n  clearExclusions(): this\n  length(): number\n}","file://node_modules/setprototypeof/package.json":"{\"name\":\"setprototypeof\",\"types\":\"index.d.ts\"}","file://node_modules/setprototypeof/index.d.ts":"declare function setPrototypeOf(o: any, proto: object | null): any;\n= setPrototypeOf;\n","file://node_modules/iconv-lite/package.json":"{\"name\":\"iconv-lite\",\"types\":\"./lib/index.d.ts\"}","file://node_modules/iconv-lite/./lib/index.d.ts":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License.\n *  REQUIREMENT: This definition is dependent on the @types/node definition.\n *  Install with `npm install @types/node --save-dev`\n *--------------------------------------------------------------------------------------------*/\n\ndeclare module 'iconv-lite' {\n\texport function decode(buffer: Buffer, encoding: string, options?: Options): string;\n\n\texport function encode(content: string, encoding: string, options?: Options): Buffer;\n\n\texport function encodingExists(encoding: string): boolean;\n\n\texport function decodeStream(encoding: string, options?: Options): NodeJS.ReadWriteStream;\n\n\texport function encodeStream(encoding: string, options?: Options): NodeJS.ReadWriteStream;\n}\n\ninterface Options {\n    stripBOM?: boolean;\n    addBOM?: boolean;\n    defaultEncoding?: string;\n}\n","file://node_modules/side-channel/package.json":"{\"name\":\"side-channel\",\"types\":\"./index.d.ts\"}","file://node_modules/side-channel/index.d.ts":"declare namespace getSideChannel {\n\ttype Key = unknown;\n\ttype ListNode<T> = {\n\t\tkey: Key;\n\t\tnext: ListNode<T>;\n\t\tvalue: T;\n\t};\n\ttype RootNode<T> = {\n\t\tkey: object;\n\t\tnext: null | ListNode<T>;\n\t};\n\tfunction listGetNode<T>(list: RootNode<T>, key: ListNode<T>['key']): ListNode<T> | void;\n\tfunction listGet<T>(objects: RootNode<T>, key: ListNode<T>['key']): T | void;\n\tfunction listSet<T>(objects: RootNode<T>, key: ListNode<T>['key'], value: T): void;\n\tfunction listHas<T>(objects: RootNode<T>, key: ListNode<T>['key']): boolean;\n\n\ttype Channel = {\n\t\tassert: (key: Key) => void;\n\t\thas: (key: Key) => boolean;\n\t\tget: <T>(key: Key) => T;\n\t\tset: <T>(key: Key, value: T) => void;\n\t}\n}\n\ndeclare function getSideChannel(): getSideChannel.Channel;\n\n= getSideChannel;\n","file://node_modules/es-define-property/package.json":"{\"name\":\"es-define-property\",\"types\":\"./index.d.ts\"}","file://node_modules/es-define-property/index.d.ts":"declare const defineProperty: false | typeof Object.defineProperty;\n\n= defineProperty;","file://node_modules/hasown/package.json":"{\"name\":\"hasown\",\"types\":\"index.d.ts\"}","file://node_modules/hasown/index.d.ts":"declare function hasOwn<O, K extends PropertyKey, V = unknown>(o: O, p: K): o is O & Record<K, V>;\n\n= hasOwn;\n","file://node_modules/define-data-property/package.json":"{\"name\":\"define-data-property\",\"types\":\"./index.d.ts\"}","file://node_modules/define-data-property/index.d.ts":"\ndeclare function defineDataProperty(\n    obj: Record<PropertyKey, unknown>,\n    property: keyof typeof obj,\n    value: typeof obj[typeof property],\n    nonEnumerable?: boolean | null,\n    nonWritable?: boolean | null,\n    nonConfigurable?: boolean | null,\n    loose?: boolean\n): void;\n\n= defineDataProperty;","file://node_modules/safe-buffer/package.json":"{\"name\":\"safe-buffer\",\"types\":\"index.d.ts\"}","file://node_modules/safe-buffer/index.d.ts":"declare module \"safe-buffer\" {\n  export class Buffer {\n    length: number\n    write(string: string, offset?: number, length?: number, encoding?: string): number;\n    toString(encoding?: string, start?: number, end?: number): string;\n    toJSON(): { type: 'Buffer', data: any[] };\n    equals(otherBuffer: Buffer): boolean;\n    compare(otherBuffer: Buffer, targetStart?: number, targetEnd?: number, sourceStart?: number, sourceEnd?: number): number;\n    copy(targetBuffer: Buffer, targetStart?: number, sourceStart?: number, sourceEnd?: number): number;\n    slice(start?: number, end?: number): Buffer;\n    writeUIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeUIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntLE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    writeIntBE(value: number, offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntLE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readIntBE(offset: number, byteLength: number, noAssert?: boolean): number;\n    readUInt8(offset: number, noAssert?: boolean): number;\n    readUInt16LE(offset: number, noAssert?: boolean): number;\n    readUInt16BE(offset: number, noAssert?: boolean): number;\n    readUInt32LE(offset: number, noAssert?: boolean): number;\n    readUInt32BE(offset: number, noAssert?: boolean): number;\n    readInt8(offset: number, noAssert?: boolean): number;\n    readInt16LE(offset: number, noAssert?: boolean): number;\n    readInt16BE(offset: number, noAssert?: boolean): number;\n    readInt32LE(offset: number, noAssert?: boolean): number;\n    readInt32BE(offset: number, noAssert?: boolean): number;\n    readFloatLE(offset: number, noAssert?: boolean): number;\n    readFloatBE(offset: number, noAssert?: boolean): number;\n    readDoubleLE(offset: number, noAssert?: boolean): number;\n    readDoubleBE(offset: number, noAssert?: boolean): number;\n    swap16(): Buffer;\n    swap32(): Buffer;\n    swap64(): Buffer;\n    writeUInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeUInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt8(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt16BE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32LE(value: number, offset: number, noAssert?: boolean): number;\n    writeInt32BE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatLE(value: number, offset: number, noAssert?: boolean): number;\n    writeFloatBE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleLE(value: number, offset: number, noAssert?: boolean): number;\n    writeDoubleBE(value: number, offset: number, noAssert?: boolean): number;\n    fill(value: any, offset?: number, end?: number): this;\n    indexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\n    lastIndexOf(value: string | number | Buffer, byteOffset?: number, encoding?: string): number;\n    includes(value: string | number | Buffer, byteOffset?: number, encoding?: string): boolean;\n\n    /**\n     * Allocates a new buffer containing the given {str}.\n     *\n     * @param str String to store in buffer.\n     * @param encoding encoding to use, optional.  Default is 'utf8'\n     */\n     constructor (str: string, encoding?: string);\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     */\n    constructor (size: number);\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     */\n    constructor (array: Uint8Array);\n    /**\n     * Produces a Buffer backed by the same allocated memory as\n     * the given {ArrayBuffer}.\n     *\n     *\n     * @param arrayBuffer The ArrayBuffer with which to share memory.\n     */\n    constructor (arrayBuffer: ArrayBuffer);\n    /**\n     * Allocates a new buffer containing the given {array} of octets.\n     *\n     * @param array The octets to store.\n     */\n    constructor (array: any[]);\n    /**\n     * Copies the passed {buffer} data onto a new {Buffer} instance.\n     *\n     * @param buffer The buffer to copy.\n     */\n    constructor (buffer: Buffer);\n    prototype: Buffer;\n    /**\n     * Allocates a new Buffer using an {array} of octets.\n     *\n     * @param array\n     */\n    static from(array: any[]): Buffer;\n    /**\n     * When passed a reference to the .buffer property of a TypedArray instance,\n     * the newly created Buffer will share the same allocated memory as the TypedArray.\n     * The optional {byteOffset} and {length} arguments specify a memory range\n     * within the {arrayBuffer} that will be shared by the Buffer.\n     *\n     * @param arrayBuffer The .buffer property of a TypedArray or a new ArrayBuffer()\n     * @param byteOffset\n     * @param length\n     */\n    static from(arrayBuffer: ArrayBuffer, byteOffset?: number, length?: number): Buffer;\n    /**\n     * Copies the passed {buffer} data onto a new Buffer instance.\n     *\n     * @param buffer\n     */\n    static from(buffer: Buffer): Buffer;\n    /**\n     * Creates a new Buffer containing the given JavaScript string {str}.\n     * If provided, the {encoding} parameter identifies the character encoding.\n     * If not provided, {encoding} defaults to 'utf8'.\n     *\n     * @param str\n     */\n    static from(str: string, encoding?: string): Buffer;\n    /**\n     * Returns true if {obj} is a Buffer\n     *\n     * @param obj object to test.\n     */\n    static isBuffer(obj: any): obj is Buffer;\n    /**\n     * Returns true if {encoding} is a valid encoding argument.\n     * Valid string encodings in Node 0.12: 'ascii'|'utf8'|'utf16le'|'ucs2'(alias of 'utf16le')|'base64'|'binary'(deprecated)|'hex'\n     *\n     * @param encoding string to test.\n     */\n    static isEncoding(encoding: string): boolean;\n    /**\n     * Gives the actual byte length of a string. encoding defaults to 'utf8'.\n     * This is not the same as String.prototype.length since that returns the number of characters in a string.\n     *\n     * @param string string to test.\n     * @param encoding encoding used to evaluate (defaults to 'utf8')\n     */\n    static byteLength(string: string, encoding?: string): number;\n    /**\n     * Returns a buffer which is the result of concatenating all the buffers in the list together.\n     *\n     * If the list has no items, or if the totalLength is 0, then it returns a zero-length buffer.\n     * If the list has exactly one item, then the first item of the list is returned.\n     * If the list has more than one item, then a new Buffer is created.\n     *\n     * @param list An array of Buffer objects to concatenate\n     * @param totalLength Total length of the buffers when concatenated.\n     *   If totalLength is not provided, it is read from the buffers in the list. However, this adds an additional loop to the function, so it is faster to provide the length explicitly.\n     */\n    static concat(list: Buffer[], totalLength?: number): Buffer;\n    /**\n     * The same as buf1.compare(buf2).\n     */\n    static compare(buf1: Buffer, buf2: Buffer): number;\n    /**\n     * Allocates a new buffer of {size} octets.\n     *\n     * @param size count of octets to allocate.\n     * @param fill if specified, buffer will be initialized by calling buf.fill(fill).\n     *    If parameter is omitted, buffer will be filled with zeros.\n     * @param encoding encoding used for call to buf.fill while initalizing\n     */\n    static alloc(size: number, fill?: string | Buffer | number, encoding?: string): Buffer;\n    /**\n     * Allocates a new buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafe(size: number): Buffer;\n    /**\n     * Allocates a new non-pooled buffer of {size} octets, leaving memory not initialized, so the contents\n     * of the newly created Buffer are unknown and may contain sensitive data.\n     *\n     * @param size count of octets to allocate\n     */\n    static allocUnsafeSlow(size: number): Buffer;\n  }\n}","file://node_modules/ipaddr.js/package.json":"{\"name\":\"ipaddr.js\",\"types\":\"./lib/ipaddr.js.d.ts\"}","file://node_modules/ipaddr.js/./lib/ipaddr.js.d.ts":"declare module \"ipaddr.js\" {\n    type IPv4Range = 'unicast' | 'unspecified' | 'broadcast' | 'multicast' | 'linkLocal' | 'loopback' | 'carrierGradeNat' | 'private' | 'reserved';\n    type IPv6Range = 'unicast' | 'unspecified' | 'linkLocal' | 'multicast' | 'loopback' | 'uniqueLocal' | 'ipv4Mapped' | 'rfc6145' | 'rfc6052' | '6to4' | 'teredo' | 'reserved';\n\n    interface RangeList<T> {\n        [name: string]: [T, number] | [T, number][];\n    }\n\n    // Common methods/properties for IPv4 and IPv6 classes.\n    class IP {\n        prefixLengthFromSubnetMask(): number | null;\n        toByteArray(): number[];\n        toNormalizedString(): string;\n        toString(): string;\n    }\n\n    namespace Address {\n        export function isValid(addr: string): boolean;\n        export function fromByteArray(bytes: number[]): IPv4 | IPv6;\n        export function parse(addr: string): IPv4 | IPv6;\n        export function parseCIDR(mask: string): [IPv4 | IPv6, number];\n        export function process(addr: string): IPv4 | IPv6;\n        export function subnetMatch(addr: IPv4, rangeList: RangeList<IPv4>, defaultName?: string): string;\n        export function subnetMatch(addr: IPv6, rangeList: RangeList<IPv6>, defaultName?: string): string;\n\n        export class IPv4 extends IP {\n            static broadcastAddressFromCIDR(addr: string): IPv4;\n            static isIPv4(addr: string): boolean;\n            static isValidFourPartDecimal(addr: string): boolean;\n            static isValid(addr: string): boolean;\n            static networkAddressFromCIDR(addr: string): IPv4;\n            static parse(addr: string): IPv4;\n            static parseCIDR(addr: string): [IPv4, number];\n            static subnetMaskFromPrefixLength(prefix: number): IPv4;\n            constructor(octets: number[]);\n            octets: number[]\n\n            kind(): 'ipv4';\n            match(addr: IPv4, bits: number): boolean;\n            match(mask: [IPv4, number]): boolean;\n            range(): IPv4Range;\n            subnetMatch(rangeList: RangeList<IPv4>, defaultName?: string): string;\n            toIPv4MappedAddress(): IPv6;\n        }\n\n        export class IPv6 extends IP {\n            static broadcastAddressFromCIDR(addr: string): IPv6;\n            static isIPv6(addr: string): boolean;\n            static isValid(addr: string): boolean;\n            static parse(addr: string): IPv6;\n            static parseCIDR(addr: string): [IPv6, number];\n            static subnetMaskFromPrefixLength(prefix: number): IPv6;\n            constructor(parts: number[]);\n            parts: number[]\n            zoneId?: string\n\n            isIPv4MappedAddress(): boolean;\n            kind(): 'ipv6';\n            match(addr: IPv6, bits: number): boolean;\n            match(mask: [IPv6, number]): boolean;\n            range(): IPv6Range;\n            subnetMatch(rangeList: RangeList<IPv6>, defaultName?: string): string;\n            toIPv4Address(): IPv4;\n        }\n    }\n\n    export = Address;\n}\n"}
